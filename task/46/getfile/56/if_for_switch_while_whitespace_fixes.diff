Index: station_cmd.c
===================================================================
--- station_cmd.c	(revision 3486)
+++ station_cmd.c	(working copy)
@@ -2706,7 +2706,7 @@
 	st2 = st1 = NULL;
 	best_rating = best_rating2 = 0;
 
-	for( i = 0; i != 8 && around[i] != INVALID_STATION; i++) {
+	for ( i = 0; i != 8 && around[i] != INVALID_STATION; i++) {
 		if (around_ptr[i]->goods[type].rating >= best_rating) {
 			best_rating2 = best_rating;
 			st2 = st1;
Index: graph_gui.c
===================================================================
--- graph_gui.c	(revision 3486)
+++ graph_gui.c	(working copy)
@@ -221,7 +221,7 @@
 {
 	const Player* p;
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		FOR_ALL_PLAYERS(p) {
 			if (!p->is_active) SETBIT(_legend_excludebits, p->index);
@@ -320,7 +320,7 @@
 
 static void OperatingProfitWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		GraphDrawer gd;
 		const Player* p;
@@ -344,7 +344,7 @@
 		FOR_ALL_PLAYERS(p) {
 			if (p->is_active) {
 				gd.colors[numd] = _color_list[p->player_color].window_color_bgb;
-				for(j=gd.num_on_x_axis,i=0; --j >= 0;) {
+				for (j=gd.num_on_x_axis,i=0; --j >= 0;) {
 					gd.cost[numd][i] = (j >= p->num_valid_stat_ent) ? INVALID_VALUE : (uint64)(p->old_economy[j].income + p->old_economy[j].expenses);
 					i++;
 				}
@@ -394,7 +394,7 @@
 
 static void IncomeGraphWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		GraphDrawer gd;
 		const Player* p;
@@ -417,7 +417,7 @@
 		FOR_ALL_PLAYERS(p) {
 			if (p->is_active) {
 				gd.colors[numd] = _color_list[p->player_color].window_color_bgb;
-				for(j=gd.num_on_x_axis,i=0; --j >= 0;) {
+				for (j=gd.num_on_x_axis,i=0; --j >= 0;) {
 					gd.cost[numd][i] = (j >= p->num_valid_stat_ent) ? INVALID_VALUE : (uint64)p->old_economy[j].income;
 					i++;
 				}
@@ -467,7 +467,7 @@
 
 static void DeliveredCargoGraphWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		GraphDrawer gd;
 		const Player* p;
@@ -490,7 +490,7 @@
 		FOR_ALL_PLAYERS(p) {
 			if (p->is_active) {
 				gd.colors[numd] = _color_list[p->player_color].window_color_bgb;
-				for(j=gd.num_on_x_axis,i=0; --j >= 0;) {
+				for (j=gd.num_on_x_axis,i=0; --j >= 0;) {
 					gd.cost[numd][i] = (j >= p->num_valid_stat_ent) ? INVALID_VALUE : (uint64)p->old_economy[j].delivered_cargo;
 					i++;
 				}
@@ -540,7 +540,7 @@
 
 static void PerformanceHistoryWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		GraphDrawer gd;
 		const Player* p;
@@ -563,7 +563,7 @@
 		FOR_ALL_PLAYERS(p) {
 			if (p->is_active) {
 				gd.colors[numd] = _color_list[p->player_color].window_color_bgb;
-				for(j=gd.num_on_x_axis,i=0; --j >= 0;) {
+				for (j=gd.num_on_x_axis,i=0; --j >= 0;) {
 					gd.cost[numd][i] = (j >= p->num_valid_stat_ent) ? INVALID_VALUE : (uint64)p->old_economy[j].performance_history;
 					i++;
 				}
@@ -616,7 +616,7 @@
 
 static void CompanyValueGraphWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		GraphDrawer gd;
 		const Player* p;
@@ -639,7 +639,7 @@
 		FOR_ALL_PLAYERS(p) {
 			if (p->is_active) {
 				gd.colors[numd] = _color_list[p->player_color].window_color_bgb;
-				for(j=gd.num_on_x_axis,i=0; --j >= 0;) {
+				for (j=gd.num_on_x_axis,i=0; --j >= 0;) {
 					gd.cost[numd][i] = (j >= p->num_valid_stat_ent) ? INVALID_VALUE : (uint64)p->old_economy[j].company_value;
 					i++;
 				}
@@ -691,7 +691,7 @@
 
 static void CargoPaymentRatesWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int i, j, x, y;
 		GraphDrawer gd;
@@ -703,7 +703,7 @@
 		x = 495;
 		y = 25;
 
-		for(i=0; i!=NUM_CARGO; i++) {
+		for (i=0; i!=NUM_CARGO; i++) {
 			GfxFillRect(x, y, x+8, y+5, 0);
 			GfxFillRect(x+1, y+1, x+7, y+4, _cargo_legend_colors[i]);
 			SetDParam(0, _cargoc.names_s[i]);
@@ -726,9 +726,9 @@
 		gd.unk61A = 10;
 		gd.unk61C = 10;
 
-		for(i=0; i!=NUM_CARGO; i++) {
+		for (i=0; i!=NUM_CARGO; i++) {
 			gd.colors[i] = _cargo_legend_colors[i];
-			for(j=0; j!=20; j++) {
+			for (j=0; j!=20; j++) {
 				gd.cost[i][j] = (uint64)GetTransportedGoodsIncome(10, 20, j*6+6,i);
 			}
 		}
@@ -740,7 +740,7 @@
 	} break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: case 4: case 5: case 6:
 		case 7: case 8: case 9: case 10:
 		case 11: case 12: case 13: case 14:
@@ -882,7 +882,7 @@
 
 static void PerformanceRatingDetailWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int val, needed, score, i;
 		byte owner, x;
@@ -1134,7 +1134,7 @@
 		error("Could not allocate memory for the sign-sorting-list");
 
 	FOR_ALL_SIGNS(ss) {
-		if(ss->str != STR_NULL) {
+		if (ss->str != STR_NULL) {
 			_sign_sort[n++] = ss->index;
 			_num_sign_sort++;
 		}
Index: aircraft_cmd.c
===================================================================
--- aircraft_cmd.c	(revision 3486)
+++ aircraft_cmd.c	(working copy)
@@ -1836,7 +1836,7 @@
 					//at what terminal does the group start?
 					//that means, sum up all terminals of
 					//groups with lower number
-					for(i = 1; i < target_group; i++)
+					for (i = 1; i < target_group; i++)
 						group_start += Airport->helipads[i];
 
 					group_end = group_start + Airport->helipads[target_group];
Index: npf.c
===================================================================
--- npf.c	(revision 3486)
+++ npf.c	(working copy)
@@ -208,7 +208,7 @@
 	return;
 #else
 	if (_debug_npf_level >= 1)
-		switch(GetTileType(tile)) {
+		switch (GetTileType(tile)) {
 			case MP_RAILWAY:
 				/* DEBUG: mark visited tiles by mowing the grass under them
 				 * ;-) */
Index: music_gui.c
===================================================================
--- music_gui.c	(revision 3486)
+++ music_gui.c	(working copy)
@@ -203,7 +203,7 @@
 
 static void MusicTrackSelectionWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		const byte* p;
 		uint i;
@@ -321,7 +321,7 @@
 
 static void MusicWindowWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		uint i;
 		StringID str;
@@ -393,7 +393,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: // skip to prev
 			if (!_song_is_active)
 				return;
Index: video/cocoa_v.m
===================================================================
--- video/cocoa_v.m	(revision 3486)
+++ video/cocoa_v.m	(working copy)
@@ -332,19 +332,19 @@
 	uint32 key = 0;
 
 	for (map = _vk_mapping; map != endof(_vk_mapping); ++map) {
-		if(sym == map->vk_from) {
+		if (sym == map->vk_from) {
 			key = map->map_to;
 			break;
 		}
 	}
 
-	if(_cocoa_video_data.current_mods & NSShiftKeyMask)
+	if (_cocoa_video_data.current_mods & NSShiftKeyMask)
 		key|= WKC_SHIFT;
-	if(_cocoa_video_data.current_mods & NSControlKeyMask)
+	if (_cocoa_video_data.current_mods & NSControlKeyMask)
 		key|= WKC_CTRL;
-	if(_cocoa_video_data.current_mods & NSAlternateKeyMask)
+	if (_cocoa_video_data.current_mods & NSAlternateKeyMask)
 		key|= WKC_ALT;
-	if(_cocoa_video_data.current_mods & NSCommandKeyMask)
+	if (_cocoa_video_data.current_mods & NSCommandKeyMask)
 		key|= WKC_META;
 
 	return key << 16;
@@ -352,7 +352,7 @@
 
 static void QZ_KeyEvent(unsigned short keycode, unsigned short unicode, BOOL down)
 {
-	switch(keycode)
+	switch (keycode)
 	{
 		case QZ_UP:
 			SB(_dirkeys, 1, 1, down);
@@ -371,12 +371,12 @@
 			break;
 		case QZ_RETURN:
 		case QZ_f:
-			if(down && ((_cocoa_video_data.current_mods & NSControlKeyMask) || (_cocoa_video_data.current_mods & NSCommandKeyMask)))
+			if (down && ((_cocoa_video_data.current_mods & NSControlKeyMask) || (_cocoa_video_data.current_mods & NSCommandKeyMask)))
 				CocoaVideoFullScreen(!_fullscreen);
 
 	}
 
-	if(down) {
+	if (down) {
 		_pressed_key = QZ_MapKey(keycode) | unicode;
 		DEBUG(driver, 2)("cocoa_v: QZ_KeyEvent: %x (%x), down, mapping: %x", keycode, unicode, _pressed_key);
 	} else {
@@ -442,9 +442,9 @@
 
 void QZ_MouseButtonEvent( int button, BOOL down )
 {
-	switch(button) {
+	switch (button) {
 		case 0:
-			if(down) {
+			if (down) {
 				_left_button_down = true;
 			} else {
 				_left_button_down = false;
@@ -452,7 +452,7 @@
 			}
 			break;
 		case 1:
-			if(down) {
+			if (down) {
 				_right_button_down = true;
 				_right_button_clicked = true;
 			} else {
@@ -467,7 +467,7 @@
 {
 	NSPoint pt;
 
-	if(_cocoa_video_data.fullscreen) {
+	if (_cocoa_video_data.fullscreen) {
 		pt = [ NSEvent mouseLocation ];
 		pt.y = _cocoa_video_data.height - pt.y;
 	} else {
@@ -480,7 +480,7 @@
 
 static bool QZ_MouseIsInsideView(NSPoint *pt)
 {
-	if(_cocoa_video_data.fullscreen)
+	if (_cocoa_video_data.fullscreen)
 		return pt->x >= 0 && pt->y >= 0 && pt->x < _cocoa_video_data.width && pt->y < _cocoa_video_data.height;
 	else
 		return [ _cocoa_video_data.qdview mouse:*pt inRect:[ _cocoa_video_data.qdview bounds ] ];
@@ -507,9 +507,9 @@
 	_cocoa_video_data.tEvent+= et - et0;
 #endif
 
-	if(event == nil)
+	if (event == nil)
 		return false;
-	if(!_cocoa_video_data.active) {
+	if (!_cocoa_video_data.active) {
 		QZ_ShowMouse();
 		[NSApp sendEvent:event];
 		return true;
@@ -523,7 +523,7 @@
 		case NSRightMouseDragged:
 		case NSLeftMouseDragged:
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt) && !_cocoa_video_data.emulating_right_button) {
+			if (!QZ_MouseIsInsideView(&pt) && !_cocoa_video_data.emulating_right_button) {
 				QZ_ShowMouse();
 				[NSApp sendEvent:event];
 				break;
@@ -534,11 +534,11 @@
 			break;
 
 		case NSLeftMouseDown:
-			if(!([ event modifierFlags ] & NSCommandKeyMask) || !QZ_MouseIsInsideView(&pt))
+			if (!([ event modifierFlags ] & NSCommandKeyMask) || !QZ_MouseIsInsideView(&pt))
 				[NSApp sendEvent:event];
 
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				break;
 			}
@@ -547,7 +547,7 @@
 			QZ_MouseMovedEvent((int) pt.x, (int) pt.y);
 
 			/* Right mouse button emulation */
-			if([ event modifierFlags ] & NSCommandKeyMask) {
+			if ([ event modifierFlags ] & NSCommandKeyMask) {
 				_cocoa_video_data.emulating_right_button = true;
 				QZ_MouseButtonEvent(1, YES);
 			} else
@@ -557,7 +557,7 @@
 			[NSApp sendEvent:event];
 
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				break;
 			}
@@ -566,7 +566,7 @@
 			QZ_MouseMovedEvent((int) pt.x, (int) pt.y);
 
 			/* Right mouse button emulation */
-			if(_cocoa_video_data.emulating_right_button) {
+			if (_cocoa_video_data.emulating_right_button) {
 				_cocoa_video_data.emulating_right_button = false;
 				QZ_MouseButtonEvent(1, NO);
 			} else
@@ -575,7 +575,7 @@
 
 		case NSRightMouseDown:
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				[NSApp sendEvent:event];
 				break;
@@ -587,7 +587,7 @@
 			break;
 		case NSRightMouseUp:
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				[NSApp sendEvent:event];
 				break;
@@ -602,7 +602,7 @@
 		/*
 		case NSOtherMouseDown:
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				[NSApp sendEvent:event];
 				break;
@@ -614,7 +614,7 @@
 			break;
 		case NSOtherMouseUp:
 			pt = QZ_GetMouseLocation(event);
-			if(!QZ_MouseIsInsideView(&pt)) {
+			if (!QZ_MouseIsInsideView(&pt)) {
 				QZ_ShowMouse();
 				[NSApp sendEvent:event];
 				break;
@@ -627,11 +627,11 @@
 		*/
 		case NSKeyDown:
 			/* Quit, hide and minimize */
-			switch([event keyCode]) {
+			switch ([event keyCode]) {
 				case QZ_q:
 				case QZ_h:
 				case QZ_m:
-					if([ event modifierFlags ] & NSCommandKeyMask)
+					if ([ event modifierFlags ] & NSCommandKeyMask)
 						[NSApp sendEvent:event];
 					break;
 			}
@@ -642,11 +642,11 @@
 
 		case NSKeyUp:
 			/* Quit, hide and minimize */
-			switch([event keyCode]) {
+			switch ([event keyCode]) {
 				case QZ_q:
 				case QZ_h:
 				case QZ_m:
-					if([ event modifierFlags ] & NSCommandKeyMask)
+					if ([ event modifierFlags ] & NSCommandKeyMask)
 						[NSApp sendEvent:event];
 					break;
 			}
@@ -695,7 +695,7 @@
 	QZ_Draw();
 	CSleep(1);
 
-	for(i = 0; i < 2; i++)
+	for (i = 0; i < 2; i++)
 		GameLoop();
 
 	_screen.dst_ptr = _cocoa_video_data.pixels;
@@ -704,7 +704,7 @@
 	QZ_Draw();
 	CSleep(1);
 
-	while(1) {
+	while (1) {
 		InteractiveRandom(); // randomness
 
 		while (QZ_PollEvent()) {}
@@ -713,7 +713,7 @@
 			break;
 
 #if defined(_DEBUG)
-		if(_cocoa_video_data.current_mods & NSShiftKeyMask)
+		if (_cocoa_video_data.current_mods & NSShiftKeyMask)
 #else
 		if (_cocoa_video_data.tab_is_down)
 #endif
@@ -851,10 +851,10 @@
 	[ super setFrame:frameRect display:flag ];
 
 	/* Don't do anything if the window is currently beign created */
-    if(_cocoa_video_data.issetting)
+    if (_cocoa_video_data.issetting)
     	return;
 
-	if(_cocoa_video_data.window == nil)
+	if (_cocoa_video_data.window == nil)
 		return;
 
 	newViewFrame = [ _cocoa_video_data.qdview frame ];
@@ -880,7 +880,7 @@
 	UnlockPortBits ( thePort );
 
 	/* Allocate new buffer */
-	if(_cocoa_video_data.pixels != NULL)
+	if (_cocoa_video_data.pixels != NULL)
 		free(_cocoa_video_data.pixels);
 	_cocoa_video_data.pixels = (uint8 *) malloc(newViewFrame.size.width * newViewFrame.size.height);
 	assert(_cocoa_video_data.pixels != NULL);
@@ -983,7 +983,7 @@
 	uint32 clr32;
 	uint16 clr16;
 
-	switch(_cocoa_video_data.device_bpp)
+	switch (_cocoa_video_data.device_bpp)
 	{
 		case 32:
 			for (i = start; i < start + count; i++) {
@@ -1014,10 +1014,10 @@
 	uint8 *src;
 	int x, y;
 
-	for(y = top; y < bottom; y++) {
+	for (y = top; y < bottom; y++) {
 		trg = ((uint32 *) _cocoa_video_data.realpixels) + y * _cocoa_video_data.pitch / 4 + left;
 		src = _cocoa_video_data.pixels + y * _cocoa_video_data.width + left;
-		for(x = left; x < right; x++, trg++, src++) {
+		for (x = left; x < right; x++, trg++, src++) {
 			*trg = _cocoa_video_data.palette32[*src];
 		}
 	}
@@ -1029,10 +1029,10 @@
 	uint8 *src;
 	int x, y;
 
-	for(y = top; y < bottom; y++) {
+	for (y = top; y < bottom; y++) {
 		trg = ((uint16 *) _cocoa_video_data.realpixels) + y * _cocoa_video_data.pitch / 2 + left;
 		src = _cocoa_video_data.pixels + y * _cocoa_video_data.width + left;
-		for(x = left; x < right; x++, trg++, src++) {
+		for (x = left; x < right; x++, trg++, src++) {
 			*trg = _cocoa_video_data.palette16[*src];
 		}
 	}
@@ -1040,7 +1040,7 @@
 
 static inline void QZ_WindowBlitIndexedPixelsToView(int left, int top, int right, int bottom)
 {
-	switch(_cocoa_video_data.device_bpp)
+	switch (_cocoa_video_data.device_bpp)
 	{
 		case 32:
 			QZ_WindowBlitIndexedPixelsToView32(left, top, right, bottom);
@@ -1077,15 +1077,15 @@
 	xoff = _cocoa_video_data.width - 16;
 	yoff = _cocoa_video_data.height - 16;
 
-	for(y = 0; y < 16; y++) {
+	for (y = 0; y < 16; y++) {
 		trg16 = ((uint16 *) _cocoa_video_data.realpixels) + (yoff + y) * _cocoa_video_data.pitch / 2 + xoff;
 		trg32 = ((uint32 *) _cocoa_video_data.realpixels) + (yoff + y) * _cocoa_video_data.pitch / 4 + xoff;
 
-		for(x = 0; x < 16; x++, trg16++, trg32++) {
-			if(!_resize_icon[y * 16 + x])
+		for (x = 0; x < 16; x++, trg16++, trg32++) {
+			if (!_resize_icon[y * 16 + x])
 				continue;
 
-			switch(_cocoa_video_data.device_bpp)
+			switch (_cocoa_video_data.device_bpp)
 			{
 				case 32:
 					*trg32 = 0xff000000;
@@ -1103,10 +1103,10 @@
 	RgnHandle dirty, temp;
 
 	/* Check if we need to do anything */
-	if(_cocoa_video_data.num_dirty_rects == 0 || [ _cocoa_video_data.window isMiniaturized ])
+	if (_cocoa_video_data.num_dirty_rects == 0 || [ _cocoa_video_data.window isMiniaturized ])
 		return;
 
-	if(_cocoa_video_data.num_dirty_rects >= MAX_DIRTY_RECTS) {
+	if (_cocoa_video_data.num_dirty_rects >= MAX_DIRTY_RECTS) {
 		_cocoa_video_data.num_dirty_rects = 1;
 		_cocoa_video_data.dirty_rects[0].left = 0;
 		_cocoa_video_data.dirty_rects[0].top = 0;
@@ -1151,9 +1151,9 @@
 	NSRect contentRect;
 	BOOL isCustom = NO;
 
-	if(width > _cocoa_video_data.device_width)
+	if (width > _cocoa_video_data.device_width)
 		width = _cocoa_video_data.device_width;
-	if(height > _cocoa_video_data.device_height)
+	if (height > _cocoa_video_data.device_height)
 		height = _cocoa_video_data.device_height;
 
 	_cocoa_video_data.width = width;
@@ -1235,10 +1235,10 @@
 		_cocoa_video_data.realpixels = (uint8 *) _cocoa_video_data.realpixels + (vOffset * _cocoa_video_data.pitch) + hOffset * (_cocoa_video_data.device_bpp / 8);
 	}
 
-	if(_cocoa_video_data.pixels != NULL)
+	if (_cocoa_video_data.pixels != NULL)
 		free(_cocoa_video_data.pixels);
 	_cocoa_video_data.pixels = (uint8 *) malloc(width * height);
-	if(_cocoa_video_data.pixels == NULL)
+	if (_cocoa_video_data.pixels == NULL)
 		return "Failed to allocate 8-bit buffer";
 
 	_cocoa_video_data.fullscreen = false;
@@ -1361,7 +1361,7 @@
 	if ( ! exact_match ) {
 		number = CFDictionaryGetValue (_cocoa_video_data.mode, kCGDisplayBitsPerPixel);
 		CFNumberGetValue (number, kCFNumberSInt32Type, &bpp);
-		if(bpp != 8) {
+		if (bpp != 8) {
 			errstr = "Failed to find display resolution";
 			goto ERR_NO_MATCH;
 		}
@@ -1399,7 +1399,7 @@
 
 	/* Setup double-buffer emulation */
 	_cocoa_video_data.pixels = (uint8 *) malloc(width * height);
-	if(_cocoa_video_data.pixels == NULL) {
+	if (_cocoa_video_data.pixels == NULL) {
 		errstr = "Failed to allocate memory for double buffering";
 		goto ERR_DOUBLEBUF;
 	}
@@ -1432,7 +1432,7 @@
 
 	pt = [ NSEvent mouseLocation ];
 	pt.y = CGDisplayPixelsHigh (_cocoa_video_data.display_id) - pt.y;
-	if(QZ_MouseIsInsideView(&pt))
+	if (QZ_MouseIsInsideView(&pt))
 		QZ_HideMouse();
 
 	return NULL;
@@ -1512,7 +1512,7 @@
 
 	QZ_WaitForVerticalBlank();
 
-	for(y = 0; y < _cocoa_video_data.height; y++) {
+	for (y = 0; y < _cocoa_video_data.height; y++) {
 		src = _cocoa_video_data.pixels + y * _cocoa_video_data.width;
 		dst = ((uint8 *) _cocoa_video_data.realpixels) + y * _cocoa_video_data.pitch;
 
@@ -1577,7 +1577,7 @@
 		int i, j;
 		for (i = 0; i < list_size; i++) {
 			for (j = 0; j < list_size-1; j++) {
-				if(mode_list[j].x > mode_list[j + 1].x || (mode_list[j].x == mode_list[j + 1].x && mode_list[j].y > mode_list[j + 1].y)) {
+				if (mode_list[j].x > mode_list[j + 1].x || (mode_list[j].x == mode_list[j + 1].x && mode_list[j].y > mode_list[j + 1].y)) {
 					uint tmpw = mode_list[j].x;
 					uint tmph = mode_list[j].y;
 
@@ -1614,7 +1614,7 @@
 
 static void QZ_UpdatePalette(uint start, uint count)
 {
-	if(_cocoa_video_data.fullscreen) {
+	if (_cocoa_video_data.fullscreen) {
 		QZ_UpdateFullscreenPalette(start, count);
 	} else {
 		QZ_UpdateWindowPalette(start, count);
@@ -1628,7 +1628,7 @@
 
 static void QZ_Draw(void)
 {
-	if(_cocoa_video_data.fullscreen) {
+	if (_cocoa_video_data.fullscreen) {
 		QZ_DrawScreen();
 	} else {
 		QZ_DrawWindow();
@@ -1656,7 +1656,7 @@
 	OTTDPoint modes[32];
 	const OTTDPoint *current_modes;
 
-	if(_cocoa_video_data.fullscreen) {
+	if (_cocoa_video_data.fullscreen) {
 		count = QZ_ListFullscreenModes(modes, 32);
 		current_modes = modes;
 	} else {
@@ -1664,7 +1664,7 @@
 		current_modes = _default_resolutions;
 	}
 
-	for(i = 0, j = 0; j < lengthof(_resolutions) && i < count; i++) {
+	for (i = 0, j = 0; j < lengthof(_resolutions) && i < count; i++) {
 		if (_cocoa_video_data.fullscreen || ((uint) current_modes[i].x <= _cocoa_video_data.device_width &&
 				  							 (uint) current_modes[i].y <= _cocoa_video_data.device_height)) {
 			_resolutions[j][0] = current_modes[i].x;
@@ -1763,7 +1763,7 @@
 	const char *ret;
 
 	ret = QZ_SetVideoMode(width, height, fullscreen);
-	if(ret != NULL && wasset)
+	if (ret != NULL && wasset)
 		QZ_SetVideoMode(oldwidth, oldheight, oldfullscreen);
 
 	return ret;
@@ -2010,10 +2010,10 @@
 {
 	DEBUG(driver, 1)("cocoa_v: CocoaVideoStop");
 
-	if(!_cocoa_video_started)
+	if (!_cocoa_video_started)
 		return;
 
-	if(_cocoa_video_data.isset)
+	if (_cocoa_video_data.isset)
 		QZ_UnsetVideoMode();
 
 	[_ottd_main release];
@@ -2027,7 +2027,7 @@
 
 	DEBUG(driver, 1)("cocoa_v: CocoaVideoStart");
 
-	if(_cocoa_video_started)
+	if (_cocoa_video_started)
 		return "Already started";
 	_cocoa_video_started = true;
 
@@ -2036,13 +2036,13 @@
 	setupApplication();
 
 	/* Don't create a window or enter fullscreen if we're just going to show a dialog. */
-	if(_cocoa_video_dialog)
+	if (_cocoa_video_dialog)
 		return NULL;
 
 	QZ_VideoInit();
 
 	ret = QZ_SetVideoMode(_cur_resolution[0], _cur_resolution[1], _fullscreen);
-	if(ret != NULL)
+	if (ret != NULL)
 		CocoaVideoStop();
 
 	return ret;
@@ -2073,7 +2073,7 @@
 	DEBUG(driver, 1)("cocoa_v: CocoaVideoChangeRes");
 
 	ret = QZ_SetVideoModeAndRestoreOnFailure((uint) w, (uint) h, _cocoa_video_data.fullscreen);
-	if(ret != NULL) {
+	if (ret != NULL) {
 		DEBUG(driver, 1)("cocoa_v:  failed with message: %s", ret);
 	}
 
@@ -2087,7 +2087,7 @@
 	DEBUG(driver, 1)("cocoa_v: CocoaVideoFullScreen");
 
 	ret = QZ_SetVideoModeAndRestoreOnFailure(_cocoa_video_data.width, _cocoa_video_data.height, full_screen);
-	if(ret != NULL) {
+	if (ret != NULL) {
 		DEBUG(driver, 1)("cocoa_v:  failed with message: %s", ret);
 	}
 
@@ -2114,7 +2114,7 @@
 	_cocoa_video_dialog = true;
 
 	wasstarted = _cocoa_video_started;
-	if(!_cocoa_video_started && CocoaVideoStart(NULL) != NULL) {
+	if (!_cocoa_video_started && CocoaVideoStart(NULL) != NULL) {
 		fprintf(stderr, "%s: %s\n", title, message);
 		return;
 	}
@@ -2122,7 +2122,7 @@
 
 	NSRunAlertPanel([NSString stringWithCString: title], [NSString stringWithCString: message], [NSString stringWithCString: buttonLabel], nil, nil);
 
-	if(!wasstarted)
+	if (!wasstarted)
 		CocoaVideoStop();
 
 	_cocoa_video_dialog = false;
Index: video/sdl_v.c
===================================================================
--- video/sdl_v.c	(revision 3486)
+++ video/sdl_v.c	(working copy)
@@ -140,7 +140,7 @@
 
 	// is the wanted mode among the available modes?
 	for (i = 0; i != _num_resolutions; i++) {
-		if(*w == _resolutions[i][0] && *h == _resolutions[i][1])
+		if (*w == _resolutions[i][0] && *h == _resolutions[i][1])
 			return 1;
 	}
 
@@ -348,7 +348,7 @@
 	case SDL_QUIT:
 		// do not ask to quit on the main screen
 		if (_game_mode != GM_MENU) {
-			if(_patches.autosave_on_exit) {
+			if (_patches.autosave_on_exit) {
 				DoExitSave();
 				return 0;
 			} else
Index: video/win32_v.c
===================================================================
--- video/win32_v.c	(revision 3486)
+++ video/win32_v.c	(working copy)
@@ -709,7 +709,7 @@
 
 	_wnd.running = true;
 
-	while(true) {
+	while (true) {
 		while (PeekMessage(&mesg, NULL, 0, 0, PM_REMOVE)) {
 			InteractiveRandom(); // randomness
 			TranslateMessage(&mesg);
Index: network.c
===================================================================
--- network.c	(revision 3486)
+++ network.c	(working copy)
@@ -225,7 +225,7 @@
 		return;
 	}
 
-	switch(res) {
+	switch (res) {
 		case NETWORK_RECV_STATUS_DESYNC: errorno = NETWORK_ERROR_DESYNC; break;
 		case NETWORK_RECV_STATUS_SAVEGAME: errorno = NETWORK_ERROR_SAVEGAME_FAILED; break;
 		default: errorno = NETWORK_ERROR_GENERAL;
@@ -1160,7 +1160,7 @@
 	// Just a safety check, to be removed in the future.
 	// Make sure that no older command appears towards the end of the queue
 	// In that case we missed executing it. This will never happen.
-	for(cp = _local_command_queue; cp; cp = cp->next) {
+	for (cp = _local_command_queue; cp; cp = cp->next) {
 		assert(_frame_counter < cp->frame);
 	}
 
Index: rail.h
===================================================================
--- rail.h	(revision 3486)
+++ rail.h	(working copy)
@@ -580,7 +580,7 @@
 static inline TransportType GetCrossingTransportType(TileIndex tile, Track track)
 {
 	/* XXX: Nicer way to write this? */
-	switch(track)
+	switch (track)
 	{
 		/* When map5 bit 3 is set, the road runs in the y direction (DIAG2) */
 		case TRACK_DIAG1:
Index: misc_gui.c
===================================================================
--- misc_gui.c	(revision 3486)
+++ misc_gui.c	(working copy)
@@ -548,7 +548,7 @@
 
 		if ( (x|y) != 0) {
 			pt = RemapCoords2(x, y);
-			for(w=_windows; w->window_class != WC_MAIN_WINDOW; w++) {}
+			for (w=_windows; w->window_class != WC_MAIN_WINDOW; w++) {}
 			vp = w->viewport;
 
 			// move x pos to opposite corner
@@ -567,7 +567,7 @@
 	} else {
 		if ( (x|y) != 0) {
 			pt = RemapCoords2(x, y);
-			for(w=_windows; w->window_class != WC_MAIN_WINDOW; w++) {}
+			for (w=_windows; w->window_class != WC_MAIN_WINDOW; w++) {}
 			vp = w->viewport;
 			pt.x = clamp(((pt.x - vp->virtual_left) >> vp->zoom) + vp->left - (334/2), 0, _screen.width - 334);
 			pt.y = clamp(((pt.y - vp->virtual_top) >> vp->zoom) + vp->top - (137/2), 22, _screen.height - 137);
@@ -967,7 +967,7 @@
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: DeleteWindow(w); break;
 		case 4:
 press_ok:;
@@ -1376,7 +1376,7 @@
 		break;
 	case WE_DESTROY:
 		// pause is only used in single-player, non-editor mode, non menu mode
-		if(!_networking && (_game_mode != GM_EDITOR) && (_game_mode != GM_MENU))
+		if (!_networking && (_game_mode != GM_EDITOR) && (_game_mode != GM_MENU))
 			DoCommandP(0, 0, 0, NULL, CMD_PAUSE);
 		FiosFreeSavegameList();
 		CLRBIT(_no_scroll, SCROLL_SAVE);
@@ -1534,7 +1534,7 @@
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: /* Sort scenario names by name */
 			_savegame_sort_order = (_savegame_sort_order == SORT_BY_NAME) ?
 				SORT_BY_NAME | SORT_DESCENDING : SORT_BY_NAME;
Index: terraform_gui.c
===================================================================
--- terraform_gui.c	(revision 3486)
+++ terraform_gui.c	(working copy)
@@ -205,7 +205,7 @@
 
 static void TerraformToolbWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowWidgets(w);
 		break;
Index: players.c
===================================================================
--- players.c	(revision 3486)
+++ players.c	(working copy)
@@ -350,7 +350,7 @@
 	}
 }
 
-#define COLOR_SWAP(i,j) do { byte t=colors[i];colors[i]=colors[j];colors[j]=t; } while(0)
+#define COLOR_SWAP(i,j) do { byte t=colors[i];colors[i]=colors[j];colors[j]=t; } while (0)
 
 static const byte _color_sort[16] = {2, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 2, 3, 1, 1, 1};
 static const byte _color_similar_1[16] = {8, 6, 255, 12,  255, 0, 1, 1, 0, 13,  11,  10, 3,   9,  15, 14};
@@ -364,7 +364,7 @@
 	Player *p;
 
 	// Initialize array
-	for(i=0; i!=16; i++)
+	for (i=0; i!=16; i++)
 		colors[i] = i;
 
 	// And randomize it
@@ -377,7 +377,7 @@
 	// Bubble sort it according to the values in table 1
 	i = 16;
 	do {
-		for(j=0; j!=15; j++) {
+		for (j=0; j!=15; j++) {
 			if (_color_sort[colors[j]] < _color_sort[colors[j+1]]) {
 				COLOR_SWAP(j,j+1);
 			}
@@ -387,12 +387,12 @@
 	// Move the colors that look similar to each player's color to the side
 	FOR_ALL_PLAYERS(p) if (p->is_active) {
 		pcolor = p->player_color;
-		for(i=0; i!=16; i++) if (colors[i] == pcolor) {
+		for (i=0; i!=16; i++) if (colors[i] == pcolor) {
 			colors[i] = 0xFF;
 
 			t2 = _color_similar_1[pcolor];
 			if (t2 == 0xFF) break;
-			for(i=0; i!=15; i++) {
+			for (i=0; i!=15; i++) {
 				if (colors[i] == t2) {
 					do COLOR_SWAP(i,i+1); while (++i != 15);
 					break;
@@ -401,7 +401,7 @@
 
 			t2 = _color_similar_2[pcolor];
 			if (t2 == 0xFF) break;
-			for(i=0; i!=15; i++) {
+			for (i=0; i!=15; i++) {
 				if (colors[i] == t2) {
 					do COLOR_SWAP(i,i+1); while (++i != 15);
 					break;
@@ -413,7 +413,7 @@
 
 	// Return the first available color
 	i = 0;
-	for(;;) {
+	for (;;) {
 		if (colors[i] != 0xFF)
 			return colors[i];
 		i++;
@@ -425,7 +425,7 @@
 	Player *pp;
 	char buffer[100], buffer2[40];
 
-	for(;;) {
+	for (;;) {
 restart:;
 
 		p->president_name_2 = Random();
@@ -539,7 +539,7 @@
 {
 	int i;
 	memset(_players, 0, sizeof(_players));
-	for(i = 0; i != MAX_PLAYERS; i++)
+	for (i = 0; i != MAX_PLAYERS; i++)
 		_players[i].index=i;
 	_cur_player_tick_index = 0;
 }
@@ -717,7 +717,7 @@
 			if (new_engine_type != INVALID_ENGINE) {
 				/* First we make sure that it's a valid type the user requested
 				 * check that it's an engine that is in the engine array */
-				if(!IsEngineIndex(new_engine_type))
+				if (!IsEngineIndex(new_engine_type))
 					return CMD_ERROR;
 
 				// check that the new vehicle type is the same as the original one
@@ -1254,7 +1254,7 @@
 	// Write AI?
 	if (!IS_HUMAN_PLAYER(p->index)) {
 		SlObject(&p->ai, _player_ai_desc);
-		for(i=0; i!=p->ai.num_build_rec; i++)
+		for (i=0; i!=p->ai.num_build_rec; i++)
 			SlObject(&p->ai.src + i, _player_ai_build_rec_desc);
 	}
 
@@ -1264,7 +1264,7 @@
 	// Write old economy entries.
 	{
 		PlayerEconomyEntry *pe;
-		for(i=p->num_valid_stat_ent,pe=p->old_economy; i!=0; i--,pe++)
+		for (i=p->num_valid_stat_ent,pe=p->old_economy; i!=0; i--,pe++)
 			SlObject(pe, _player_economy_desc);
 	}
 }
Index: depot.h
===================================================================
--- depot.h	(revision 3486)
+++ depot.h	(working copy)
@@ -75,7 +75,7 @@
  */
 static inline bool IsTileDepotType(TileIndex tile, TransportType type)
 {
-	switch(type)
+	switch (type)
 	{
 		case TRANSPORT_RAIL:
 			return IsTileType(tile, MP_RAILWAY) && (_m[tile].m5 & 0xFC) == 0xC0;
Index: macros.h
===================================================================
--- macros.h	(revision 3486)
+++ macros.h	(working copy)
@@ -121,7 +121,7 @@
 
 
 #define for_each_bit(_i,_b)										\
-	for(_i=0; _b!=0; _i++,_b>>=1)								\
+	for (_i=0; _b!=0; _i++,_b>>=1)								\
 		if (_b&1)
 
 #define abs myabs
Index: tunnelbridge_cmd.c
===================================================================
--- tunnelbridge_cmd.c	(revision 3486)
+++ tunnelbridge_cmd.c	(working copy)
@@ -690,7 +690,7 @@
 	TileIndex start;
 
 	// find start of bridge
-	for(;;) {
+	for (;;) {
 		if (IsTileType(tile, MP_TUNNELBRIDGE) && (_m[tile].m5 & 0xE0) == 0x80)
 			break;
 		tile += direction ? TileDiffXY(0, -1) : TileDiffXY(-1, 0);
@@ -699,7 +699,7 @@
 	start = tile;
 
 	// find end of bridge
-	for(;;) {
+	for (;;) {
 		if (IsTileType(tile, MP_TUNNELBRIDGE) && (_m[tile].m5 & 0xE0) == 0xA0)
 			break;
 		tile += direction ? TileDiffXY(0, 1) : TileDiffXY(1, 0);
@@ -1000,7 +1000,7 @@
 			if (!(ti->tileh & p[3])) back_height += 8;
 		}
 
-		for(; z>=front_height || z>=back_height; z=z-8) {
+		for (; z>=front_height || z>=back_height; z=z-8) {
 			if (z>=front_height) AddSortableSpriteToDraw(image, x,y, p[4], p[5], 0x28, z); // front facing pillar
 			if (z>=back_height && z<i-8) AddSortableSpriteToDraw(image, x - p[6], y - p[7], p[4], p[5], 0x28, z); // back facing pillar
 		}
Index: sound/cocoa_s.c
===================================================================
--- sound/cocoa_s.c	(revision 3486)
+++ sound/cocoa_s.c	(working copy)
@@ -87,24 +87,24 @@
 		return "cocoa_s: Failed to start CoreAudio: FindNextComponent returned NULL";
 
 	/* Open & initialize the default output audio unit */
-	if(OpenAComponent(comp, &_outputAudioUnit) != noErr)
+	if (OpenAComponent(comp, &_outputAudioUnit) != noErr)
 		return "cocoa_s: Failed to start CoreAudio: OpenAComponent";
 
-	if(AudioUnitInitialize(_outputAudioUnit) != noErr)
+	if (AudioUnitInitialize(_outputAudioUnit) != noErr)
 		return "cocoa_s: Failed to start CoreAudio: AudioUnitInitialize";
 
 	/* Set the input format of the audio unit. */
-	if(AudioUnitSetProperty(_outputAudioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &requestedDesc, sizeof (requestedDesc)) != noErr)
+	if (AudioUnitSetProperty(_outputAudioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &requestedDesc, sizeof (requestedDesc)) != noErr)
 		return "cocoa_s: Failed to start CoreAudio:  AudioUnitSetProperty (kAudioUnitProperty_StreamFormat)";
 
 	/* Set the audio callback */
 	callback.inputProc = audioCallback;
 	callback.inputProcRefCon = NULL;
-	if(AudioUnitSetProperty(_outputAudioUnit,  kAudioUnitProperty_SetInputCallback,  kAudioUnitScope_Input,  0, &callback,  sizeof(callback)) != noErr)
+	if (AudioUnitSetProperty(_outputAudioUnit,  kAudioUnitProperty_SetInputCallback,  kAudioUnitScope_Input,  0, &callback,  sizeof(callback)) != noErr)
 		return "cocoa_s: Failed to start CoreAudio: AudioUnitSetProperty (kAudioUnitProperty_SetInputCallback)";
 
 	/* Finally, start processing of the audio unit */
-	if(AudioOutputUnitStart (_outputAudioUnit) != noErr)
+	if (AudioOutputUnitStart (_outputAudioUnit) != noErr)
 		return "cocoa_s: Failed to start CoreAudio: AudioOutputUnitStart";
 
 	/* We're running! */
@@ -119,7 +119,7 @@
 	DEBUG(driver, 1)("cocoa_s: CocoaSoundStop");
 
 	/* stop processing the audio unit */
-	if(AudioOutputUnitStop(_outputAudioUnit) != noErr) {
+	if (AudioOutputUnitStop(_outputAudioUnit) != noErr) {
 		DEBUG(driver, 1)("cocoa_s: Core_CloseAudio: AudioOutputUnitStop failed");
 		return;
 	}
@@ -127,7 +127,7 @@
 	/* Remove the input callback */
 	callback.inputProc = 0;
 	callback.inputProcRefCon = 0;
-	if(AudioUnitSetProperty(_outputAudioUnit, kAudioUnitProperty_SetInputCallback, kAudioUnitScope_Input, 0, &callback, sizeof(callback)) != noErr) {
+	if (AudioUnitSetProperty(_outputAudioUnit, kAudioUnitProperty_SetInputCallback, kAudioUnitScope_Input, 0, &callback, sizeof(callback)) != noErr) {
 		DEBUG(driver, 1)("cocoa_s: Core_CloseAudio: AudioUnitSetProperty (kAudioUnitProperty_SetInputCallback) failed");
 		return;
 	}
Index: clear_cmd.c
===================================================================
--- clear_cmd.c	(revision 3486)
+++ clear_cmd.c	(working copy)
@@ -68,7 +68,7 @@
 
 	if (count >= 625) return;
 
-	for(t = ts->tile_table; count != 0; count--,t++) {
+	for (t = ts->tile_table; count != 0; count--,t++) {
 		if (*t == tile) return;
 	}
 
@@ -190,7 +190,7 @@
 			{ 0, -2}
 		};
 
-		for(ttm = _terraform_tilepos; ttm != endof(_terraform_tilepos); ttm++) {
+		for (ttm = _terraform_tilepos; ttm != endof(_terraform_tilepos); ttm++) {
 			tile += ToTileIndexDiff(*ttm);
 
 			r = TerraformGetHeightOfTile(ts, tile);
@@ -778,7 +778,7 @@
 		tile = RandomTileSeed(r);
 		if (IsTileType(tile, MP_CLEAR)) {
 			uint j = GB(r, 16, 4) + 5;
-			for(;;) {
+			for (;;) {
 				TileIndex tile_new;
 
 				SB(_m[tile].m5, 2, 2, 2);
Index: roadveh_cmd.c
===================================================================
--- roadveh_cmd.c	(revision 3486)
+++ roadveh_cmd.c	(working copy)
@@ -323,7 +323,7 @@
 		rfdd.best_length = (uint)-1;
 
 		/* search in all directions */
-		for(i=0; i!=4; i++)
+		for (i=0; i!=4; i++)
 			FollowTrack(tile, 0x2000 | TRANSPORT_ROAD, i, (TPFEnumProc*)EnumRoadSignalFindDepot, NULL, &rfdd);
 
 		if (rfdd.best_length == (uint)-1)
@@ -959,7 +959,7 @@
 
 	num = RandomRange(num);
 
-	for(i=0; !((bits & 1) && ((int)--num) < 0); bits>>=1,i++);
+	for (i=0; !((bits & 1) && ((int)--num) < 0); bits>>=1,i++);
 	return i;
 }
 
@@ -1626,7 +1626,7 @@
 
 		//first we need to find out how far our stations are away.
 			DEBUG(ms, 2) ("Multistop: Attempting to obtain a slot for vehicle %d at station %d (0x%x)", v->unitnumber, st->index, st->xy);
-			for(; rs != NULL; rs = rs->next) {
+			for (; rs != NULL; rs = rs->next) {
 				// Only consider those with at least a free slot.
 				if (!(rs->slot[0] == INVALID_SLOT || rs->slot[1] == INVALID_SLOT))
 					continue;
@@ -1637,7 +1637,7 @@
 
 				// Check if the station is located BEHIND the vehicle..
 				// In that case, add penalty.
-				switch(v->direction) {
+				switch (v->direction) {
 				case 1: // going north east,x position decreasing
 					if (v->x_pos <= (int32)TileX(rs->xy) * 16 + 15)
 						dist += 6;
Index: openttd.c
===================================================================
--- openttd.c	(revision 3486)
+++ openttd.c	(working copy)
@@ -335,7 +335,7 @@
 
 	MyGetOptInit(&mgo, argc-1, argv+1, optformat);
 	while ((i = MyGetOpt(&mgo)) != -1) {
-		switch(i) {
+		switch (i) {
 		case 'm': ttd_strlcpy(musicdriver, mgo.opt, sizeof(musicdriver)); break;
 		case 's': ttd_strlcpy(sounddriver, mgo.opt, sizeof(sounddriver)); break;
 		case 'v': ttd_strlcpy(videodriver, mgo.opt, sizeof(videodriver)); break;
@@ -956,7 +956,7 @@
 	// make a screenshot?
 	if ((m=_make_screenshot) != 0) {
 		_make_screenshot = 0;
-		switch(m) {
+		switch (m) {
 		case 1: // make small screenshot
 			UndrawMouseCursor();
 			ShowScreenshotResult(MakeScreenshot());
Index: gfx.c
===================================================================
--- gfx.c	(revision 3486)
+++ gfx.c	(working copy)
@@ -402,11 +402,11 @@
 	char *last_space;
 	byte c;
 
-	for(;;) {
+	for (;;) {
 		w = 0;
 		last_space = NULL;
 
-		for(;;) {
+		for (;;) {
 			c = *str++;
 			if (c == ASCII_LETTERSTART) last_space = str;
 
@@ -457,12 +457,12 @@
 
 	src = buffer;
 
-	for(;;) {
+	for (;;) {
 		w = GetStringWidth(src);
 		DoDrawString(src, x - (w>>1), y, 0xFE);
 		_stringwidth_base = _stringwidth_out;
 
-		for(;;) {
+		for (;;) {
 			c = *src++;
 			if (c == 0) {
 				y += mt;
@@ -501,11 +501,11 @@
 
 	src = buffer;
 
-	for(;;) {
+	for (;;) {
 		DoDrawString(src, x, y, 0xFE);
 		_stringwidth_base = _stringwidth_out;
 
-		for(;;) {
+		for (;;) {
 			c = *src++;
 			if (c == 0) {
 				y += mt;
@@ -608,13 +608,13 @@
 check_bounds:
 	if (y + 19 <= dpi->top || dpi->top + dpi->height <= y) {
 skip_char:;
-		for(;;) {
+		for (;;) {
 			c = *string++;
 			if (c < ASCII_LETTERSTART) goto skip_cont;
 		}
 	}
 
-	for(;;) {
+	for (;;) {
 		c = *string++;
 skip_cont:;
 		if (c == 0) {
@@ -1106,7 +1106,7 @@
 
 	if (bp->mode & 1) {
 		src_o += READ_LE_UINT16(src_o + bp->start_y * 2);
-		for(;;) {
+		for (;;) {
 			do {
 				done = src_o[0];
 				num = done & 0x7F;
@@ -1175,7 +1175,7 @@
 		}
 	} else if (bp->mode & 2) {
 		src_o += READ_LE_UINT16(src_o + bp->start_y * 2);
-		for(;;) {
+		for (;;) {
 			do {
 				done = src_o[0];
 				num = done & 0x7F;
@@ -1240,7 +1240,7 @@
 		}
 	} else {
 		src_o += READ_LE_UINT16(src_o + bp->start_y * 2);
-		for(;;) {
+		for (;;) {
 			do {
 				done = src_o[0];
 				num = done & 0x7F;
Index: strings.c
===================================================================
--- strings.c	(revision 3486)
+++ strings.c	(working copy)
@@ -402,7 +402,7 @@
 	// The absolute value determines plurality
 	if (n < 0) n = -n;
 
-	switch(_langpack->plural_form) {
+	switch (_langpack->plural_form) {
 	// Two forms, singular used for one only
 	// Used in:
 	//   Danish, Dutch, English, German, Norwegian, Swedish, Estonian, Finnish,
@@ -466,7 +466,7 @@
 	//<NUM> {Length of each string} {each string}
 	uint n = (byte)*b++;
 	uint pos,i, mylen=0,mypos=0;
-	for(i=pos=0; i!=n; i++) {
+	for (i=pos=0; i!=n; i++) {
 		uint len = (byte)*b++;
 		if (i == form) {
 			mypos = pos;
Index: saveload.c
===================================================================
--- saveload.c	(revision 3486)
+++ saveload.c	(working copy)
@@ -778,7 +778,7 @@
 	const ChunkHandler *ch;
 	const ChunkHandler *const *chsc;
 	for (chsc = _sl.chs; (ch=*chsc++) != NULL;) {
-		while(true) {
+		while (true) {
 			if (ch->id == id)
 				return ch;
 			if (ch->flags & CH_LAST)
Index: aircraft_gui.c
===================================================================
--- aircraft_gui.c	(revision 3486)
+++ aircraft_gui.c	(working copy)
@@ -141,7 +141,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* listbox */
 			uint i = (e->click.pt.y - 14) / 24;
 			if (i < w->vscroll.cap) {
@@ -255,7 +255,7 @@
 	}	break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* listbox */
 			int y = e->click.pt.y - 25;
 			if (y >= 0) {
@@ -496,7 +496,7 @@
 
 static void AircraftViewWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		const Vehicle* v = GetVehicle(w->window_number);
 		uint32 disabled = 1 << 8;
@@ -774,13 +774,13 @@
 
 static void AircraftDepotWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawAircraftDepotWindow(w);
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 			case 5: /* click aircraft */
 				AircraftDepotClickAircraft(w, e->click.pt.x, e->click.pt.y);
 				break;
@@ -834,7 +834,7 @@
 		break;
 
 	case WE_DRAGDROP:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5: {
 			Vehicle *v;
 			VehicleID sel = WP(w,traindepot_d).sel;
@@ -985,7 +985,7 @@
 	PlayerID owner = GB(w->window_number, 0, 8);
 	vehiclelist_d *vl = &WP(w, vehiclelist_d);
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int x = 2;
 		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
@@ -1056,7 +1056,7 @@
 		}	break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: /* Flip sorting method ascending/descending */
 			vl->flags ^= VL_DESC;
 			vl->flags |= VL_RESORT;
@@ -1103,7 +1103,7 @@
 				}
 
 				tile = TILE_MASK(tile + 1);
-			} while(tile != _last_built_aircraft_depot_tile);
+			} while (tile != _last_built_aircraft_depot_tile);
 
 			ShowBuildAircraftWindow(0);
 		} break;
Index: train_cmd.c
===================================================================
--- train_cmd.c	(revision 3486)
+++ train_cmd.c	(working copy)
@@ -894,11 +894,11 @@
 
 	assert(IsFrontEngine(v));
 
-	for(; v != NULL; v = GetNextVehicle(v)) {
+	for (; v != NULL; v = GetNextVehicle(v)) {
 		if (!IsMultiheaded(v) || !IsTrainEngine(v)) continue;
 
 		/* make sure that there are no free cars before next engine */
-		for(u = v; u->next != NULL && !IsTrainEngine(u->next); u = u->next);
+		for (u = v; u->next != NULL && !IsTrainEngine(u->next); u = u->next);
 
 		if (u == v->u.rail.other_multiheaded_part) continue;
 		AddWagonToConsist(v->u.rail.other_multiheaded_part, u);
@@ -974,7 +974,7 @@
 		/* we need to make sure that we didn't place it between a pair of multiheaded engines */
 		Vehicle *u, *engine = NULL;
 
-		for(u = dst_head; u != NULL; u = u->next) {
+		for (u = dst_head; u != NULL; u = u->next) {
 			if (IsTrainEngine(u) && IsMultiheaded(u) && u->u.rail.other_multiheaded_part != NULL) {
 				engine = u;
 			}
@@ -2215,7 +2215,7 @@
 				reverse_best = false;
 		}
 	} else {
-		while(true) {
+		while (true) {
 			fd.best_bird_dist = (uint)-1;
 			fd.best_track_dist = (uint)-1;
 
@@ -3537,7 +3537,7 @@
 					{
 						Vehicle *w;
 
-						for(w = u->next; w != NULL && (w->engine_type != u->engine_type || w->u.rail.other_multiheaded_part != NULL); w = GetNextVehicle(w));
+						for (w = u->next; w != NULL && (w->engine_type != u->engine_type || w->u.rail.other_multiheaded_part != NULL); w = GetNextVehicle(w));
 						if (w != NULL) {
 							/* we found a car to partner with this engine. Now we will make sure it face the right way */
 							if (IsTrainEngine(w)) {
Index: player.h
===================================================================
--- player.h	(revision 3486)
+++ player.h	(working copy)
@@ -201,7 +201,7 @@
 int64 CalculateCompanyValue(const Player* p);
 void InvalidatePlayerWindows(const Player* p);
 void UpdatePlayerMoney32(Player *p);
-#define FOR_ALL_PLAYERS(p) for(p=_players; p != endof(_players); p++)
+#define FOR_ALL_PLAYERS(p) for (p=_players; p != endof(_players); p++)
 
 VARDEF PlayerID _local_player;
 VARDEF PlayerID _current_player;
Index: industry_cmd.c
===================================================================
--- industry_cmd.c	(revision 3486)
+++ industry_cmd.c	(working copy)
@@ -505,12 +505,12 @@
 {
 	byte m,n;
 
-	switch(_m[tile].m5) {
+	switch (_m[tile].m5) {
 	case 174:
 		if ((_tick_counter & 1) == 0) {
 			m = _m[tile].m3 + 1;
 
-			switch(m & 7) {
+			switch (m & 7) {
 			case 2:	SndPlayTileFx(SND_2D_RIP_2, tile); break;
 			case 6: SndPlayTileFx(SND_29_RIP, tile); break;
 			}
@@ -685,7 +685,7 @@
 	if (!(_m[tile].m1 & 0x80))
 		return;
 
-	switch(_m[tile].m5) {
+	switch (_m[tile].m5) {
 	case 8:
 		MakeIndustryTileBiggerCase8(tile);
 		break;
Index: road_cmd.c
===================================================================
--- road_cmd.c	(revision 3486)
+++ road_cmd.c	(working copy)
@@ -223,7 +223,7 @@
 			cost = 0;
 			do {
 				if (t2&1) cost += _price.remove_road;
-			} while(t2>>=1);
+			} while (t2>>=1);
 
 			if (flags & DC_EXEC) {
 				ChangeTownRating(t, -road_remove_cost[(byte)edge_road], RATING_ROAD_MINIMUM);
@@ -386,7 +386,7 @@
 		if (IsSteepTileh(ti.tileh)) // very steep tile
 				return_cmd_error(STR_1000_LAND_SLOPED_IN_WRONG_DIRECTION);
 
-		if(!_valid_tileh_slopes_road[2][ti.tileh]) // prevent certain slopes
+		if (!_valid_tileh_slopes_road[2][ti.tileh]) // prevent certain slopes
 				return_cmd_error(STR_1000_LAND_SLOPED_IN_WRONG_DIRECTION);
 
 		if (ti.map5 == 2) {
@@ -890,7 +890,7 @@
 
 	DrawSprite(dtss++->image, x, y);
 
-	for(; dtss->image != 0; dtss++) {
+	for (; dtss->image != 0; dtss++) {
 		Point pt = RemapCoords(dtss->subcoord_x, dtss->subcoord_y, 0);
 
 		image = dtss->image;
Index: rail_cmd.c
===================================================================
--- rail_cmd.c	(revision 3486)
+++ rail_cmd.c	(working copy)
@@ -413,7 +413,7 @@
 	if (!IsTileType(tile, MP_TUNNELBRIDGE) && !EnsureNoVehicle(tile))
 		return CMD_ERROR;
 
-	switch(GetTileType(tile))
+	switch (GetTileType(tile))
 	{
 		case MP_TUNNELBRIDGE:
 			if (!EnsureNoVehicleZ(tile, TilePixelHeight(tile)))
@@ -579,7 +579,7 @@
 
 	if (flags & DC_EXEC) SndPlayTileFx(SND_20_SPLAT_2, TileVirtXY(x, y));
 
-	for(;;) {
+	for (;;) {
 		ret = DoCommand(x, y, railtype, TrackdirToTrack(trackdir), flags, (mode == 0) ? CMD_BUILD_SINGLE_RAIL : CMD_REMOVE_SINGLE_RAIL);
 
 		if (CmdFailed(ret)) {
@@ -1071,12 +1071,12 @@
 	switch (GetRailTileType(tile)) {
 		/* XXX: Why the fuck do we remove these thow signals first? */
 		case RAIL_TYPE_SIGNALS:
-			if(HasSignalOnTrack(tile, TRACK_DIAG1)) {
+			if (HasSignalOnTrack(tile, TRACK_DIAG1)) {
 				ret = DoCommandByTile(tile, TRACK_DIAG1, 0, flags, CMD_REMOVE_SIGNALS);
 				if (CmdFailed(ret)) return CMD_ERROR;
 				cost += ret;
 			}
-			if(HasSignalOnTrack(tile, TRACK_LOWER)) {
+			if (HasSignalOnTrack(tile, TRACK_LOWER)) {
 				ret = DoCommandByTile(tile, TRACK_LOWER, 0, flags, CMD_REMOVE_SIGNALS);
 				if (CmdFailed(ret)) return CMD_ERROR;
 				cost += ret;
@@ -1772,7 +1772,7 @@
 	ssd.cur_stack = 0;
 	direction >>= 1;
 
-	for(;;) {
+	for (;;) {
 		// go through one segment and update all signals pointing into that segment.
 		ssd.cur = ssd.presignal_exits = ssd.presignal_exits_free = 0;
 		ssd.has_presignal = false;
Index: smallmap_gui.c
===================================================================
--- smallmap_gui.c	(revision 3486)
+++ smallmap_gui.c	(working copy)
@@ -644,7 +644,7 @@
 	x = - dx - 4;
 	y = 0;
 
-	for(;;) {
+	for (;;) {
 		uint32 mask;
 		int reps;
 		int t;
Index: vehicle.c
===================================================================
--- vehicle.c	(revision 3486)
+++ vehicle.c	(working copy)
@@ -341,7 +341,7 @@
 	Vehicle *v;
 	VehicleID counter = 0;
 
-	for(i = 0; i != num; i++) {
+	for (i = 0; i != num; i++) {
 		v = AllocateSingleVehicle(&counter);
 		if (v == NULL) {
 			return false;
@@ -716,9 +716,9 @@
 	y  = ((dpi->top - 70) & 0xFC0);
 	y2 = ((dpi->top + dpi->height) & 0xFC0);
 
-	for(;;) {
+	for (;;) {
 		xb = x;
-		for(;;) {
+		for (;;) {
 			veh = _vehicle_position_hash[(x + y) & 0xFFFF];
 			while (veh != INVALID_VEHICLE) {
 				v = GetVehicle(veh);
@@ -1946,7 +1946,7 @@
 {
 	if (v->vehstatus & VS_CRASHED) return 0xFF;
 
-	switch(v->type)
+	switch (v->type)
 	{
 		case VEH_Train:
 			if (v->u.rail.track == 0x80) /* We'll assume the train is facing outwards */
Index: viewport.c
===================================================================
--- viewport.c	(revision 3486)
+++ viewport.c	(working copy)
@@ -571,7 +571,7 @@
 void DebugClearMarkedTiles()
 {
 	uint size = MapSize(), i;
-	for(i=0; i!=size; i++) {
+	for (i=0; i!=size; i++) {
 		if (_m[i].extra & 0x80) {
 			_m[i].extra &= ~0x80;
 			MarkTileDirtyByTile(i);
@@ -598,7 +598,7 @@
 	px -= _thd.selstart.x;
 	py -= _thd.selstart.y;
 
-	switch(_thd.drawstyle) {
+	switch (_thd.drawstyle) {
 	case HT_LINE | HT_DIR_X:  return py == 0; // x direction
 	case HT_LINE | HT_DIR_Y:  return px == 0; // y direction
 	case HT_LINE | HT_DIR_HU: return px == -py || px == -py - 16; // horizontal upper
@@ -1954,7 +1954,7 @@
 	int fxmy = _tile_fract_coords.x - _tile_fract_coords.y;
 	int sxmy = (_thd.selend.x & 0xF) - (_thd.selend.y & 0xF);
 
-	switch(mode) {
+	switch (mode) {
 	case 0: // end piece is lower right
 		if (fxpy >= 20 && sxpy <= 12) { /*SwapSelection(); DoRailroadTrack(0); */return 3; }
 		if (fxmy < -3 && sxmy > 3) {/* DoRailroadTrack(0); */return 5; }
Index: landscape.c
===================================================================
--- landscape.c	(revision 3486)
+++ landscape.c	(working copy)
@@ -84,7 +84,7 @@
 {
 	int z = 0;
 
-	switch(corners) {
+	switch (corners) {
 	case 1:
 		if (x - y >= 0)
 			z = (x - y) >> 1;
Index: misc.c
===================================================================
--- misc.c	(revision 3486)
+++ misc.c	(working copy)
@@ -223,7 +223,7 @@
 
 	// No need to run the tile loop in the scenario editor.
 	if (mode != GW_EMPTY) {
-		for(i=0x500; i!=0; i--)
+		for (i=0x500; i!=0; i--)
 			RunTileLoop();
 	}
 
@@ -419,7 +419,7 @@
 	memcpy(_cargoc.ai_roadveh_start, lpd->road_veh_by_cargo_start,sizeof(lpd->road_veh_by_cargo_start));
 	memcpy(_cargoc.ai_roadveh_count, lpd->road_veh_by_cargo_count,sizeof(lpd->road_veh_by_cargo_count));
 
-	for(i=0; i!=NUM_CARGO; i++) {
+	for (i=0; i!=NUM_CARGO; i++) {
 		_cargoc.sprites[i] = lpd->sprites[i];
 
 		str = lpd->names[i];
@@ -971,7 +971,7 @@
 	Cheat* cht_last = &cht[count];
 
 	SlSetLength(count*2);
-	for(; cht != cht_last; cht++) {
+	for (; cht != cht_last; cht++) {
 		SlWriteByte(cht->been_used);
 		SlWriteByte(cht->value);
 	}
@@ -982,7 +982,7 @@
 	Cheat* cht = (Cheat*) &_cheats;
 
 	uint count = SlGetFieldLength()/2;
-	for(; count; count--, cht++)
+	for (; count; count--, cht++)
 	{
 		cht->been_used = (byte)SlReadByte();
 		cht->value = (byte)SlReadByte();
Index: player_gui.c
===================================================================
--- player_gui.c	(revision 3486)
+++ player_gui.c	(working copy)
@@ -35,7 +35,7 @@
 	if (!(mode & 1)) { // normal sized economics window (mode&1) is minimized status
 		/* draw categories */
 		DrawStringCenterUnderline(61, 15, STR_700F_EXPENDITURE_INCOME, 0);
-		for(i=0; i!=13; i++)
+		for (i=0; i!=13; i++)
 			DrawString(2, 27 + i*10, STR_7011_CONSTRUCTION + i, 0);
 		DrawStringRightAligned(111, 27 + 10*13 + 2, STR_7020_TOTAL, 0);
 
@@ -49,7 +49,7 @@
 				SetDParam(0, year + 1920);
 				DrawStringCenterUnderline(x-17, 15, STR_7010, 0);
 				sum = 0;
-				for(i=0; i!=13; i++) {
+				for (i=0; i!=13; i++) {
 					/* draw one row in the price column */
 					cost = (*tbl)[i];
 					if (cost != 0) {
@@ -148,7 +148,7 @@
 
 static void PlayerFinancesWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		PlayerID player = w->window_number;
 		const Player* p = GetPlayer(player);
@@ -165,7 +165,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: {/* toggle size */
 			byte mode = (byte)WP(w,def_d).data_1;
 			bool stickied = !!(w->flags4 & WF_STICKY);
@@ -246,7 +246,7 @@
 
 static void SelectPlayerColorWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		const Player* p;
 		uint used_colors = 0;
@@ -268,7 +268,7 @@
 		y = 17;
 		pos = w->vscroll.pos;
 
-		for(i=0; i!=16; i++) {
+		for (i=0; i!=16; i++) {
 			if (!(used_colors & 1) && --pos < 0 && pos >= -8) {
 				DrawString(x + 30, y, STR_00D1_DARK_BLUE + i, 2);
 				DrawSprite((i << 16) + 0x3078C1A, x + 14, y + 4);
@@ -289,7 +289,7 @@
 			item += w->vscroll.pos;
 			used_colors = WP(w,def_d).data_1;
 
-			for(i=0; i!=16; i++) {
+			for (i=0; i!=16; i++) {
 				if (!(used_colors & 1) && --item < 0) {
 					DoCommandP(0, 0, i, NULL, CMD_SET_PLAYER_COLOR);
 					DeleteWindow(w);
@@ -320,7 +320,7 @@
 
 static void SelectPlayerFaceWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		Player *p;
 		w->click_state = (w->click_state & ~(1<<5|1<<6)) | ((1<<5) << WP(w,facesel_d).gender);
@@ -330,7 +330,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: DeleteWindow(w); break;
 		case 4: /* ok click */
 			DoCommandP(0, 0, WP(w,facesel_d).face, NULL, CMD_SET_PLAYER_FACE);
@@ -695,7 +695,7 @@
 
 static void BuyCompanyWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		Player *p = GetPlayer(w->window_number);
 		SetDParam(0, p->name_1);
@@ -712,7 +712,7 @@
 	}
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3:
 			DeleteWindow(w);
 			break;
Index: win32.c
===================================================================
--- win32.c	(revision 3486)
+++ win32.c	(working copy)
@@ -141,7 +141,7 @@
 		file = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL,
 			OPEN_EXISTING, 0, 0);
 		if (file != INVALID_HANDLE_VALUE) {
-			while(true) {
+			while (true) {
 				if (ReadFile(file, buffer, sizeof(buffer), &numread, NULL) == 0 ||
 						numread == 0)
 					break;
@@ -359,7 +359,7 @@
 
 static INT_PTR CALLBACK CrashDialogFunc(HWND wnd,UINT msg,WPARAM wParam,LPARAM lParam)
 {
-	switch(msg) {
+	switch (msg) {
 	case WM_INITDIALOG:
 		SetDlgItemText(wnd, 10, _crash_desc);
 		SetDlgItemText(wnd, 11, _crash_msg);
@@ -367,7 +367,7 @@
 		SetWndSize(wnd, -1);
 		return TRUE;
 	case WM_COMMAND:
-		switch(wParam) {
+		switch (wParam) {
 		case 12: // Close
 			ExitProcess(0);
 		case 13: { // Emergency save
Index: economy.c
===================================================================
--- economy.c	(revision 3486)
+++ economy.c	(working copy)
@@ -505,7 +505,7 @@
 
 	DrawStringMultiCenter(49, 148, STR_7058_PRESIDENT, 94);
 
-	switch(WP(w,news_d).ni->string_id >> 4) {
+	switch (WP(w,news_d).ni->string_id >> 4) {
 	case 1:
 		DrawStringCentered(w->width>>1, 1, STR_7056_TRANSPORT_COMPANY_IN_TROUBLE, 0);
 
@@ -806,7 +806,7 @@
 
 	assert(sizeof(_price) == NUM_PRICES * sizeof(int32));
 
-	for(i=0; i!=NUM_PRICES; i++) {
+	for (i=0; i!=NUM_PRICES; i++) {
 		int32 price = _price_base[i];
 		if (_price_category[i] != 0) {
 			uint mod = _price_category[i] == 1 ? _opt.diff.vehicle_costs : _opt.diff.construction_cost;
@@ -883,7 +883,7 @@
 {
 	Subsidy *s;
 
-	for(s=_subsidies; s != endof(_subsidies); s++) {
+	for (s=_subsidies; s != endof(_subsidies); s++) {
 		if (s->cargo_type != CT_INVALID && s->age < 12 &&
 				s->cargo_type != CT_PASSENGERS && s->cargo_type != CT_MAIL &&
 				(index == s->from || (s->cargo_type!=CT_GOODS && s->cargo_type!=CT_FOOD && index==s->to))) {
@@ -897,7 +897,7 @@
 	Subsidy *s;
 	bool dirty = false;
 
-	for(s=_subsidies; s != endof(_subsidies); s++) {
+	for (s=_subsidies; s != endof(_subsidies); s++) {
 		if (s->cargo_type != CT_INVALID && s->age >= 12 &&
 				(s->from == index || s->to == index)) {
 			s->cargo_type = CT_INVALID;
@@ -1014,7 +1014,7 @@
 	FoundRoute fr;
 	bool modified = false;
 
-	for(s=_subsidies; s != endof(_subsidies); s++) {
+	for (s=_subsidies; s != endof(_subsidies); s++) {
 		if (s->cargo_type == CT_INVALID)
 			continue;
 
@@ -1090,7 +1090,7 @@
 	int i;
 	Subsidy *s;
 
-	for(i=0; i!=lengthof(_subsidies); i++) {
+	for (i=0; i!=lengthof(_subsidies); i++) {
 		s = &_subsidies[i];
 		if (s->cargo_type != CT_INVALID) {
 			SlSetArrayIndex(i);
@@ -1169,7 +1169,7 @@
 	Player *p;
 
 	// check if there is an already existing subsidy that applies to us
-	for(s=_subsidies; s != endof(_subsidies); s++) {
+	for (s=_subsidies; s != endof(_subsidies); s++) {
 		if (s->cargo_type == cargo_type &&
 				s->age >= 12 &&
 				s->from == from->index &&
@@ -1178,7 +1178,7 @@
 	}
 
 	/* check if there's a new subsidy that applies.. */
-	for(s=_subsidies; s != endof(_subsidies); s++) {
+	for (s=_subsidies; s != endof(_subsidies); s++) {
 		if (s->cargo_type == cargo_type && s->age < 12) {
 
 			/* Check distance from source */
@@ -1537,7 +1537,7 @@
 	}
 
 	value = CalculateCompanyValue(p) >> 2;
-	for(i=0; i!=4; i++) {
+	for (i=0; i!=4; i++) {
 		if (p->share_owners[i] != OWNER_SPECTATOR) {
 			owner = GetPlayer(p->share_owners[i]);
 			owner->money64 += value;
Index: town_cmd.c
===================================================================
--- town_cmd.c	(revision 3486)
+++ town_cmd.c	(working copy)
@@ -593,7 +593,7 @@
 		if (CHANCE16(1, 4)) {
 			do {
 				a = GB(Random(), 0, 2);
-			} while(a == b);
+			} while (a == b);
 		}
 
 		if (!IsRoadAllowedHere(TILE_ADD(tile, ToTileIndexDiff(_roadblock_tileadd[a])), a)) {
@@ -702,7 +702,7 @@
 				// obviously, if building any bridge would fail, there is no need to try other bridge-types
 				return;
 			}
-		} while(--j != 0);
+		} while (--j != 0);
 	}
 }
 #undef IS_WATER_TILE
@@ -889,7 +889,7 @@
 
 	assert(townnameparts);
 
-	for(;;) {
+	for (;;) {
 restart:
 		r = Random();
 
@@ -956,7 +956,7 @@
 	t->act_food = 0;
 	t->act_water = 0;
 
-	for(i = 0; i != MAX_PLAYERS; i++)
+	for (i = 0; i != MAX_PLAYERS; i++)
 		t->ratings[i] = 500;
 
 	t->have_ratings = 0;
@@ -1174,7 +1174,7 @@
 		{1 - 1, 1 - 0}
 	};
 
-	for(i=0; i!=4; i++) {
+	for (i=0; i!=4; i++) {
 		tile += ToTileIndexDiff(_tile_add[i]);
 
 		if (GetTileSlope(tile, NULL))
@@ -1218,12 +1218,12 @@
 		int num = 0;
 
 		// Generate a list of all possible houses that can be built.
-		for(i=0; i!=lengthof(_housetype_flags); i++) {
+		for (i=0; i!=lengthof(_housetype_flags); i++) {
 			if ((~_housetype_flags[i] & bitmask) == 0)
 				houses[num++] = (byte)i;
 		}
 
-		for(;;) {
+		for (;;) {
 			house = houses[RandomRange(num)];
 
 			if (_cur_year < _housetype_years[house].min || _cur_year > _housetype_years[house].max)
@@ -1923,7 +1923,7 @@
 			t->road_build_months--;
 
 		if (t->exclusive_counter != 0)
-			if(--t->exclusive_counter==0)
+			if (--t->exclusive_counter==0)
 				t->exclusivity = (byte)-1;
 
 		UpdateTownGrowRate(t);
Index: strgen/strgen.c
===================================================================
--- strgen/strgen.c	(revision 3486)
+++ strgen/strgen.c	(working copy)
@@ -116,7 +116,7 @@
 static uint HashStr(const char *s)
 {
 	uint hash = 0;
-	for(; *s; s++)
+	for (; *s; s++)
 		hash = ((hash << 3) | (hash >> 29)) ^ *s;
 	return hash % HASH_SIZE;
 }
@@ -270,7 +270,7 @@
 	if (*s == '"') {
 		r = ++s;
 		// parse until next " or NUL
-		for(;;) {
+		for (;;) {
 			if (*s == 0)
 				break;
 			if (*s == '"') {
@@ -282,7 +282,7 @@
 	} else {
 		// proceed until whitespace or NUL
 		r = s;
-		for(;;) {
+		for (;;) {
 			if (*s == 0)
 				break;
 			if (*s == ' ' || *s == '\t') {
@@ -304,10 +304,10 @@
 	int i,j;
 
 	PutByte(nw);
-	for(i=0; i<nw; i++)
+	for (i=0; i<nw; i++)
 		PutByte(strlen(words[i]));
-	for(i=0; i<nw; i++) {
-		for(j=0; words[i][j]; j++)
+	for (i=0; i<nw; i++) {
+		for (j=0; words[i][j]; j++)
 			PutByte(words[i][j]);
 	}
 }
@@ -341,7 +341,7 @@
 			if (nw > _plural_form_counts[_lang_pluralform]) {
 				nw = _plural_form_counts[_lang_pluralform];
 			} else {
-				for(; nw < _plural_form_counts[_lang_pluralform]; nw++) {
+				for (; nw < _plural_form_counts[_lang_pluralform]; nw++) {
 					words[nw] = words[nw - 1];
 				}
 			}
@@ -364,7 +364,7 @@
 		buf++;
 
 		// This is a {G=DER} command
-		for(nw=0; ;nw++) {
+		for (nw=0; ;nw++) {
 			if (nw >= 8)
 				Fatal("G argument '%s' invalid", buf);
 			if (!strcmp(buf, _genders[nw]))
@@ -379,7 +379,7 @@
 		// If no relative number exists, default to +0
 		if (!ParseRelNum(&buf, &argidx)) {}
 
-		for(nw=0; nw<8; nw++) {
+		for (nw=0; nw<8; nw++) {
 			words[nw] = ParseWord(&buf);
 			if (!words[nw])
 				break;
@@ -507,7 +507,7 @@
 {
 	int i;
 	const CmdStruct *cs = _cmd_structs;
-	for(i=0; i != lengthof(_cmd_structs); i++, cs++) {
+	for (i=0; i != lengthof(_cmd_structs); i++, cs++) {
 		if (!strncmp(cs->cmd, s, len) && cs->cmd[len] == '\0')
 			return cs;
 	}
@@ -517,7 +517,7 @@
 static int ResolveCaseName(const char *str, int len)
 {
 	int i;
-	for(i=0; i<MAX_NUM_CASES; i++)
+	for (i=0; i<MAX_NUM_CASES; i++)
 		if (!memcmp(_cases[i], str, len) && _cases[i][len] == 0)
 			return i + 1;
 	Fatal("Invalid case-name '%s'", str);
@@ -536,7 +536,7 @@
 	*casei = -1;
 
 	// Scan to the next command, exit if there's no next command.
-	for(; *s != '{'; s++) {
+	for (; *s != '{'; s++) {
 		if (*s == '\0')
 			return NULL;
 	}
@@ -583,7 +583,7 @@
 		if (c == '=') s--;
 		// copy params
 		start = s;
-		for(;;) {
+		for (;;) {
 			c = *s++;
 			if (c == '}') break;
 			if (c == '\0') {
@@ -619,7 +619,7 @@
 			Fatal("Invalid pluralform %d", _lang_pluralform);
 	} else if (!memcmp(str, "gender ", 7)) {
 		char *buf = str + 7, *s;
-		for(;;) {
+		for (;;) {
 			s = ParseWord(&buf);
 			if (!s) break;
 			if (_numgenders >= MAX_NUM_GENDER) Fatal("Too many genders, max %d", MAX_NUM_GENDER);
@@ -628,7 +628,7 @@
 		}
 	} else if (!memcmp(str, "case ", 5)) {
 		char *buf = str + 5, *s;
-		for(;;) {
+		for (;;) {
 			s = ParseWord(&buf);
 			if (!s) break;
 			if (_numcases >= MAX_NUM_CASES) Fatal("Too many cases, max %d", MAX_NUM_CASES);
@@ -650,7 +650,7 @@
 
 	memset(p, 0, sizeof(*p));
 
-	for(;;) {
+	for (;;) {
 		// read until next command from a.
 		ar = ParseCommandString((const char **)&s, param, &argno, &casei);
 		if (ar == NULL)
@@ -710,10 +710,10 @@
 		result = false;
 	}
 
-	for(i = 0; i < templ.np; i++) {
+	for (i = 0; i < templ.np; i++) {
 		// see if we find it in lang, and zero it out
 		bool found = false;
-		for(j = 0; j < lang.np; j++) {
+		for (j = 0; j < lang.np; j++) {
 			if (templ.pairs[i].a == lang.pairs[j].a &&
 					!strcmp(templ.pairs[i].v, lang.pairs[j].v)) {
 				// it was found in both. zero it out from lang so we don't find it again
@@ -731,7 +731,7 @@
 
 	// if we reach here, all non consumer commands match up.
 	// Check if the non consumer commands match up also.
-	for(i = 0; i < lengthof(templ.cmd); i++) {
+	for (i = 0; i < lengthof(templ.cmd); i++) {
 		if (TranslateCmdForCompare(templ.cmd[i]) != TranslateCmdForCompare(lang.cmd[i])) {
 			Warning("%s: Param idx #%d '%s' doesn't match with template command '%s'", name, i,
 				!lang.cmd[i] ? "<empty>" : lang.cmd[i]->cmd,
@@ -767,7 +767,7 @@
 
 	// Trim spaces.
 	// After this str points to the command name, and s points to the command contents
-	for(t = s; t > str && (t[-1]==' ' || t[-1]=='\t'); t--);
+	for (t = s; t > str && (t[-1]==' ' || t[-1]=='\t'); t--);
 	*t = 0;
 	s++;
 
@@ -884,7 +884,7 @@
 
 static uint32 MyHashStr(uint32 hash, const char *s)
 {
-	for(; *s; s++) {
+	for (; *s; s++) {
 		hash = ((hash << 3) | (hash >> 29)) ^ *s;
 		if (hash & 1) hash = (hash>>1) ^ 0xDEADBEEF; else hash >>= 1;
 	}
@@ -904,7 +904,7 @@
 	int argno;
 	int casei;
 
-	for(i = 0; i != 65536; i++) {
+	for (i = 0; i != 65536; i++) {
 		if ((ls=_strings[i]) != NULL) {
 			s = ls->name;
 			hash ^= i * 0x717239;
@@ -929,7 +929,7 @@
 {
 	int i;
 
-	for(i = 0x800; --i >= 0;) {
+	for (i = 0x800; --i >= 0;) {
 		if (_strings[(grp<<11)+i] != NULL)
 			break;
 	}
@@ -983,7 +983,7 @@
 
 	lastgrp = 0;
 
-	for(i = 0; i != 65536; i++) {
+	for (i = 0; i != 65536; i++) {
 		if (_strings[i]) {
 			if (lastgrp != (i >> 11)) {
 				lastgrp = (i >> 11);
@@ -1025,7 +1025,7 @@
 	if (argidx < 0 || argidx >= lengthof(_cur_pcs.cmd))
 		Fatal("invalid argidx %d", argidx);
 
-	for(i = sum = 0; i < argidx; i++) {
+	for (i = sum = 0; i < argidx; i++) {
 		const CmdStruct *cs = _cur_pcs.cmd[i];
 		sum += cs ? cs->consumes : 1;
 	}
@@ -1105,7 +1105,7 @@
 	if (f == NULL) Fatal("can't open %s", filename);
 
 	memset(&hdr, 0, sizeof(hdr));
-	for(i = 0; i != 32; i++) {
+	for (i = 0; i != 32; i++) {
 		int n = CountInUse(i);
 		in_use[i] = n;
 		hdr.offsets[i] = TO_LE16(n);
@@ -1121,8 +1121,8 @@
 
 	fwrite(&hdr, sizeof(hdr), 1, f);
 
-	for(i = 0; i != 32; i++) {
-		for(j = 0; j != in_use[i]; j++) {
+	for (i = 0; i != 32; i++) {
+		for (j = 0; j != in_use[i]; j++) {
 			LangString *ls = _strings[(i<<11)+j];
 
 			Case *casep;
@@ -1143,7 +1143,7 @@
 					Warning("'%s' is untranslated", ls->name);
 				} else {
 					const char *s = "<TODO> ";
-					while(*s) PutByte(*s++);
+					while (*s) PutByte(*s++);
 				}
 			}
 
@@ -1169,11 +1169,11 @@
 				// Each LEN is printed using 2 bytes in big endian order.
 				PutByte(0x9E);
 				// Count the number of cases
-				for(num=0,c=casep; c; c=c->next) num++;
+				for (num=0,c=casep; c; c=c->next) num++;
 				PutByte(num);
 
 				// Write each case
-				for(c=casep; c; c=c->next) {
+				for (c=casep; c; c=c->next) {
 					int pos;
 					PutByte(c->caseidx);
 					// Make some space for the 16-bit length
Index: unix.c
===================================================================
--- unix.c	(revision 3486)
+++ unix.c	(working copy)
@@ -457,7 +457,7 @@
 #ifdef WITH_COCOA
 	cocoaSetupAutoreleasePool();
     /* This is passed if we are launched by double-clicking */
-	if(argc >= 2 && strncmp (argv[1], "-psn", 4) == 0) {
+	if (argc >= 2 && strncmp (argv[1], "-psn", 4) == 0) {
 		argv[1] = NULL;
 		argc = 1;
 		cocoaSetWorkingDirectory();
Index: widget.c
===================================================================
--- widget.c	(revision 3486)
+++ widget.c	(working copy)
@@ -477,7 +477,7 @@
 {
 	int item;
 
-	switch(e->event) {
+	switch (e->event) {
 		case WE_PAINT: {
 			int x,y,i,sel;
 
Index: main_gui.c
===================================================================
--- main_gui.c	(revision 3486)
+++ main_gui.c	(working copy)
@@ -1687,7 +1687,7 @@
 {
 	int button;
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowWidgets(w);
 		break;
@@ -1850,7 +1850,7 @@
 
 static void MainToolbarWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 
 		// Draw brown-red toolbar bg.
@@ -2057,7 +2057,7 @@
 
 static void ScenEditToolbarWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		/* XXX look for better place for these */
 		if (_date <= MinDate) {
@@ -2286,7 +2286,7 @@
 static void MainWindowWndProc(Window *w, WindowEvent *e) {
 	int off_x;
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowViewport(w);
 		if (_game_mode == GM_MENU) {
Index: roadveh_gui.c
===================================================================
--- roadveh_gui.c	(revision 3486)
+++ roadveh_gui.c	(working copy)
@@ -230,7 +230,7 @@
 
 static void RoadVehViewWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		Vehicle *v = GetVehicle(w->window_number);
 		StringID str;
@@ -447,7 +447,7 @@
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* listbox */
 			uint i = (e->click.pt.y - 14) / 14;
 			if (i < w->vscroll.cap) {
@@ -679,13 +679,13 @@
 
 static void RoadDepotWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawRoadDepotWindow(w);
 		break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5:
 			RoadDepotClickVeh(w, e->click.pt.x, e->click.pt.y);
 			break;
@@ -739,7 +739,7 @@
 		break;
 
 	case WE_DRAGDROP:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5: {
 			Vehicle *v;
 			VehicleID sel = WP(w,traindepot_d).sel;
@@ -869,7 +869,7 @@
 	PlayerID owner = GB(w->window_number, 0, 8);
 	vehiclelist_d *vl = &WP(w, vehiclelist_d);
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int x = 2;
 		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
@@ -938,7 +938,7 @@
 		}	break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: /* Flip sorting method ascending/descending */
 			vl->flags ^= VL_DESC;
 			vl->flags |= VL_RESORT;
@@ -984,7 +984,7 @@
 				}
 
 				tile = TILE_MASK(tile + 1);
-			} while(tile != _last_built_road_depot_tile);
+			} while (tile != _last_built_road_depot_tile);
 
 			ShowBuildRoadVehWindow(0);
 		} break;
Index: pathfind.c
===================================================================
--- pathfind.c	(revision 3486)
+++ pathfind.c	(working copy)
@@ -185,7 +185,7 @@
 
 		// Change direction 4 times only
 		if ((byte)i != tpf->rd.pft_var6) {
-			if(++tpf->rd.depth > 4) {
+			if (++tpf->rd.depth > 4) {
 				tpf->rd = rd;
 				return;
 			}
@@ -222,7 +222,7 @@
 
 	z = GetSlopeZ(x+8, y+8);
 
-	for(;;) {
+	for (;;) {
 		flotr.length++;
 
 		x += _get_tunlen_inc[direction];
@@ -609,7 +609,7 @@
 
 	// else it's a linked list of many tiles
 	offs = tpf->hash_tile[hash];
-	for(;;) {
+	for (;;) {
 		link = NTP_GET_LINK_PTR(tpf, offs);
 		if (tile == link->tile && (uint)(link->typelength & 0x3) == dir) {
 			assert( (uint)(link->typelength >> 2) <= length);
@@ -690,7 +690,7 @@
 	si.first_track = 0xFF;
 	goto start_at;
 
-	for(;;) {
+	for (;;) {
 		// Get the next item to search from from the priority queue
 		do {
 			if (tpf->nstack == 0)
@@ -734,7 +734,7 @@
 		// This is a special loop used to go through
 		// a rail net and find the first intersection
 		tile_org = tile;
-		for(;;) {
+		for (;;) {
 			assert(direction <= 3);
 			tile += TileOffsByDir(direction);
 
Index: bridge_gui.c
===================================================================
--- bridge_gui.c	(revision 3486)
+++ bridge_gui.c	(working copy)
@@ -40,7 +40,7 @@
 
 static void BuildBridgeWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		uint i;
 
Index: settings.c
===================================================================
--- settings.c	(revision 3486)
+++ settings.c	(working copy)
@@ -130,7 +130,7 @@
 	IniGroup *grp = pool_alloc(&ini->pool, sizeof(IniGroup));
 	grp->ini = ini;
 	grp->name = pool_strdup(&ini->pool, grpt, len);
-	if(!strcmp(grp->name, "newgrf") || !strcmp(grp->name, "servers") || !strcmp(grp->name, "bans") )
+	if (!strcmp(grp->name, "newgrf") || !strcmp(grp->name, "servers") || !strcmp(grp->name, "bans") )
 		grp->type = IGT_LIST;
 	else
 		grp->type = IGT_VARIABLES;
@@ -177,7 +177,7 @@
 	while (fgets(buffer, sizeof(buffer), in)) {
 
 		// trim whitespace from the left side
-		for(s=buffer; s[0] == ' ' || s[0] == '\t'; s++);
+		for (s=buffer; s[0] == ' ' || s[0] == '\t'; s++);
 
 		// trim whitespace from right side.
 		e = s + strlen(s);
@@ -216,7 +216,7 @@
 			}
 		} else if (group) {
 			// find end of keyname
-			for(t=s; *t != 0 && *t != '=' && *t != '\t' && *t != ' '; t++) {}
+			for (t=s; *t != 0 && *t != '=' && *t != '\t' && *t != ' '; t++) {}
 
 			// it's an item in an existing group
 			item = ini_item_alloc(group, s, t-s);
@@ -226,7 +226,7 @@
 			}
 
 			// for list items, the name and value are the same:
-			if( group->type == IGT_LIST ) {
+			if ( group->type == IGT_LIST ) {
 				item->value = item->name;
 				continue;
 			}
@@ -236,10 +236,10 @@
 
 
 			// remove starting quotation marks
-			if(*t=='\"') t++;
+			if (*t=='\"') t++;
 			// remove ending quotation marks
 			e = t + strlen(t);
-			if(e>t && e[-1] =='\"') e--;
+			if (e>t && e[-1] =='\"') e--;
 			*e = 0;
 
 			item->value = pool_strdup(&ini->pool, t, e - t);
@@ -268,7 +268,7 @@
 	if (len == -1) len = strlen(name);
 
 	// does it exist already?
-	for(group = ini->group; group; group = group->next)
+	for (group = ini->group; group; group = group->next)
 		if (!memcmp(group->name, name, len) && group->name[len] == 0)
 			return group;
 
@@ -284,7 +284,7 @@
 	IniItem *item;
 	uint len = strlen(name);
 
-	for(item = group->item; item; item = item->next)
+	for (item = group->item; item; item = item->next)
 		if (!strcmp(item->name, name))
 			return item;
 
@@ -310,7 +310,7 @@
 		fprintf(f, "[%s]\n", group->name);
 		for (item = group->item; item != NULL; item = item->next) {
 			if (item->comment) fputs(item->comment, f);
-			if(group->type==IGT_LIST)
+			if (group->type==IGT_LIST)
 				fprintf(f, "%s\n", item->value ? item->value : "");
 			else
 				fprintf(f, "%s = %s\n", item->name, item->value ? item->value : "");
@@ -339,7 +339,7 @@
 		return strtoul(one, NULL, 0);
 
 	idx = 0;
-	for(;;) {
+	for (;;) {
 		// find end of item
 		s = many;
 		while (*s != '|' && *s != 0) s++;
@@ -356,7 +356,7 @@
 	int r;
 	uint32 res = 0;
 
-	for(;;) {
+	for (;;) {
 		// skip "whitespace"
 		while (*str == ' ' || *str == '\t' || *str == '|') str++;
 		if (*str == 0) break;
@@ -379,7 +379,7 @@
 	int n = 0, v;
 	char *end;
 
-	for(;;) {
+	for (;;) {
 		v = strtol(p, &end, 0);
 		if (p == end || n == maxitems) return -1;
 		p = end;
@@ -406,18 +406,18 @@
 			return false;
 	}
 
-	switch(type) {
+	switch (type) {
 	case SDT_INT8 >> 4:
 	case SDT_UINT8 >> 4:
-		for(i=0; i!=nitems; i++) ((byte*)array)[i] = items[i];
+		for (i=0; i!=nitems; i++) ((byte*)array)[i] = items[i];
 		break;
 	case SDT_INT16 >> 4:
 	case SDT_UINT16 >> 4:
-		for(i=0; i!=nitems; i++) ((uint16*)array)[i] = items[i];
+		for (i=0; i!=nitems; i++) ((uint16*)array)[i] = items[i];
 		break;
 	case SDT_INT32 >> 4:
 	case SDT_UINT32 >> 4:
-		for(i=0; i!=nitems; i++) ((uint32*)array)[i] = items[i];
+		for (i=0; i!=nitems; i++) ((uint32*)array)[i] = items[i];
 		break;
 	default:
 		NOT_REACHED();
@@ -430,8 +430,8 @@
 {
 	int i, v = 0;
 	byte *p = (byte*)array;
-	for(i=0; i!=nelems; i++) {
-		switch(type) {
+	for (i=0; i!=nelems; i++) {
+		switch (type) {
 		case SDT_INT8 >> 4: v = *(int8*)p; p += 1; break;
 		case SDT_UINT8 >> 4:v = *(byte*)p; p += 1; break;
 		case SDT_INT16 >> 4:v = *(int16*)p; p += 2; break;
@@ -494,7 +494,7 @@
 	unsigned long val;
 	char *end;
 
-	switch(desc->flags & 0xF) {
+	switch (desc->flags & 0xF) {
 	case SDT_INTX:
 		val = strtoul(str, &end, 0);
 		if (*end != 0) ShowInfoF("ini: trailing characters at end of setting '%s'", desc->name);
@@ -558,13 +558,13 @@
 		// get ptr to array
 		ptr = desc->ptr;
 
-		switch(desc->flags & 0xF) {
+		switch (desc->flags & 0xF) {
 		// all these are stored in the same way
 		case SDT_INTX:
 		case SDT_ONEOFMANY:
 		case SDT_MANYOFMANY:
 		case SDT_BOOLX:
-			switch(desc->flags >> 4 & 7) {
+			switch (desc->flags >> 4 & 7) {
 			case SDT_INT8 >> 4:
 			case SDT_UINT8 >> 4:
 				*(byte*)ptr = (byte)(unsigned long)p;
@@ -640,12 +640,12 @@
 			// check if the value is the same as the old value
 			p = string_to_val(desc, item->value);
 
-			switch(desc->flags & 0xF) {
+			switch (desc->flags & 0xF) {
 			case SDT_INTX:
 			case SDT_ONEOFMANY:
 			case SDT_MANYOFMANY:
 			case SDT_BOOLX:
-				switch(desc->flags >> 4 & 7) {
+				switch (desc->flags >> 4 & 7) {
 				case SDT_INT8 >> 4:
 				case SDT_UINT8 >> 4:
 					if (*(byte*)ptr == (byte)(unsigned long)p)
@@ -674,12 +674,12 @@
 			}
 		}
 
-		switch(desc->flags & 0xF) {
+		switch (desc->flags & 0xF) {
 		case SDT_INTX:
 		case SDT_ONEOFMANY:
 		case SDT_MANYOFMANY:
 		case SDT_BOOLX:
-			switch(desc->flags >> 4 & 7) {
+			switch (desc->flags >> 4 & 7) {
 			case SDT_INT8 >> 4: i = *(int8*)ptr; break;
 			case SDT_UINT8 >> 4:i = *(byte*)ptr; break;
 			case SDT_INT16 >> 4:i = *(int16*)ptr; break;
@@ -689,7 +689,7 @@
 			default:
 				NOT_REACHED();
 			}
-			switch(desc->flags & 0xF) {
+			switch (desc->flags & 0xF) {
 			case SDT_INTX:
 				sprintf(buf, "%u", i);
 				break;
Index: disaster_cmd.c
===================================================================
--- disaster_cmd.c	(revision 3486)
+++ disaster_cmd.c	(working copy)
@@ -621,7 +621,7 @@
 
 		DeleteDisasterVeh(u);
 
-		for(i=0; i!=80; i++) {
+		for (i=0; i!=80; i++) {
 			uint32 r = Random();
 			CreateEffectVehicleAbove(
 				GB(r, 0, 6) + v->x_pos - 32,
Index: train_gui.c
===================================================================
--- train_gui.c	(revision 3486)
+++ train_gui.c	(working copy)
@@ -194,7 +194,7 @@
 
 static void NewRailVehicleWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 
 		if (w->window_number == 0)
@@ -250,7 +250,7 @@
 	break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: {
 			uint i = (e->click.pt.y - 14) / 14;
 			if (i < w->vscroll.cap) {
@@ -571,7 +571,7 @@
 
 	v = gdvp.wagon;
 
-	switch(mode) {
+	switch (mode) {
 	case 0: { // start dragging of vehicle
 		VehicleID sel = WP(w, traindepot_d).sel;
 
@@ -628,13 +628,13 @@
 
 static void TrainDepotWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawTrainDepotWindow(w);
 		break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 8:
 			ResetObjectToPlace();
 			ShowBuildTrainWindow(w->window_number);
@@ -687,7 +687,7 @@
 		break;
 
 	case WE_DRAGDROP: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 4: case 5: {
 			Vehicle *v;
 			int sell_cmd;
@@ -825,7 +825,7 @@
 	}	break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* listbox */
 			int y = e->click.pt.y - 25;
 			if (y >= 0) {
@@ -986,7 +986,7 @@
 		int wid = e->click.widget;
 		Vehicle *v = GetVehicle(w->window_number);
 
-		switch(wid) {
+		switch (wid) {
 		case 5: /* start/stop train */
 			DoCommandP(v->tile, v->index, 0, NULL, CMD_START_STOP_TRAIN | CMD_MSG(STR_883B_CAN_T_STOP_START_TRAIN));
 			break;
@@ -1198,7 +1198,7 @@
 	// draw the first 3 details tabs
 	if (det_tab != 3) {
 		x = 1;
-		for(;;) {
+		for (;;) {
 			if (--sel < 0 && sel >= -6) {
 				int dx = 0;
 				u = v;
@@ -1373,7 +1373,7 @@
 	PlayerID owner = GB(w->window_number, 0, 8);
 	vehiclelist_d *vl = &WP(w, vehiclelist_d);
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int x = 2;
 		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
@@ -1443,7 +1443,7 @@
 	}
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: /* Flip sorting method ascending/descending */
 			vl->flags ^= VL_DESC;
 			vl->flags |= VL_RESORT;
@@ -1490,7 +1490,7 @@
 				}
 
 				tile = TILE_MASK(tile + 1);
-			} while(tile != _last_built_train_depot_tile);
+			} while (tile != _last_built_train_depot_tile);
 
 			ShowBuildTrainWindow(0);
 		} break;
Index: industry_gui.c
===================================================================
--- industry_gui.c	(revision 3486)
+++ industry_gui.c	(working copy)
@@ -26,7 +26,7 @@
 
 static void BuildIndustryWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowWidgets(w);
 		if (_thd.place_mode == 1 && _thd.window_class == WC_BUILD_INDUSTRY) {
@@ -278,7 +278,7 @@
 	// WP(w,vp2_d).data_2 is for the clickline
 	// WP(w,vp2_d).data_3 is for the click pos (left or right)
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		const Industry *i;
 		StringID str;
@@ -331,7 +331,7 @@
 	case WE_CLICK: {
 		Industry *i;
 
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5: {
 			int line;
 			int x;
@@ -549,7 +549,7 @@
 		error("Could not allocate memory for the industry-sorting-list");
 
 	FOR_ALL_INDUSTRIES(i) {
-		if(i->xy)
+		if (i->xy)
 			_industry_sort[n++] = i->index;
 	}
 	_num_industry_sort = n;
@@ -563,7 +563,7 @@
 
 static void IndustryDirectoryWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int n;
 		uint p;
@@ -610,7 +610,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: {
 			_industry_sort_order = _industry_sort_order==0 ? 1 : 0;
 			_industry_sort_dirty = true;
Index: road_gui.c
===================================================================
--- road_gui.c	(revision 3486)
+++ road_gui.c	(working copy)
@@ -405,7 +405,7 @@
 
 static void RoadStationPickerWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int image;
 
Index: rail_gui.c
===================================================================
--- rail_gui.c	(revision 3486)
+++ rail_gui.c	(working copy)
@@ -141,7 +141,7 @@
 
 static void PlaceRail_Station(TileIndex tile)
 {
-	if(_remove_button_clicked)
+	if (_remove_button_clicked)
 		DoCommandP(tile, 0, 0, CcPlaySound1E, CMD_REMOVE_FROM_RAILROAD_STATION | CMD_MSG(STR_CANT_REMOVE_PART_OF_STATION));
 	else if (_railstation.dragdrop) {
 		VpStartPlaceSizing(tile, VPM_X_AND_Y_LIMITED);
@@ -631,7 +631,7 @@
 			int x = _railstation.numtracks;
 			int y = _railstation.platlength;
 			if (_railstation.orientation == 0) intswap(x,y);
-			if(!_remove_button_clicked)
+			if (!_remove_button_clicked)
 				SetTileSelectSize(x, y);
 		}
 
@@ -768,7 +768,7 @@
 
 static void BuildTrainDepotWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		RailType r;
 
Index: network_gui.c
===================================================================
--- network_gui.c	(revision 3486)
+++ network_gui.c	(working copy)
@@ -447,7 +447,7 @@
 	}	break;
 
 	case WE_DROPDOWN_SELECT: /* we have selected a dropdown item in the list */
-		switch(e->dropdown.button) {
+		switch (e->dropdown.button) {
 			case 5:
 				_network_lan_internet = e->dropdown.index;
 				break;
@@ -700,7 +700,7 @@
 		break;
 
 	case WE_DROPDOWN_SELECT: /* we have selected a dropdown item in the list */
-		switch(e->dropdown.button) {
+		switch (e->dropdown.button) {
 			case  8: _network_advertise = (e->dropdown.index != 0); break;
 			case 10: _network_game_info.clients_max = e->dropdown.index; break;
 			case 12: _network_game_info.companies_max = e->dropdown.index; break;
Index: os/macosx/splash.c
===================================================================
--- os/macosx/splash.c	(revision 3486)
+++ os/macosx/splash.c	(working copy)
@@ -87,13 +87,13 @@
 	bit_depth        = png_get_bit_depth(png_ptr, info_ptr);
 	color_type       = png_get_color_type(png_ptr, info_ptr);
 
-	if(color_type != PNG_COLOR_TYPE_PALETTE || bit_depth != 8) {
+	if (color_type != PNG_COLOR_TYPE_PALETTE || bit_depth != 8) {
 		png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
 		fclose(f);
 		return;
 	}
 
-	if(!png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE)) {
+	if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE)) {
 		png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
 		fclose(f);
 		return;
@@ -105,14 +105,14 @@
 
 	memset(_screen.dst_ptr, 0xff, _screen.pitch * _screen.height);
 
-	if(width > (uint) _screen.width)
+	if (width > (uint) _screen.width)
 		width = _screen.width;
-	if(height > (uint) _screen.height)
+	if (height > (uint) _screen.height)
 		height = _screen.height;
 
 	xoff = (_screen.width - width) / 2;
 	yoff = (_screen.height - height) / 2;
-	for(y = 0; y < height; y++) {
+	for (y = 0; y < height; y++) {
 		src = row_pointers[y];
 		dst = ((uint8 *) _screen.dst_ptr) + (yoff + y) * _screen.pitch + xoff;
 
Index: settings_gui.c
===================================================================
--- settings_gui.c	(revision 3486)
+++ settings_gui.c	(working copy)
@@ -899,7 +899,7 @@
 	}
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: {
 			int x,y;
 			uint btn;
@@ -926,7 +926,7 @@
 			if (x < 21) { // clicked on the icon on the left side. Either scroller or bool on/off
 				int32 val = ReadPE(pe), oval = val;
 
-				switch(pe->type) {
+				switch (pe->type) {
 				case PE_BOOL:
 					val ^= 1;
 					break;
@@ -1216,7 +1216,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: { // select a grf file
 			int y = (e->click.pt.y - NEWGRF_WND_PROC_OFFSET_TOP_WIDGET) / NEWGRF_WND_PROC_ROWSIZE;
 
Index: network_server.c
===================================================================
--- network_server.c	(revision 3486)
+++ network_server.c	(working copy)
@@ -1482,7 +1482,7 @@
 {
 	Packet *p;
 	NetworkRecvStatus res;
-	while((p = NetworkRecv_Packet(cs, &res)) != NULL) {
+	while ((p = NetworkRecv_Packet(cs, &res)) != NULL) {
 		byte type = NetworkRecv_uint8(cs, p);
 		if (type < PACKET_END && _network_server_packet[type] != NULL && !cs->quited)
 			_network_server_packet[type](cs, p);
Index: town_gui.c
===================================================================
--- town_gui.c	(revision 3486)
+++ town_gui.c	(working copy)
@@ -466,7 +466,7 @@
 	} break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: { /* Sort by Name ascending/descending */
 			_town_sort_order = (_town_sort_order == 0) ? 1 : 0;
 			_town_sort_dirty = true;
Index: fileio.c
===================================================================
--- fileio.c	(revision 3486)
+++ fileio.c	(working copy)
@@ -59,7 +59,7 @@
 
 void FioSkipBytes(int n)
 {
-	for(;;) {
+	for (;;) {
 		int m = min(_fio.buffer_end - _fio.buffer, n);
 		_fio.buffer += m;
 		n -= m;
@@ -117,7 +117,7 @@
 	if (f == NULL) {
 		char *s;
 		// Make lower case and try again
-		for(s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
+		for (s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
 			*s = tolower(*s);
 		f = fopen(buf, "rb");
 
@@ -125,7 +125,7 @@
 	// tries in the 2nd data directory
 		if (f == NULL) {
 			sprintf(buf, "%s%s", _path.second_data_dir, filename);
-			for(s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
+			for (s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
 			*s = tolower(*s);
 		f = fopen(buf, "rb");
 		}
@@ -153,7 +153,7 @@
 	if (f == NULL) {
 		char *s;
 		// Make lower case and try again
-		for(s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
+		for (s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
 			*s = tolower(*s);
 		f = fopen(buf, "rb");
 
@@ -161,7 +161,7 @@
 		// tries in the 2nd data directory
 		if (f == NULL) {
 			sprintf(buf, "%s%s", _path.second_data_dir, filename);
-			for(s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
+			for (s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
 				*s = tolower(*s);
 			f = fopen(buf, "rb");
 		}
@@ -184,7 +184,7 @@
 	if (f == NULL) {
 		char *s;
 		// Make lower case and try again
-		for(s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
+		for (s=buf + strlen(_path.data_dir) - 1; *s != 0; s++)
 			*s = tolower(*s);
 		f = fopen(buf, "rb");
 
@@ -192,7 +192,7 @@
 	// tries in the 2nd data directory
 		if (f == NULL) {
 			sprintf(buf, "%s%s", _path.second_data_dir, filename);
-			for(s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
+			for (s=buf + strlen(_path.second_data_dir) - 1; *s != 0; s++)
 			*s = tolower(*s);
 		f = fopen(buf, "rb");
 		}
Index: ship_gui.c
===================================================================
--- ship_gui.c	(revision 3486)
+++ ship_gui.c	(working copy)
@@ -369,7 +369,7 @@
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* listbox */
 			uint i = (e->click.pt.y - 14) / 24;
 			if (i < w->vscroll.cap) {
@@ -460,7 +460,7 @@
 
 
 static void ShipViewWndProc(Window *w, WindowEvent *e) {
-	switch(e->event) {
+	switch (e->event) {
 		case WE_PAINT: {
 			Vehicle *v = GetVehicle(w->window_number);
 			uint32 disabled = 1<<8;
@@ -763,7 +763,7 @@
 		break;
 
 	case WE_CLICK:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5:
 			ShipDepotClick(w, e->click.pt.x, e->click.pt.y);
 			break;
@@ -817,7 +817,7 @@
 		break;
 
 	case WE_DRAGDROP:
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 5: {
 			Vehicle *v;
 			VehicleID sel = WP(w,traindepot_d).sel;
@@ -970,7 +970,7 @@
 	PlayerID owner = GB(w->window_number, 0, 8);
 	vehiclelist_d *vl = &WP(w, vehiclelist_d);
 
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT: {
 		int x = 2;
 		int y = PLY_WND_PRC__OFFSET_TOP_WIDGET;
@@ -1041,7 +1041,7 @@
 		}	break;
 
 	case WE_CLICK: {
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 3: /* Flip sorting method ascending/descending */
 			vl->flags ^= VL_DESC;
 			vl->flags |= VL_RESORT;
@@ -1085,7 +1085,7 @@
 				}
 
 				tile = TILE_MASK(tile + 1);
-			} while(tile != _last_built_ship_depot_tile);
+			} while (tile != _last_built_ship_depot_tile);
 
 			ShowBuildShipWindow(0);
 		} break;
Index: window.c
===================================================================
--- window.c	(revision 3486)
+++ window.c	(working copy)
@@ -48,7 +48,7 @@
 
 		if (wi->type & 0xE0) {
 			/* special widget handling for buttons*/
-			switch(wi->type) {
+			switch (wi->type) {
 			case WWT_IMGBTN  | WWB_PUSHBUTTON: /* WWT_PUSHIMGBTN */
 			case WWT_TEXTBTN | WWB_PUSHBUTTON: /* WWT_PUSHTXTBTN */
 				HandleButtonClick(w, e.click.widget);
@@ -648,7 +648,7 @@
 		} else {
 			if (pt.x == WDP_CENTER) pt.x = (_screen.width - desc->width) >> 1;
 			if (pt.y == WDP_CENTER) pt.y = (_screen.height - desc->height) >> 1;
-			else if(pt.y < 0) pt.y = _screen.height + pt.y; // if y is negative, it's from the bottom of the screen
+			else if (pt.y < 0) pt.y = _screen.height + pt.y; // if y is negative, it's from the bottom of the screen
 		}
 	}
 
Index: ai/default/default.c
===================================================================
--- ai/default/default.c	(revision 3486)
+++ ai/default/default.c	(working copy)
@@ -655,7 +655,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 		// look for one from the subsidy list
 		AiFindSubsidyIndustryRoute(&fr);
 		if (IS_INT_INSIDE(fr.distance, 60, 90+1))
@@ -761,7 +761,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyIndustryRoute(&fr);
@@ -833,7 +833,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyIndustryRoute(&fr);
@@ -905,7 +905,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyPassengerRoute(&fr);
@@ -1010,7 +1010,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyPassengerRoute(&fr);
@@ -1102,7 +1102,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyIndustryRoute(&fr);
@@ -1162,7 +1162,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyIndustryRoute(&fr);
@@ -1222,7 +1222,7 @@
 	FoundRoute fr;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyPassengerRoute(&fr);
@@ -1285,7 +1285,7 @@
 	Town *t;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 		// Find a town big enough
 		t = AiFindRandomTown();
 		if (t != NULL && t->population >= 700)
@@ -1357,7 +1357,7 @@
 	int i;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 
 		// look for one from the subsidy list
 		AiFindSubsidyPassengerRoute(&fr);
@@ -1416,7 +1416,7 @@
 	Industry *in;
 
 	i = 60;
-	for(;;) {
+	for (;;) {
 		// Find a town
 		t = AiFindRandomTown();
 		if (t != NULL) {
@@ -1498,7 +1498,7 @@
 	}
 
 	i = 200;
-	for(;;) {
+	for (;;) {
 		r = (uint16)Random();
 
 		if (_patches.ai_disable_veh_train && _patches.ai_disable_veh_roadveh &&
@@ -1536,7 +1536,7 @@
 	uint values[NUM_CARGO];
 	int rad;
 
-	for(;p->mode != 4;p++) if (p->mode == 1) {
+	for (;p->mode != 4;p++) if (p->mode == 1) {
 		TileIndex tile2 = TILE_ADD(tile, ToTileIndexDiff(p->tileoffs));
 		uint w;
 		uint h;
@@ -1576,7 +1576,7 @@
 	int rating = 0;
 	int i,j,k;
 
-	for(;;) {
+	for (;;) {
 		// This will seldomly overflow for valid reasons. Mask it to be on the safe side.
 		uint c = TILE_MASK(tile + ToTileIndexDiff(p->tileoffs));
 
@@ -1965,7 +1965,7 @@
 		tile_new = tile;
 		// Allow bridges directly over bottom tiles
 		flag = arf->ti.z == 0;
-		for(;;) {
+		for (;;) {
 			if ((TileIndexDiff)tile_new < -TileOffsByDir(dir2)) return; // Wraping around map, no bridge possible!
 			tile_new = TILE_MASK(tile_new + TileOffsByDir(dir2));
 			FindLandscapeHeightByTile(&arf->ti, tile_new);
@@ -2118,7 +2118,7 @@
 	// Didn't find anything to build?
 	if (arf.best_ptr == NULL) {
 		// Terraform some
-		for(i=0; i!=5; i++)
+		for (i=0; i!=5; i++)
 			AiDoTerraformLand(p->ai.cur_tile_a, p->ai.cur_dir_a, 3, 0);
 
 		if (++p->ai.state_counter == 21) {
@@ -2169,7 +2169,7 @@
 	}
 
 	if (arf.best_tile != 0) {
-		for(i=0; i!=2; i++)
+		for (i=0; i!=2; i++)
 			AiDoTerraformLand(arf.best_tile, arf.best_dir, 3, 0);
 	}
 }
@@ -2274,7 +2274,7 @@
 	} else if (p->ai.state_mode == 2) {
 
 		// Terraform some and then try building again.
-		for(i=0; i!=4; i++)
+		for (i=0; i!=4; i++)
 			AiDoTerraformLand(p->ai.cur_tile_a, p->ai.cur_dir_a, 3, 0);
 
 		if (++p->ai.state_counter == 4) {
@@ -2314,7 +2314,7 @@
 	num = p->ai.num_build_rec;
 	aib = &p->ai.src;
 
-	for(;;) {
+	for (;;) {
 		cmd = aib->buildcmd_a;
 		aib->buildcmd_a = 255;
 		if (cmd != 255) break;
@@ -2382,7 +2382,7 @@
 	tile = TILE_ADD(p->ai.src.use_tile, ToTileIndexDiff(ptr->tileoffs));
 
 	cargo = p->ai.cargo_type;
-	for(i=0;;) {
+	for (i=0;;) {
 		if (p->ai.wagon_list[i] == INVALID_VEHICLE) {
 			veh = _cargoc.ai_railwagon[p->ai.railtype_to_use][cargo];
 			cost = DoCommandByTile(tile, veh, 0, DC_EXEC, CMD_BUILD_RAIL_VEHICLE);
@@ -2403,7 +2403,7 @@
 handle_nocash:
 		// after a while, if AI still doesn't have cash, get out of this block by selling the wagons.
 		if (++p->ai.state_counter == 1000) {
-			for(i=0; p->ai.wagon_list[i] != INVALID_VEHICLE; i++) {
+			for (i=0; p->ai.wagon_list[i] != INVALID_VEHICLE; i++) {
 				cost = DoCommandByTile(tile, p->ai.wagon_list[i], 0, DC_EXEC, CMD_SELL_RAIL_WAGON);
 				assert(!CmdFailed(cost));
 			}
@@ -2426,11 +2426,11 @@
 	}
 
 	// Move the wagons onto the train
-	for(i=0; p->ai.wagon_list[i] != INVALID_VEHICLE; i++) {
+	for (i=0; p->ai.wagon_list[i] != INVALID_VEHICLE; i++) {
 		DoCommandByTile(tile, p->ai.wagon_list[i] | (loco_id << 16), 0, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);
 	}
 
-	for(i=0; p->ai.order_list_blocks[i] != 0xFF; i++) {
+	for (i=0; p->ai.order_list_blocks[i] != 0xFF; i++) {
 		AiBuildRec *aib = (&p->ai.src) + p->ai.order_list_blocks[i];
 		bool is_pass = (p->ai.cargo_type == CT_PASSENGERS ||
 							p->ai.cargo_type == CT_MAIL ||
@@ -2495,7 +2495,7 @@
 		rad = 4;
 	}
 
-	for(;;p++) {
+	for (;;p++) {
 		if (p->mode == 4) {
 			return true;
 		} else if (p->mode == 1) {
@@ -2523,7 +2523,7 @@
 
 	_want_road_truck_station = (cargo & 0x7F) != CT_PASSENGERS;
 
-	for(i=0; (p = _road_default_block_data[i]) != NULL; i++) {
+	for (i=0; (p = _road_default_block_data[i]) != NULL; i++) {
 		if (p->dir == direction) {
 			*cost = AiDoBuildDefaultRoadBlock(tile, p->data, 0);
 			if (!CmdFailed(*cost) && AiCheckRoadResources(tile, p->data, cargo))
@@ -2542,7 +2542,7 @@
 	int rating = 0;
 	int roadflag = 0;
 
-	for(;p->mode != 4;p++) {
+	for (;p->mode != 4;p++) {
 		uint c = TILE_MASK(tile + ToTileIndexDiff(p->tileoffs));
 
 		_cleared_town = NULL;
@@ -2855,7 +2855,7 @@
 		tile_new = tile;
 		// Allow bridges directly over bottom tiles
 		flag = arf->ti.z == 0;
-		for(;;) {
+		for (;;) {
 			if ((TileIndexDiff)tile_new < -TileOffsByDir(dir2)) return; // Wraping around map, no bridge possible!
 			tile_new = TILE_MASK(tile_new + TileOffsByDir(dir2));
 			FindLandscapeHeightByTile(&arf->ti, tile_new);
@@ -2999,7 +2999,7 @@
 	if (arf.best_ptr == NULL) {
 		// Terraform some
 do_some_terraform:
-		for(i=0; i!=5; i++)
+		for (i=0; i!=5; i++)
 			AiDoTerraformLand(p->ai.cur_tile_a, p->ai.cur_dir_a, 3, 0);
 
 		if (++p->ai.state_counter == 21) {
@@ -3025,7 +3025,7 @@
 				unnecessary to check for worse bridge (i=0), since AI will always build that.
 				AI is so fucked up that fixing this small thing will probably not solve a thing
 		*/
-		for(i = 10; i != 0; i--) {
+		for (i = 10; i != 0; i--) {
 			if (CheckBridge_Stuff(i, bridge_len)) {
 				int32 cost = DoCommandByTile(tile, p->ai.cur_tile_a, i + (0x80 << 8), DC_AUTO, CMD_BUILD_BRIDGE);
 				if (!CmdFailed(cost) && cost < (p->player_money >> 5))
@@ -3054,7 +3054,7 @@
 	}
 
 	if (arf.best_tile != 0) {
-		for(i=0; i!=2; i++)
+		for (i=0; i!=2; i++)
 			AiDoTerraformLand(arf.best_tile, arf.best_dir, 3, 0);
 	}
 }
@@ -3074,7 +3074,7 @@
 	} else if (p->ai.state_mode == 2) {
 
 		// Terraform some and then try building again.
-		for(i=0; i!=4; i++)
+		for (i=0; i!=4; i++)
 			AiDoTerraformLand(p->ai.cur_tile_a, p->ai.cur_dir_a, 3, 0);
 
 		if (++p->ai.state_counter == 4) {
@@ -3124,7 +3124,7 @@
 	num = p->ai.num_build_rec;
 	aib = &p->ai.src;
 
-	for(;;) {
+	for (;;) {
 		cmd = aib->buildcmd_a;
 		aib->buildcmd_a = 255;
 		if (cmd != 255) break;
@@ -3173,7 +3173,7 @@
 	int i;
 
 	ptr = _road_default_block_data[p->ai.src.cur_building_rule]->data;
-	for(;ptr->mode != 0;ptr++) {}
+	for (;ptr->mode != 0;ptr++) {}
 	tile = TILE_ADD(p->ai.src.use_tile, ToTileIndexDiff(ptr->tileoffs));
 
 	veh = AiChooseRoadVehToBuild(p->ai.cargo_type, p->player_money, tile);
@@ -3336,7 +3336,7 @@
 {
 	int32 total_cost = 0, ret;
 
-	for(;p->mode == 0;p++) {
+	for (;p->mode == 0;p++) {
 		if (!HASBIT(_avail_aircraft, p->attr))
 			return CMD_ERROR;
 		ret = DoCommandByTile(TILE_MASK(tile + ToTileIndexDiff(p->tileoffs)), p->attr,0,flag | DC_AUTO | DC_NO_WATER,CMD_BUILD_AIRPORT);
@@ -3359,7 +3359,7 @@
 		rad = 4;
 	}
 
-	for(;p->mode==0;p++) {
+	for (;p->mode==0;p++) {
 		TileIndex tile2 = TILE_ADD(tile, ToTileIndexDiff(p->tileoffs));
 
 		w = _airport_size_x[p->attr];
@@ -3379,7 +3379,7 @@
 {
 	int i;
 	const AiDefaultBlockData *p;
-	for(i=0; (p = _airport_default_block_data[i]) != NULL; i++) {
+	for (i=0; (p = _airport_default_block_data[i]) != NULL; i++) {
 		// If we are doing a helicopter service, avoid building
 		// airports where they can't land.
 		if (heli && GetAirport(p->attr)->acc_planes == AIRCRAFT_ONLY)
@@ -3490,7 +3490,7 @@
 	uint loco_id;
 
 	ptr = _airport_default_block_data[p->ai.src.cur_building_rule];
-	for(;ptr->mode!=0;ptr++) {}
+	for (;ptr->mode!=0;ptr++) {}
 
 	tile = TILE_ADD(p->ai.src.use_tile, ToTileIndexDiff(ptr->tileoffs));
 
@@ -3503,7 +3503,7 @@
 	if (CmdFailed(DoCommandByTile(tile, veh, 0, DC_EXEC, CMD_BUILD_AIRCRAFT))) return;
 	loco_id = _new_aircraft_id;
 
-	for(i=0; p->ai.order_list_blocks[i] != 0xFF; i++) {
+	for (i=0; p->ai.order_list_blocks[i] != 0xFF; i++) {
 		AiBuildRec *aib = (&p->ai.src) + p->ai.order_list_blocks[i];
 		bool is_pass = (p->ai.cargo_type == CT_PASSENGERS || p->ai.cargo_type == CT_MAIL);
 		Order order;
Index: unmovable_cmd.c
===================================================================
--- unmovable_cmd.c	(revision 3486)
+++ unmovable_cmd.c	(working copy)
@@ -345,7 +345,7 @@
 	do {
 		tile = RandomTile();
 		if (IsTileType(tile, MP_CLEAR) && GetTileSlope(tile, &h) == 0 && h >= 32) {
-			if(!checkRadioTowerNearby(tile))
+			if (!checkRadioTowerNearby(tile))
 				continue;
 			SetTileType(tile, MP_UNMOVABLE);
 			_m[tile].m5 = 0;
Index: mersenne.c
===================================================================
--- mersenne.c	(revision 3486)
+++ mersenne.c	(working copy)
@@ -25,7 +25,7 @@
     register uint32 x = (seed | 1U) & 0xFFFFFFFFU, *s = _mt_state;
     register int    j;
 
-    for(_mt_left=0, *s++=x, j=N; --j;
+    for (_mt_left=0, *s++=x, j=N; --j;
         *s++ = (x*=69069U) & 0xFFFFFFFFU);
  }
 
@@ -35,15 +35,15 @@
     register uint32 *p0=_mt_state, *p2=_mt_state+2, *pM=_mt_state+M, s0, s1;
     register int    j;
 
-    if(_mt_left < -1)
+    if (_mt_left < -1)
         SeedMT(4357U);
 
     _mt_left=N-1, _mt_next=_mt_state+1;
 
-    for(s0=_mt_state[0], s1=_mt_state[1], j=N-M+1; --j; s0=s1, s1=*p2++)
+    for (s0=_mt_state[0], s1=_mt_state[1], j=N-M+1; --j; s0=s1, s1=*p2++)
         *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
 
-    for(pM=_mt_state, j=M; --j; s0=s1, s1=*p2++)
+    for (pM=_mt_state, j=M; --j; s0=s1, s1=*p2++)
         *p0++ = *pM++ ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
 
     s1=_mt_state[0], *p0 = *pM ^ (mixBits(s0, s1) >> 1) ^ (loBit(s1) ? K : 0U);
@@ -58,7 +58,7 @@
 {
 	uint32 y;
 
-	if(--_mt_left < 0)
+	if (--_mt_left < 0)
 		return ReloadMT();
 
 	y  = *_mt_next++;
Index: order_gui.c
===================================================================
--- order_gui.c	(revision 3486)
+++ order_gui.c	(working copy)
@@ -392,7 +392,7 @@
 
 	case WE_CLICK: {
 		Vehicle *v = GetVehicle(w->window_number);
-		switch(e->click.widget) {
+		switch (e->click.widget) {
 		case 2: { /* orders list */
 			int sel;
 			sel = (e->click.pt.y - 15) / 10;
@@ -460,7 +460,7 @@
 		Vehicle *v = GetVehicle(w->window_number);
 		uint i;
 
-		for(i = 0; i < lengthof(_order_keycodes); i++) {
+		for (i = 0; i < lengthof(_order_keycodes); i++) {
 			if (e->keypress.keycode == _order_keycodes[i]) {
 				e->keypress.cont = false;
 				//see if the button is disabled
Index: tree_cmd.c
===================================================================
--- tree_cmd.c	(revision 3486)
+++ tree_cmd.c	(working copy)
@@ -315,7 +315,7 @@
 		} while (i);
 
 		/* draw them in a sorted way */
-		for(;;) {
+		for (;;) {
 			byte min = 0xFF;
 			TreeListEnt *tep = NULL;
 
Index: command.h
===================================================================
--- command.h	(revision 3486)
+++ command.h	(working copy)
@@ -174,7 +174,7 @@
 	byte flags;
 } Command;
 
-//#define return_cmd_error(errcode) do { _error_message=(errcode); return CMD_ERROR; } while(0)
+//#define return_cmd_error(errcode) do { _error_message=(errcode); return CMD_ERROR; } while (0)
 #define return_cmd_error(errcode) do { return CMD_ERROR | (errcode); } while (0)
 
 /**
Index: dock_gui.c
===================================================================
--- dock_gui.c	(revision 3486)
+++ dock_gui.c	(working copy)
@@ -115,7 +115,7 @@
 
 static void BuildDocksToolbWndProc(Window *w, WindowEvent *e)
 {
-	switch(e->event) {
+	switch (e->event) {
 	case WE_PAINT:
 		DrawWindowWidgets(w);
 		break;
Index: queue.c
===================================================================
--- queue.c	(revision 3486)
+++ queue.c	(working copy)
@@ -182,7 +182,7 @@
 		q->data.inssort.first = newnode;
 	} else {
 		InsSortNode* node = q->data.inssort.first;
-		while( node != NULL ) {
+		while ( node != NULL ) {
 			if (node->next == NULL || node->next->priority >= priority) {
 				newnode->next = node->next;
 				node->next = newnode;
