=== src/rail_cmd.cpp
==================================================================
--- src/rail_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/rail_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -314,7 +314,7 @@
 	RailType railtype;
 	Track track;
 	TrackBits trackbit;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (!ValParamRailtype(p1) || !ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
@@ -324,8 +324,6 @@
 	tileh = GetTileSlope(tile, NULL);
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY:
 			if (!CheckTrackCombination(tile, trackbit, flags) ||
@@ -446,14 +444,12 @@
 {
 	Track track = (Track)p2;
 	TrackBits trackbit;
-	CommandCost cost(_price.remove_rail);
+	CommandCost cost(_price.remove_rail, EXPENSES_CONSTRUCTION);
 	bool crossing = false;
 
 	if (!ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_ROAD: {
 			if (!IsLevelCrossing(tile) ||
@@ -632,7 +628,7 @@
  */
 static CommandCost CmdRailTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	Track track = (Track)GB(p2, 4, 3);
 	Trackdir trackdir;
 	byte mode = HASBIT(p2, 7);
@@ -644,8 +640,6 @@
 	end_tile = p1;
 	trackdir = TrackToTrackdir(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (CmdFailed(ValidateAutoDrag(&trackdir, tile, end_tile))) return CMD_ERROR;
 
 	if (flags & DC_EXEC) SndPlayTileFx(SND_20_SPLAT_2, tile);
@@ -714,11 +708,9 @@
  */
 CommandCost CmdBuildTrainDepot(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* check railtype and valid direction for depot (0 through 3), 4 in total */
 	if (!ValParamRailtype(p1)) return CMD_ERROR;
 
@@ -809,15 +801,13 @@
 		}
 	}
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!HasSignalOnTrack(tile, track)) {
 		/* build new signals */
-		cost = CommandCost(_price.build_signals);
+		cost = CommandCost(_price.build_signals, EXPENSES_CONSTRUCTION);
 	} else {
 		if (p2 != 0 && sigvar != GetSignalVariant(tile, track)) {
 			/* convert signals <-> semaphores */
-			cost = CommandCost(_price.build_signals + _price.remove_signals);
+			cost = CommandCost(_price.build_signals + _price.remove_signals, EXPENSES_CONSTRUCTION);
 		} else {
 			/* it is free to change orientation/pre-exit-combo signals */
 			cost = CommandCost();
@@ -937,7 +927,7 @@
  */
 static CommandCost CmdSignalTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	int signal_ctr;
 	byte signals;
 	bool error = true;
@@ -958,8 +948,6 @@
 
 	if (!IsTileType(tile, MP_RAILWAY)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* for vertical/horizontal tracks, double the given signals density
 	 * since the original amount will be too dense (shorter tracks) */
 	signal_density *= 2;
@@ -1082,8 +1070,6 @@
 	/* Only water can remove signals from anyone */
 	if (_current_player != OWNER_WATER && !CheckTileOwnership(tile)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do it? */
 	if (flags & DC_EXEC) {
 		SetPresentSignals(tile, GetPresentSignals(tile) & ~SignalOnTrack(track));
@@ -1101,7 +1087,7 @@
 		MarkTileDirtyByTile(tile);
 	}
 
-	return CommandCost(_price.remove_signals);
+	return CommandCost(_price.remove_signals, EXPENSES_CONSTRUCTION);
 }
 
 /** Remove signals on a stretch of track.
@@ -1186,14 +1172,12 @@
  */
 CommandCost CmdConvertRail(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, cost;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
 	Money money;
 	int ex;
 	int ey;
 	int sx, sy, x, y;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!ValParamRailtype(p2)) return CMD_ERROR;
 	if (p1 >= MapSize()) return CMD_ERROR;
 
@@ -1276,7 +1260,7 @@
 
 static CommandCost ClearTile_Track(TileIndex tile, byte flags)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (flags & DC_AUTO) {
@@ -2415,7 +2399,7 @@
 		case TRACK_BIT_UPPER: track_corner = CORNER_N; break;
 
 		/* Surface slope must not be changed */
-		default: return (((z_old != z_new) || (tileh_old != tileh_new)) ? CMD_ERROR : _price.terraform);
+		default: return (((z_old != z_new) || (tileh_old != tileh_new)) ? CMD_ERROR : CommandCost(_price.terraform, EXPENSES_CONSTRUCTION));
 	}
 
 	/* The height of the track_corner must not be changed. The rest ensures GetRailFoundation() already. */
@@ -2481,7 +2465,7 @@
 				}
 
 				case RAIL_TILE_DEPOT:
-					if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRailDepotDirection(tile))) return _price.terraform;
+					if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRailDepotDirection(tile))) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 					break;
 
 				default: NOT_REACHED();
=== src/station_cmd.cpp
==================================================================
--- src/station_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/station_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -690,7 +690,7 @@
  */
 CommandCost CheckFlatLandBelow(TileIndex tile, uint w, uint h, uint flags, uint invalid_dirs, StationID *station, bool check_clear = true)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int allowed_z = -1;
 
 	BEGIN_TILE_LOOP(tile_cur, w, h, tile) {
@@ -878,8 +878,6 @@
 	int w_org, h_org;
 	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Does the authority allow this? */
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
 	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
@@ -911,7 +909,7 @@
 	 * https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365 */
 	ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags & ~DC_EXEC, 5 << axis, _patches.nonuniform_stations ? &est : NULL);
 	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len);
+	CommandCost cost(ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len, EXPENSES_CONSTRUCTION);
 
 	Station *st = NULL;
 	bool check_surrounding = true;
@@ -1148,8 +1146,6 @@
 	int size_x = ex - sx + 1;
 	int size_y = ey - sy + 1;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do the action for every tile into the area */
 	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
 		/* Make sure the specified tile belongs to the current player, and that it is a railroad station. */
@@ -1195,7 +1191,7 @@
 	/* If we've not removed any tiles, give an error */
 	if (quantity == 0) return CMD_ERROR;
 
-	return CommandCost(_price.remove_rail_station * quantity);
+	return CommandCost(_price.remove_rail_station * quantity, EXPENSES_CONSTRUCTION);
 }
 
 
@@ -1216,7 +1212,7 @@
 
 	assert(w != 0 && h != 0);
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	/* clear all areas of the station */
 	do {
 		int w_bak = w;
@@ -1277,7 +1273,7 @@
 		VehicleFromPos(tile, &tile, UpdateTrainPowerProc);
 	}
 
-	return CommandCost(RailBuildCost(totype) / 2);
+	return CommandCost(RailBuildCost(totype) / 2, EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -1329,8 +1325,6 @@
 	/* Road bits in the wrong direction */
 	if (build_over_road && (GetAllRoadBits(tile) & ((Axis)p1 == AXIS_X ? ROAD_Y : ROAD_X)) != 0) return_cmd_error(STR_DRIVE_THROUGH_ERROR_DIRECTION);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile)) return CMD_ERROR;
 
 	CommandCost cost;
@@ -1487,7 +1481,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost((is_truck) ? _price.remove_truck_station : _price.remove_bus_station);
+	return CommandCost((is_truck) ? _price.remove_truck_station : _price.remove_bus_station, EXPENSES_CONSTRUCTION);
 }
 
 /** Remove a bus or truck stop
@@ -1626,8 +1620,6 @@
 {
 	bool airport_upgrade = true;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Check if a valid, buildable airport was chosen for construction */
 	if (p1 > lengthof(_airport_sections) || !HASBIT(GetValidAirports(), p1)) return CMD_ERROR;
 
@@ -1654,9 +1646,8 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost ret = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
-	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost());
+	CommandCost cost = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
+	if (CmdFailed(cost)) return cost;
 
 	Station *st = NULL;
 
@@ -1760,7 +1751,7 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost cost(w * h * _price.remove_airport);
+	CommandCost cost(w * h * _price.remove_airport, EXPENSES_CONSTRUCTION);
 
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
@@ -1805,8 +1796,6 @@
  */
 CommandCost CmdBuildBuoy(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!IsWaterTile(tile) || tile == 0) return_cmd_error(STR_304B_SITE_UNSUITABLE);
 	if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) return_cmd_error(STR_5007_MUST_DEMOLISH_BRIDGE_FIRST);
 
@@ -1842,7 +1831,7 @@
 		st_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_dock);
+	return CommandCost(_price.build_dock, EXPENSES_CONSTRUCTION);
 }
 
 /* Checks if any ship is servicing the buoy specified. Returns yes or no */
@@ -1894,7 +1883,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_truck_station);
+	return CommandCost(_price.remove_truck_station, EXPENSES_CONSTRUCTION);
 }
 
 static const TileIndexDiffC _dock_tileoffs_chkaround[] = {
@@ -1916,8 +1905,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection direction;
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: direction = DIAGDIR_NE; break;
@@ -2008,7 +1995,7 @@
 		/* success, so don't delete the new station */
 		st_auto_delete.Detach();
 	}
-	return CommandCost(_price.build_dock);
+	return CommandCost(_price.build_dock, EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveDock(Station *st, uint32 flags)
@@ -2037,7 +2024,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_dock);
+	return CommandCost(_price.remove_dock, EXPENSES_CONSTRUCTION);
 }
 
 #include "table/station_land.h"
@@ -2929,11 +2916,11 @@
 					DiagDirection direction = AxisToDiagDir(GetRailStationAxis(tile));
 					if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, direction)) break;
 					if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, ReverseDiagDir(direction))) break;
-					return _price.terraform;
+					return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 				}
 
 				case STATION_AIRPORT:
-					return _price.terraform;
+					return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 
 				case STATION_TRUCK:
 				case STATION_BUS: {
@@ -2942,7 +2929,7 @@
 					if (IsDriveThroughStopTile(tile)) {
 						if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, ReverseDiagDir(direction))) break;
 					}
-					return _price.terraform;
+					return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 				}
 
 				default: break;
=== src/town_cmd.cpp
==================================================================
--- src/town_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/town_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -493,7 +493,7 @@
 static CommandCost ClearTile_Town(TileIndex tile, byte flags)
 {
 	int rating;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Town *t;
 	HouseSpec *hs = GetHouseSpecs(GetHouseType(tile));
 
@@ -1482,8 +1482,6 @@
 	if (_game_mode != GM_EDITOR) return CMD_ERROR;
 	if (p2 > TSM_CITY) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* Check if too close to the edge of map */
 	if (DistanceFromEdge(tile) < 12)
 		return_cmd_error(STR_0237_TOO_CLOSE_TO_EDGE_OF_MAP);
@@ -2083,7 +2081,6 @@
  */
 CommandCost CmdDoTownAction(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
 	Town *t;
 
 	if (!IsValidTownID(p1) || p2 > lengthof(_town_action_proc)) return CMD_ERROR;
@@ -2092,10 +2089,8 @@
 
 	if (!HASBIT(GetMaskOfTownActions(NULL, _current_player, t), p2)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+	CommandCost cost((_price.build_industry >> 8) * _town_action_costs[p2], EXPENSES_OTHER);
 
-	cost.AddCost((_price.build_industry >> 8) * _town_action_costs[p2]);
-
 	if (flags & DC_EXEC) {
 		_town_action_proc[p2](t);
 		InvalidateWindow(WC_TOWN_AUTHORITY, p1);
@@ -2350,7 +2345,7 @@
 
 		/* Here we differ from TTDP by checking TILE_NOT_SLOPED */
 		if (((hs->building_flags & TILE_NOT_SLOPED) == 0) && !IsSteepSlope(tileh_new) &&
-			(GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new))) return _price.terraform;
+			(GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new))) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 	}
 
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
=== src/ship_cmd.cpp
==================================================================
--- src/ship_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/ship_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -166,7 +166,7 @@
 
 void OnNewDay_Ship(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 
 	if ((++v->day_counter & 7) == 0)
 		DecreaseVehicleValue(v);
@@ -182,8 +182,7 @@
 	cost.AddCost(GetVehicleProperty(v, 0x0F, ShipVehInfo(v->engine_type)->running_cost) * _price.ship_running / 364);
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	/* we need this for the profit */
@@ -397,7 +396,7 @@
 
 static CommandCost EstimateShipCost(EngineID engine_type)
 {
-	return CommandCost(GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5, EXPENSES_NEW_VEHICLES);
 }
 
 static void ShipArrivesAt(const Vehicle* v, Station* st)
@@ -812,8 +811,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_SHIP, _current_player)) return_cmd_error(STR_SHIP_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	value = EstimateShipCost(p1);
 	if (flags & DC_QUERY_COST) return value;
 
@@ -913,13 +910,11 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!v->IsStoppedInDepot()) {
 		return_cmd_error(STR_980B_SHIP_MUST_BE_STOPPED_IN);
 	}
 
-	CommandCost ret(-v->value);
+	CommandCost ret(-v->value, EXPENSES_NEW_VEHICLES);
 
 	if (flags & DC_EXEC) {
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
@@ -1062,7 +1057,7 @@
 CommandCost CmdRefitShip(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 	CargoID new_cid = GB(p2, 0, 8); //gets the cargo number
 	byte new_subtype = GB(p2, 8, 8);
 	uint16 capacity = CALLBACK_FAILED;
@@ -1081,8 +1076,6 @@
 	if (!ShipVehInfo(v->engine_type)->refittable) return CMD_ERROR;
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-
 	/* Check the refit capacity callback */
 	if (HASBIT(EngInfo(v->engine_type)->callbackmask, CBM_VEHICLE_REFIT_CAPACITY)) {
 		/* Back up the existing cargo type */
=== src/waypoint.cpp
==================================================================
--- src/waypoint.cpp	(/openttd/trunk)	(revision 388)
+++ src/waypoint.cpp	(/openttd/commandcost)	(revision 388)
@@ -161,8 +161,6 @@
 	Slope tileh;
 	Axis axis;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* if custom gfx are used, make sure it is within bounds */
 	if (p1 >= GetNumCustomStations(STAT_CLASS_WAYP)) return CMD_ERROR;
 
@@ -245,7 +243,7 @@
 		wp_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_train_depot);
+	return CommandCost(_price.build_train_depot, EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -297,7 +295,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 	}
 
-	return CommandCost(_price.remove_train_depot);
+	return CommandCost(_price.remove_train_depot, EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -310,7 +308,6 @@
  */
 CommandCost CmdRemoveTrainWaypoint(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 	return RemoveTrainWaypoint(tile, flags, true);
 }
 
=== src/train_cmd.cpp
==================================================================
--- src/train_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/train_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -513,10 +513,8 @@
 
 static CommandCost CmdBuildRailWagon(EngineID engine, TileIndex tile, uint32 flags)
 {
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(engine);
-	CommandCost value((GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8);
+	CommandCost value((GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8, EXPENSES_NEW_VEHICLES);
 
 	uint num_vehicles = 1 + CountArticulatedParts(engine, false);
 
@@ -602,7 +600,7 @@
 		}
 	}
 
-	return CommandCost(value);
+	return value;
 }
 
 /** Move all free vehicles in the depot to the train */
@@ -623,7 +621,7 @@
 
 static CommandCost EstimateTrainCost(EngineID engine, const RailVehicleInfo* rvi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5, EXPENSES_NEW_VEHICLES);
 }
 
 static void AddRearEngineToMultiheadedTrain(Vehicle* v, Vehicle* u, bool building)
@@ -673,8 +671,6 @@
 		if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
 	}
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(p1);
 
 	/* Check if depot and new engine uses the same kind of tracks */
@@ -1229,8 +1225,6 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	while (IsArticulatedPart(v)) v = v->Previous();
 	Vehicle *first = v->First();
 
@@ -1250,7 +1244,7 @@
 		RebuildVehicleLists();
 	}
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
 	switch (p2) {
 		case 0: case 2: { /* Delete given wagon */
 			bool switch_engine = false;    // update second wagon to engine?
@@ -1715,9 +1709,7 @@
 	/* Check cargo */
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
-
-	CommandCost cost;
+	CommandCost cost(EXPENSES_TRAIN_RUN);
 	uint num = 0;
 
 	do {
@@ -3421,11 +3413,11 @@
 
 		if ((v->vehstatus & VS_STOPPED) == 0) {
 			/* running costs */
-			CommandCost cost(v->GetRunningCost() / 364);
+			CommandCost cost(v->GetRunningCost() / 364, EXPENSES_TRAIN_RUN);
 
+
 			v->profit_this_year -= cost.GetCost() >> 8;
 
-			SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
 			SubtractMoneyFromPlayerFract(v->owner, cost);
 
 			InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
=== src/road_cmd.cpp
==================================================================
--- src/road_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/road_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -111,8 +111,6 @@
 	 * false if it was a center piece. Affects town ratings drop */
 	bool edge_road;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	RoadType rt = (RoadType)GB(p1, 4, 2);
 	if (!IsValidRoadType(rt)) return CMD_ERROR;
 
@@ -152,7 +150,7 @@
 		/* If it's the last roadtype, just clear the whole tile */
 		if (rts == RoadTypeToRoadTypes(rt)) return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 
-		CommandCost cost;
+		CommandCost cost(EXPENSES_CONSTRUCTION);
 		if (IsTileType(tile, MP_TUNNELBRIDGE)) {
 			TileIndex other_end = IsTunnel(tile) ? GetOtherTunnelEnd(tile) : GetOtherBridgeEnd(tile);
 			/* Pay for *every* tile of the bridge or tunnel */
@@ -177,7 +175,7 @@
 				MarkTileDirtyByTile(tile);
 			}
 		}
-		return CommandCost(cost);
+		return cost;
 	}
 
 	switch (GetRoadTileType(tile)) {
@@ -220,7 +218,7 @@
 					MarkTileDirtyByTile(tile);
 				}
 			}
-			return CommandCost(COUNTBITS(c) * _price.remove_road);
+			return CommandCost(COUNTBITS(c) * _price.remove_road, EXPENSES_CONSTRUCTION);
 		}
 
 		case ROAD_TILE_CROSSING: {
@@ -246,7 +244,7 @@
 				MarkTileDirtyByTile(tile);
 				YapfNotifyTrackLayoutChange(tile, FindFirstTrack(GetTrackBits(tile)));
 			}
-			return CommandCost(_price.remove_road * 2);
+			return CommandCost(_price.remove_road * 2, EXPENSES_CONSTRUCTION);
 		}
 
 		default:
@@ -342,7 +340,7 @@
 		*pieces |= MirrorRoadBits(*pieces);
 
 		if (existing == ROAD_NONE || existing == *pieces) {
-			if (*pieces == ROAD_X || *pieces == ROAD_Y) return _price.terraform;
+			if (*pieces == ROAD_X || *pieces == ROAD_Y) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 		}
 		return CMD_ERROR;
 	}
@@ -374,7 +372,7 @@
 
 	/* partly leveled up tile, only if there's no road on that tile */
 	if ((existing == ROAD_NONE || existing == *pieces) && (tileh == SLOPE_W || tileh == SLOPE_S || tileh == SLOPE_E || tileh == SLOPE_N)) {
-		if (*pieces == ROAD_X || *pieces == ROAD_Y) return _price.terraform;
+		if (*pieces == ROAD_X || *pieces == ROAD_Y) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 	}
 	return CMD_ERROR;
 }
@@ -389,14 +387,12 @@
  */
 CommandCost CmdBuildRoad(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 	RoadBits existing = ROAD_NONE;
 	RoadBits all_bits = ROAD_NONE;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Road pieces are max 4 bitset values (NE, NW, SE, SW) and town can only be non-zero
 	 * if a non-player is building the road */
 	if ((IsValidPlayer(_current_player) && p2 != 0) || (_current_player == OWNER_TOWN && !IsValidTownID(p2))) return CMD_ERROR;
@@ -623,14 +619,12 @@
 CommandCost CmdBuildLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret;
+	CommandCost ret,cost(EXPENSES_CONSTRUCTION);
 	bool had_bridge = false;
 	bool had_tunnel = false;
 	bool had_success = false;
 	DisallowedRoadDirections drd = DRD_NORTHBOUND;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -710,10 +704,9 @@
 CommandCost CmdRemoveLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret, money;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
+	Money money;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -732,7 +725,7 @@
 		p2 ^= IS_INT_INSIDE(p2 & 3, 1, 3) ? 3 : 0;
 	}
 
-	money.AddCost(GetAvailableMoneyForCommand());
+	money = GetAvailableMoneyForCommand();
 	tile = start_tile;
 	/* Start tile is the small number. */
 	for (;;) {
@@ -746,8 +739,8 @@
 			ret = DoCommand(tile, rt << 4 | bits, 0, flags & ~DC_EXEC, CMD_REMOVE_ROAD);
 			if (CmdSucceeded(ret)) {
 				if (flags & DC_EXEC) {
-					money.AddCost(-ret.GetCost());
-					if (money.GetCost() < 0) {
+					money -= ret.GetCost();
+					if (money < 0) {
 						_additional_cash_required = DoCommand(end_tile, start_tile, p2, flags & ~DC_EXEC, CMD_REMOVE_LONG_ROAD).GetCost();
 						return cost;
 					}
@@ -780,8 +773,6 @@
 	CommandCost cost;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection dir = Extract<DiagDirection, 0>(p1);
 	RoadType rt = (RoadType)GB(p1, 2, 2);
 
@@ -843,7 +834,7 @@
 			    !(flags & DC_AUTO)
 				) {
 				RoadTypes rts = GetRoadTypes(tile);
-				CommandCost ret;
+				CommandCost ret(EXPENSES_CONSTRUCTION);
 				for (RoadType rt = ROADTYPE_ROAD; rt < ROADTYPE_END; rt++) {
 					if (HASBIT(rts, rt)) {
 						CommandCost tmp_ret = DoCommand(tile, rt << 4 | GetRoadBits(tile, rt), 0, flags, CMD_REMOVE_ROAD);
@@ -858,7 +849,7 @@
 
 		case ROAD_TILE_CROSSING: {
 			RoadTypes rts = GetRoadTypes(tile);
-			CommandCost ret;
+			CommandCost ret(EXPENSES_CONSTRUCTION);
 
 			if (flags & DC_AUTO) return_cmd_error(STR_1801_MUST_REMOVE_ROAD_FIRST);
 
@@ -1439,11 +1430,11 @@
 	if (_patches.build_on_slopes && AutoslopeEnabled()) {
 		switch (GetRoadTileType(tile)) {
 			case ROAD_TILE_CROSSING:
-				if (!IsSteepSlope(tileh_new) && (GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new)) && HASBIT(VALID_LEVEL_CROSSING_SLOPES, tileh_new)) return _price.terraform;
+				if (!IsSteepSlope(tileh_new) && (GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new)) && HASBIT(VALID_LEVEL_CROSSING_SLOPES, tileh_new)) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 				break;
 
 			case ROAD_TILE_DEPOT:
-				if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRoadDepotDirection(tile))) return _price.terraform;
+				if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRoadDepotDirection(tile))) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 				break;
 
 			case ROAD_TILE_NORMAL: {
@@ -1461,7 +1452,7 @@
 						z_new += ApplyFoundationToSlope(GetRoadFoundation(tileh_new, bits), &tileh_new);
 
 						/* The surface slope must not be changed */
-						if ((z_old == z_new) && (tileh_old == tileh_new)) return _price.terraform;
+						if ((z_old == z_new) && (tileh_old == tileh_new)) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 					}
 				}
 				break;
=== src/command.cpp
==================================================================
--- src/command.cpp	(/openttd/trunk)	(revision 388)
+++ src/command.cpp	(/openttd/commandcost)	(revision 388)
@@ -440,7 +440,7 @@
 	}
 
 	/* Execute the command here. All cost-relevant functions set the expenses type
-	 * themselves with "SET_EXPENSES_TYPE(...);" at the beginning of the function */
+	 * themselves to the cost object at some point */
 	res = proc(tile, flags, p1, p2);
 	if (CmdFailed(res)) {
 		res.SetGlobalErrorMessage();
@@ -453,6 +453,7 @@
 	/* if toplevel, subtract the money. */
 	if (--_docommand_recursive == 0) {
 		SubtractMoneyFromPlayer(res);
+	
 		/* XXX - Old AI hack which doesn't use DoCommandDP; update last build coord of player */
 		if (tile != 0 && IsValidPlayer(_current_player)) {
 			GetPlayer(_current_player)->last_build_coordinate = tile;
@@ -617,7 +618,6 @@
 
 	/* Actually try and execute the command. If no cost-type is given
 	 * use the construction one */
-	_yearly_expenses_type = EXPENSES_CONSTRUCTION;
 	res2 = proc(tile, flags | DC_EXEC, p1, p2);
 
 	/* If notest is on, it means the result of the test can be different than
@@ -630,9 +630,8 @@
 			goto show_error;
 		}
 	}
-
 	SubtractMoneyFromPlayer(res2);
-
+	
 	if (IsLocalPlayer() && _game_mode != GM_EDITOR) {
 		if (res2.GetCost() != 0 && tile != 0) ShowCostOrIncomeAnimation(x, y, GetSlopeZ(x, y), res2.GetCost());
 		if (_additional_cash_required != 0) {
@@ -681,7 +680,7 @@
 	return *this;
 }
 
-CommandCost CommandCost::MultiplyCost(int factor)
+CommandCost CommandCost::MultiplyCost(int64 factor)
 {
 	this->cost *= factor;
 	return *this;
@@ -692,6 +691,11 @@
 	return this->cost;
 }
 
+ExpensesType CommandCost::GetExpensesType() const 
+{
+	return this->expense_type;	
+}
+
 void CommandCost::SetGlobalErrorMessage() const
 {
 	extern StringID _error_message;
=== src/tree_cmd.cpp
==================================================================
--- src/tree_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/tree_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -271,7 +271,7 @@
 CommandCost CmdPlantTree(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	StringID msg = INVALID_STRING_ID;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 	int ex;
 	int ey;
 	int sx, sy, x, y;
@@ -280,8 +280,6 @@
 	/* Check the tree type. It can be random or some valid value within the current climate */
 	if (p1 != (uint)-1 && p1 - _tree_base_by_landscape[_opt.landscape] >= _tree_count_by_landscape[_opt.landscape]) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	// make sure sx,sy are smaller than ex,ey
 	ex = TileX(tile);
 	ey = TileY(tile);
@@ -497,7 +495,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(num * _price.remove_trees);
+	return CommandCost(num * _price.remove_trees, EXPENSES_CONSTRUCTION);
 }
 
 static void GetAcceptedCargo_Trees(TileIndex tile, AcceptedCargo ac)
=== src/tunnelbridge_cmd.cpp
==================================================================
--- src/tunnelbridge_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/tunnelbridge_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -196,13 +196,12 @@
 	TileIndexDiff delta;
 	uint bridge_len;
 	Axis direction;
-	CommandCost cost, terraformcost, ret;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+	CommandCost terraformcost, ret;
 	bool allow_on_slopes;
 	bool replace_bridge = false;
 	uint replaced_bridge_type;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* unpack parameters */
 	bridge_type = GB(p2, 0, 8);
 
@@ -458,7 +457,7 @@
 	Slope end_tileh;
 	uint start_z;
 	uint end_z;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	_build_tunnel_endtile = 0;
@@ -606,8 +605,6 @@
 	TileIndex endtile;
 	uint length;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = CheckTunnelBusy(tile, &length);
@@ -644,7 +641,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
-	return CommandCost(_price.clear_tunnel * (length + 1));
+	return CommandCost(_price.clear_tunnel * (length + 1), EXPENSES_CONSTRUCTION);
 }
 
 
@@ -667,8 +664,6 @@
 	TileIndex endtile;
 	Town *t = NULL;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = GetOtherBridgeEnd(tile);
@@ -717,7 +712,7 @@
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
 
-	return CommandCost((DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge);
+	return CommandCost((DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge, EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost ClearTile_TunnelBridge(TileIndex tile, byte flags)
@@ -1532,7 +1527,7 @@
 			z_new += ApplyFoundationToSlope(GetBridgeFoundation(tileh_new, axis), &tileh_new);
 
 			/* Surface slope remains unchanged? */
-			if ((z_old == z_new) && (tileh_old == tileh_new)) return _price.terraform;
+			if ((z_old == z_new) && (tileh_old == tileh_new)) return CommandCost(_price.terraform,EXPENSES_CONSTRUCTION);
 		}
 	}
 
=== src/ai/default/default.cpp
==================================================================
--- src/ai/default/default.cpp	(/openttd/trunk)	(revision 388)
+++ src/ai/default/default.cpp	(/openttd/commandcost)	(revision 388)
@@ -1615,7 +1615,7 @@
 static CommandCost AiDoBuildDefaultRailTrack(TileIndex tile, const AiDefaultBlockData* p, RailType railtype, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int i, j, k;
@@ -2602,7 +2602,7 @@
 static CommandCost AiDoBuildDefaultRoadBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int roadflag = 0;
@@ -3363,7 +3363,7 @@
 static CommandCost AiDoBuildDefaultAirportBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	uint32 avail_airports = GetValidAirports();
-	CommandCost total_cost, ret;
+	CommandCost ret,total_cost(EXPENSES_CONSTRUCTION);
 
 	for (; p->mode == 0; p++) {
 		if (!HASBIT(avail_airports, p->attr)) return CMD_ERROR;
=== src/clear_cmd.cpp
==================================================================
--- src/clear_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/clear_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -236,11 +236,9 @@
 CommandCost CmdTerraformLand(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TerraformerState ts;
-	CommandCost total_cost = CommandCost();
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	int direction = (p2 != 0 ? 1 : -1);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	_terraform_err_tile = 0;
 
 	ts.modheight_count = ts.tile_table_count = 0;
@@ -364,14 +362,12 @@
 	int ey;
 	int sx, sy;
 	uint h, curh;
-	CommandCost money;
+	Money money;
 	CommandCost ret;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* remember level height */
 	h = TileHeight(p1);
 
@@ -387,7 +383,7 @@
 	size_x = ex - sx + 1;
 	size_y = ey - sy + 1;
 
-	money.AddCost(GetAvailableMoneyForCommand());
+	money = GetAvailableMoneyForCommand();
 
 	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
 		curh = TileHeight(tile2);
@@ -396,8 +392,8 @@
 			if (CmdFailed(ret)) break;
 
 			if (flags & DC_EXEC) {
-				money.AddCost(-ret.GetCost());
-				if (money.GetCost() < 0) {
+				money -= ret.GetCost();
+				if (money < 0) {
 					_additional_cash_required = ret.GetCost();
 					return cost;
 				}
@@ -424,8 +420,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (IsOwnedLandTile(tile) && IsTileOwner(tile, _current_player)) {
 		return_cmd_error(STR_5807_YOU_ALREADY_OWN_IT);
 	}
@@ -453,15 +447,15 @@
 		&_price.purchase_land,
 		&_price.clear_2, // XXX unused?
 	};
-	CommandCost price;
+	Money price = 0;
 
 	if (!IsClearGround(tile, CLEAR_GRASS) || GetClearDensity(tile) != 0) {
-		price.AddCost(*clear_price_table[GetClearGround(tile)]);
+		price = *clear_price_table[GetClearGround(tile)];
 	}
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return price;
+	return CommandCost(price,EXPENSES_CONSTRUCTION);
 }
 
 /** Sell a land area. Actually you only sell one tile, so
@@ -474,7 +468,6 @@
  */
 CommandCost CmdSellLandArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
 	if (!IsOwnedLandTile(tile)) return CMD_ERROR;
 	if (!CheckTileOwnership(tile) && _current_player != OWNER_WATER) return CMD_ERROR;
@@ -484,7 +477,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(- _price.purchase_land * 2);
+	return CommandCost(- _price.purchase_land * 2, EXPENSES_CONSTRUCTION);
 }
 
 
=== src/strings.cpp
==================================================================
--- src/strings.cpp	(/openttd/trunk)	(revision 388)
+++ src/strings.cpp	(/openttd/commandcost)	(revision 388)
@@ -340,6 +340,9 @@
 	int j;
 
 	number *= spec->rate;
+	
+	
+	
 
 	/* convert from negative */
 	if (number < 0) {
=== src/unmovable_cmd.cpp
==================================================================
--- src/unmovable_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/unmovable_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -37,8 +37,6 @@
 {
 	Player* p = GetPlayer(pid);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	if (flags & DC_EXEC) {
 		TileIndex t = p->location_of_house;
 
@@ -51,7 +49,7 @@
 	}
 
 	/* cost of relocating company is 1% of company value */
-	return CommandCost(CalculateCompanyValue(p) / 100);
+	return CommandCost(CalculateCompanyValue(p) / 100, EXPENSES_PROPERTY);
 }
 
 void UpdateCompanyHQ(Player *p, uint score)
@@ -86,10 +84,8 @@
 CommandCost CmdBuildCompanyHQ(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p = GetPlayer(_current_player);
-	CommandCost cost;
+	CommandCost cost(EXPENSES_PROPERTY);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	cost = CheckFlatLandBelow(tile, 2, 2, flags, 0, NULL);
 	if (CmdFailed(cost)) return cost;
 
@@ -410,7 +406,7 @@
 	if (IsOwnedLand(tile) && CheckTileOwnership(tile)) return CommandCost();
 
 	if (AutoslopeEnabled() && (IsStatue(tile) || IsCompanyHQ(tile))) {
-		if (!IsSteepSlope(tileh_new) && (z_new + GetSlopeMaxZ(tileh_new) == GetTileMaxZ(tile))) return _price.terraform;
+		if (!IsSteepSlope(tileh_new) && (z_new + GetSlopeMaxZ(tileh_new) == GetTileMaxZ(tile))) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 	}
 
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
=== src/water_cmd.cpp
==================================================================
--- src/water_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/water_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -64,10 +64,8 @@
 {
 	TileIndex tile2;
 
-	CommandCost cost, ret;
+	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	Axis axis = Extract<Axis, 0>(p1);
 
 	tile2 = tile + (axis == AXIS_X ? TileDiffXY(1, 0) : TileDiffXY(0, 1));
@@ -96,7 +94,7 @@
 		d_auto_delete.Detach();
 	}
 
-	return cost.AddCost(_price.build_ship_depot);
+	return CommandCost(_price.build_ship_depot, EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveShipDepot(TileIndex tile, uint32 flags)
@@ -121,7 +119,7 @@
 		MarkTileDirtyByTile(tile2);
 	}
 
-	return CommandCost(_price.remove_ship_depot);
+	return CommandCost(_price.remove_ship_depot, EXPENSES_CONSTRUCTION);
 }
 
 /** build a shiplift */
@@ -162,7 +160,7 @@
 		MarkTileDirtyByTile(tile + delta);
 	}
 
-	return CommandCost(_price.clear_water * 22 >> 3);
+	return CommandCost(_price.clear_water * 22 >> 3, EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveShiplift(TileIndex tile, uint32 flags)
@@ -211,8 +209,6 @@
 {
 	DiagDirection dir;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: dir = DIAGDIR_SW; break;
 		case SLOPE_SE: dir = DIAGDIR_SE; break;
@@ -231,7 +227,7 @@
  */
 CommandCost CmdBuildCanal(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int size_x, size_y;
 	int x;
 	int y;
@@ -246,8 +242,6 @@
 	sx = TileX(p1);
 	sy = TileY(p1);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (x < sx) Swap(x, sx);
 	if (y < sy) Swap(y, sy);
 	size_x = (x - sx) + 1;
@@ -308,7 +302,7 @@
 			if (GetTileOwner(tile) != OWNER_WATER && GetTileOwner(tile) != OWNER_NONE && !CheckTileOwnership(tile)) return CMD_ERROR;
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
-			return CommandCost(_price.clear_water);
+			return CommandCost(_price.clear_water, EXPENSES_CONSTRUCTION);
 
 		case WATER_TILE_COAST: {
 			Slope slope = GetTileSlope(tile, NULL);
@@ -318,9 +312,9 @@
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
 			if (slope == SLOPE_N || slope == SLOPE_E || slope == SLOPE_S || slope == SLOPE_W) {
-				return CommandCost(_price.clear_water);
+				return CommandCost(_price.clear_water, EXPENSES_CONSTRUCTION);
 			} else {
-				return CommandCost(_price.purchase_land);
+				return CommandCost(_price.purchase_land, EXPENSES_CONSTRUCTION);
 			}
 		}
 
=== src/economy.cpp
==================================================================
--- src/economy.cpp	(/openttd/trunk)	(revision 388)
+++ src/economy.cpp	(/openttd/commandcost)	(revision 388)
@@ -603,8 +603,8 @@
 
 	FOR_ALL_STATIONS(st) {
 		_current_player = st->owner;
-		SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-		SubtractMoneyFromPlayer(_price.station_value >> 1);
+		CommandCost cost(_price.station_value >> 1, EXPENSES_PROPERTY);
+		SubtractMoneyFromPlayer(cost);
 	}
 
 	if (!HASBIT(1<<0|1<<3|1<<6|1<<9, _cur_month))
@@ -704,12 +704,11 @@
 		if (!p->is_active) continue;
 
 		_current_player = p->index;
-		SET_EXPENSES_TYPE(EXPENSES_LOAN_INT);
+		
 
-		SubtractMoneyFromPlayer(CommandCost((Money)BIGMULUS(p->current_loan, interest, 16)));
+		SubtractMoneyFromPlayer(CommandCost((Money)BIGMULUS(p->current_loan, interest, 16), EXPENSES_LOAN_INT));
 
-		SET_EXPENSES_TYPE(EXPENSES_OTHER);
-		SubtractMoneyFromPlayer(_price.station_value >> 2);
+		SubtractMoneyFromPlayer(CommandCost(_price.station_value >> 2, EXPENSES_OTHER));
 	}
 }
 
@@ -1456,7 +1455,7 @@
 
 	if (route_profit != 0) {
 		front_v->profit_this_year += vehicle_profit;
-		SubtractMoneyFromPlayer(-route_profit);
+		SubtractMoneyFromPlayer( CommandCost( -route_profit, front_v->GetExpenseType(true) ) );
 
 		if (IsLocalPlayer() && !PlayVehicleSound(front_v, VSE_LOAD_UNLOAD)) {
 			SndPlayVehicleFx(SND_14_CASHTILL, front_v);
@@ -1765,9 +1764,9 @@
 	PlayerID old_player = _current_player;
 	for (i = 0; i != 4; i++) {
 		if (p->share_owners[i] != PLAYER_SPECTATOR) {
-			SET_EXPENSES_TYPE(EXPENSES_OTHER);
+			
 			_current_player = p->share_owners[i];
-			SubtractMoneyFromPlayer(CommandCost(-value));
+			SubtractMoneyFromPlayer(CommandCost( -value, EXPENSES_OTHER ) );
 		}
 	}
 	_current_player = old_player;
@@ -1789,7 +1788,7 @@
 CommandCost CmdBuyShareInCompany(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 
 	/* Check if buying shares is allowed (protection against modified clients) */
 	/* Cannot buy own shares */
@@ -1800,8 +1799,6 @@
 	/* Cannot buy shares of non-existent nor bankrupted company */
 	if (!p->is_active) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* Protect new companies from hostile takeovers */
 	if (_cur_year - p->inaugurated_year < 6) return_cmd_error(STR_7080_PROTECTED);
 
@@ -1851,7 +1848,6 @@
 	/* Cannot sell shares of non-existent nor bankrupted company */
 	if (!p->is_active) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 
 	/* Those lines are here for network-protection (clients can be slow) */
 	if (GetAmountOwnedBy(p, _current_player) == 0) return CommandCost();
@@ -1866,7 +1862,7 @@
 		*b = PLAYER_SPECTATOR;
 		InvalidateWindow(WC_COMPANY, p1);
 	}
-	return CommandCost(cost);
+	return CommandCost(cost, EXPENSES_OTHER);
 }
 
 /** Buy up another company.
@@ -1889,7 +1885,6 @@
 	/* Do not allow players to take over themselves */
 	if (pid == _current_player) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 	p = GetPlayer(pid);
 
 	if (!p->is_ai) return CMD_ERROR;
@@ -1897,7 +1892,7 @@
 	if (flags & DC_EXEC) {
 		DoAcquireCompany(p);
 	}
-	return CommandCost(p->bankrupt_value);
+	return CommandCost(p->bankrupt_value, EXPENSES_OTHER);
 }
 
 /** Prices */
=== src/variables.h
==================================================================
--- src/variables.h	(/openttd/trunk)	(revision 388)
+++ src/variables.h	(/openttd/commandcost)	(revision 388)
@@ -303,7 +303,6 @@
 VARDEF PlayerFace _player_face; ///< for player face storage in openttd.cfg
 
 /* IN/OUT parameters to commands */
-VARDEF byte _yearly_expenses_type;
 VARDEF TileIndex _terraform_err_tile;
 VARDEF TileIndex _build_tunnel_endtile;
 VARDEF bool _generating_world;
@@ -337,8 +336,6 @@
 VARDEF char *_log_file;
 
 
-#define SET_EXPENSES_TYPE(x) _yearly_expenses_type = x;
-
 /* landscape.cpp */
 extern const byte _tileh_to_sprite[32];
 
=== src/players.cpp
==================================================================
--- src/players.cpp	(/openttd/trunk)	(revision 388)
+++ src/players.cpp	(/openttd/commandcost)	(revision 388)
@@ -188,30 +188,32 @@
 
 static void SubtractMoneyFromAnyPlayer(Player *p, CommandCost cost)
 {
-	CommandCost tmp(p->player_money);
-	tmp.AddCost(-cost.GetCost());
-	p->player_money = tmp.GetCost();
+	if(cost.GetCost() == 0) return;
+	assert(cost.GetExpensesType() != EXPENSES_INVALID);
+	
+	if(p->player_money > cost.GetCost())
+	{
+		p->player_money -= cost.GetCost();
+	}
+	else
+	{
+		p->player_money = 0;
+	}
+	p->yearly_expenses[0][cost.GetExpensesType()] += cost.GetCost();
 
-	tmp = CommandCost(p->yearly_expenses[0][_yearly_expenses_type]);
-	tmp.AddCost(cost);
-	p->yearly_expenses[0][_yearly_expenses_type] = tmp.GetCost();
-
 	if (HASBIT(1 << EXPENSES_TRAIN_INC    |
 	           1 << EXPENSES_ROADVEH_INC  |
 	           1 << EXPENSES_AIRCRAFT_INC |
-	           1 << EXPENSES_SHIP_INC, _yearly_expenses_type)) {
-		tmp = CommandCost(p->cur_economy.income);
-		tmp.AddCost(-cost.GetCost());
-		p->cur_economy.income = tmp.GetCost();
+	           1 << EXPENSES_SHIP_INC, cost.GetExpensesType())) {
+		
+		p->cur_economy.income += cost.GetCost();
 	} else if (HASBIT(1 << EXPENSES_TRAIN_RUN    |
 	                  1 << EXPENSES_ROADVEH_RUN  |
 	                  1 << EXPENSES_AIRCRAFT_RUN |
 	                  1 << EXPENSES_SHIP_RUN     |
 	                  1 << EXPENSES_PROPERTY     |
-	                  1 << EXPENSES_LOAN_INT, _yearly_expenses_type)) {
-		tmp = CommandCost(p->cur_economy.expenses);
-		tmp.AddCost(-cost.GetCost());
-		p->cur_economy.expenses = tmp.GetCost();
+	                  1 << EXPENSES_LOAN_INT, cost.GetExpensesType())) {
+		p->cur_economy.expenses += cost.GetCost();
 	}
 
 	InvalidatePlayerWindows(p);
@@ -233,7 +235,7 @@
 	p->player_money_fraction = m - (byte)cost;
 	cost >>= 8;
 	if (p->player_money_fraction > m) cost++;
-	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cost));
+	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cost, cst.GetExpensesType()));
 }
 
 void GetNameOfOwner(Owner owner, TileIndex tile)
=== src/openttd.h
==================================================================
--- src/openttd.h	(/openttd/trunk)	(revision 388)
+++ src/openttd.h	(/openttd/commandcost)	(revision 388)
@@ -366,6 +366,22 @@
 	int32 top;
 	byte width_1, width_2;
 };
+enum ExpensesType {
+	EXPENSES_CONSTRUCTION =  0,
+	EXPENSES_NEW_VEHICLES =  1,
+	EXPENSES_TRAIN_RUN    =  2,
+	EXPENSES_ROADVEH_RUN  =  3,
+	EXPENSES_AIRCRAFT_RUN =  4,
+	EXPENSES_SHIP_RUN     =  5,
+	EXPENSES_PROPERTY     =  6,
+	EXPENSES_TRAIN_INC    =  7,
+	EXPENSES_ROADVEH_INC  =  8,
+	EXPENSES_AIRCRAFT_INC =  9,
+	EXPENSES_SHIP_INC     = 10,
+	EXPENSES_LOAN_INT     = 11,
+	EXPENSES_OTHER        = 12,
+	EXPENSES_INVALID      = 0xFF,
+};
 
 /**
  * Common return value for all commands. Wraps the cost and
@@ -375,25 +391,38 @@
 	Money cost;       ///< The cost of this action
 	StringID message; ///< Warning message for when success is unset
 	bool success;     ///< Whether the comment went fine up to this moment
-
+	ExpensesType expense_type;
 public:
 	/**
 	 * Creates a command cost return with no cost and no error
 	 */
-	CommandCost() : cost(0), message(INVALID_STRING_ID), success(true) {}
+	CommandCost() : cost(0), message(INVALID_STRING_ID), success(true), expense_type(EXPENSES_INVALID) {}
 
 	/**
 	 * Creates a command return value the is failed with the given message
 	 */
-	CommandCost(StringID msg) : cost(0), message(msg), success(false) {}
+	CommandCost(StringID msg) : cost(0), message(msg), success(false), expense_type(EXPENSES_INVALID) {}
 
 	/**
+	 * Creates a command cost return with given expense type
+	 * @param ex_t the expense type
+	 */
+	CommandCost(ExpensesType ex_t) : cost(0), message(INVALID_STRING_ID), success(true), expense_type(ex_t) {}
+	
+	/**
 	 * Creates a command return value with the given start cost
 	 * @param cst the initial cost of this command
 	 */
-	CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true) {}
+	//CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true), expense_type(EXPENSES_INVALID) {}
 
 	/**
+	 * Creates a command return value with the given start cost and expense type
+	 * @param cst the initial cost of this command
+	 * @param ex_t the expense type
+	 */
+	CommandCost(Money cst,ExpensesType ex_t) : cost(cst), message(INVALID_STRING_ID), success(true),expense_type(ex_t) {}
+	
+	/**
 	 * Adds the cost of the given command return value to this cost.
 	 * Also takes a possible error message when it is set.
 	 * @param ret the command to add the cost of.
@@ -413,7 +442,7 @@
 	 * @param cost factor to multiply the costs with
 	 * @return this class
 	 */
-	CommandCost MultiplyCost(int factor);
+	CommandCost MultiplyCost(int64 factor);
 
 	/**
 	 * The costs as made up to this moment
@@ -422,6 +451,12 @@
 	Money GetCost() const;
 
 	/**
+	 * The expense type of the cost
+	 * @return the expense type 
+	 */
+	ExpensesType GetExpensesType() const;
+
+	/**
 	 * Sets the global error message *if* this class has one.
 	 */
 	void SetGlobalErrorMessage() const;
@@ -439,7 +474,6 @@
 	bool Failed() const;
 };
 
-
 typedef void DrawTileProc(TileInfo *ti);
 typedef uint GetSlopeZProc(TileIndex tile, uint x, uint y);
 typedef CommandCost ClearTileProc(TileIndex tile, byte flags);
@@ -594,23 +628,6 @@
 	WC_VEHICLE_TIMETABLE,
 };
 
-
-enum ExpensesType {
-	EXPENSES_CONSTRUCTION =  0,
-	EXPENSES_NEW_VEHICLES =  1,
-	EXPENSES_TRAIN_RUN    =  2,
-	EXPENSES_ROADVEH_RUN  =  3,
-	EXPENSES_AIRCRAFT_RUN =  4,
-	EXPENSES_SHIP_RUN     =  5,
-	EXPENSES_PROPERTY     =  6,
-	EXPENSES_TRAIN_INC    =  7,
-	EXPENSES_ROADVEH_INC  =  8,
-	EXPENSES_AIRCRAFT_INC =  9,
-	EXPENSES_SHIP_INC     = 10,
-	EXPENSES_LOAN_INT     = 11,
-	EXPENSES_OTHER        = 12,
-};
-
 enum {
 	MAX_LANG = 64,
 };
=== src/landscape.cpp
==================================================================
--- src/landscape.cpp	(/openttd/trunk)	(revision 388)
+++ src/landscape.cpp	(/openttd/commandcost)	(revision 388)
@@ -521,9 +521,7 @@
  * @param p2 unused
  */
 CommandCost CmdLandscapeClear(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
-{
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
+{	
 	return _tile_type_procs[GetTileType(tile)]->clear_tile_proc(tile, flags);
 }
 
@@ -535,7 +533,8 @@
  */
 CommandCost CmdClearArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost, ret, money;
+	CommandCost ret, money;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int ex;
 	int ey;
 	int sx, sy;
@@ -544,8 +543,6 @@
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* make sure sx,sy are smaller than ex,ey */
 	ex = TileX(tile);
 	ey = TileY(tile);
=== src/roadveh_cmd.cpp
==================================================================
--- src/roadveh_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/roadveh_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -120,7 +120,7 @@
 
 static CommandCost EstimateRoadVehCost(EngineID engine_type)
 {
-	return CommandCost(((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5);
+	return CommandCost(((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5, EXPENSES_NEW_VEHICLES);
 }
 
 byte GetRoadVehLength(const Vehicle *v)
@@ -167,8 +167,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_ROAD, _current_player)) return_cmd_error(STR_ROAD_VEHICLE_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	cost = EstimateRoadVehCost(p1);
 	if (flags & DC_QUERY_COST) return cost;
 
@@ -361,13 +359,11 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!CheckRoadVehInDepotStopped(v)) {
 		return_cmd_error(STR_9013_MUST_BE_STOPPED_INSIDE);
 	}
 
-	CommandCost ret(-v->value);
+	CommandCost ret(-v->value, EXPENSES_NEW_VEHICLES);
 
 	if (flags & DC_EXEC) {
 		// Invalidate depot
@@ -1896,7 +1892,7 @@
 
 void OnNewDay_RoadVeh(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 
 	if (!IsRoadVehFront(v)) return;
 
@@ -1976,12 +1972,11 @@
 		}
 	}
 
-	cost = RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364;
+	cost = CommandCost(RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364, EXPENSES_ROADVEH_RUN);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	InvalidateWindowClasses(WC_ROADVEH_LIST);
@@ -2014,7 +2009,7 @@
 CommandCost CmdRefitRoadVeh(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 	CargoID new_cid = GB(p2, 0, 8);
 	byte new_subtype = GB(p2, 8, 8);
 	bool only_this = HASBIT(p2, 16);
@@ -2030,8 +2025,6 @@
 
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-
 	for (; v != NULL; v = v->Next()) {
 		/* XXX: We refit all the attached wagons en-masse if they can be
 		 * refitted. This is how TTDPatch does it.  TODO: Have some nice
=== src/vehicle.cpp
==================================================================
--- src/vehicle.cpp	(/openttd/trunk)	(revision 388)
+++ src/vehicle.cpp	(/openttd/commandcost)	(revision 388)
@@ -681,18 +681,28 @@
 CommandCost GetRefitCost(EngineID engine_type)
 {
 	CommandCost base_cost;
-
+	ExpensesType expense_type;
 	switch (GetEngine(engine_type)->type) {
-		case VEH_SHIP: base_cost.AddCost(_price.ship_base); break;
-		case VEH_ROAD: base_cost.AddCost(_price.roadveh_base); break;
-		case VEH_AIRCRAFT: base_cost.AddCost(_price.aircraft_base); break;
+		case VEH_SHIP: 
+			base_cost.AddCost(_price.ship_base); 
+			expense_type = EXPENSES_SHIP_RUN;
+			break;
+		case VEH_ROAD: 
+			base_cost.AddCost(_price.roadveh_base); 
+			expense_type = EXPENSES_ROADVEH_RUN;
+			break;
+		case VEH_AIRCRAFT: 
+			base_cost.AddCost(_price.aircraft_base); 
+			expense_type = EXPENSES_AIRCRAFT_RUN;
+			break;
 		case VEH_TRAIN:
 			base_cost.AddCost(2 * ((RailVehInfo(engine_type)->railveh_type == RAILVEH_WAGON) ?
 							 _price.build_railwagon : _price.build_railvehicle));
+			expense_type = EXPENSES_TRAIN_RUN;
 			break;
 		default: NOT_REACHED(); break;
 	}
-	return CommandCost((EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10);
+	return CommandCost((EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10, expense_type);
 }
 
 static void DoDrawVehicle(const Vehicle *v)
@@ -1671,8 +1681,8 @@
 			 * Because of this, we can't estimate costs due to wagon removal and we will have to always return 0 and pay manually
 			 * Since we pay after each vehicle is replaced and MaybeReplaceVehicle() check if the player got enough money
 			 * we should never reach a condition where the player will end up with negative money from doing this */
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 			SubtractMoneyFromPlayer(ret);
+
 		}
 	}
 
@@ -1700,7 +1710,7 @@
 {
 	Vehicle *v_front, *v;
 	Vehicle *w_front, *w, *w_rear;
-	CommandCost cost, total_cost;
+	CommandCost cost, total_cost(EXPENSES_NEW_VEHICLES);
 	uint32 build_argument = 2;
 
 	if (!IsValidVehicleID(p1)) return CMD_ERROR;
@@ -1846,9 +1856,6 @@
 		return CMD_ERROR;
 	}
 
-	/* Set the expense type last as refitting will make the cost go towards
-	 * running costs... */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	return total_cost;
 }
 
@@ -3071,7 +3078,6 @@
 	current_order.type = OT_LOADING;
 	GetStation(this->last_station_visited)->loading_vehicles.push_back(this);
 
-	SET_EXPENSES_TYPE(this->GetExpenseType(true));
 	VehiclePayment(this);
 
 	InvalidateWindow(this->GetVehicleListWindowClass(), this->owner);
=== src/misc_cmd.cpp
==================================================================
--- src/misc_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/misc_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -155,7 +155,7 @@
 		InvalidatePlayerWindows(p);
 	}
 
-	return CommandCost();
+	return CommandCost(EXPENSES_OTHER);
 }
 
 /** Decrease the loan of your company.
@@ -327,8 +327,7 @@
 #ifndef _DEBUG
 	if (_networking) return CMD_ERROR;
 #endif
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-	return CommandCost(-(Money)p1);
+	return CommandCost(-(Money)p1, EXPENSES_OTHER);
 }
 
 /** Transfer funds (money) from one player to another.
@@ -345,10 +344,8 @@
 	if (!_patches.give_money) return CMD_ERROR;
 
 	const Player *p = GetPlayer(_current_player);
-	CommandCost amount(min((Money)p1, (Money)20000000LL));
+	CommandCost amount(min((Money)p1, (Money)20000000LL), EXPENSES_OTHER);
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* You can only transfer funds that is in excess of your loan */
 	if (p->player_money - p->current_loan < amount.GetCost() || amount.GetCost() <= 0) return CMD_ERROR;
 	if (!_networking || !IsValidPlayer((PlayerID)p2)) return CMD_ERROR;
@@ -357,7 +354,7 @@
 		/* Add money to player */
 		PlayerID old_cp = _current_player;
 		_current_player = (PlayerID)p2;
-		SubtractMoneyFromPlayer(CommandCost(-amount.GetCost()));
+		SubtractMoneyFromPlayer( CommandCost( -amount.GetCost(), EXPENSES_OTHER ) );
 		_current_player = old_cp;
 	}
 
=== src/industry_cmd.cpp
==================================================================
--- src/industry_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/industry_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -398,7 +398,7 @@
 	}
 
 	if (flags & DC_EXEC) delete i;
-	return CommandCost();
+	return CommandCost(EXPENSES_CONSTRUCTION);
 }
 
 static void TransportIndustryGoods(TileIndex tile)
@@ -1577,8 +1577,6 @@
 {
 	const IndustrySpec *indspec;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	indspec = GetIndustrySpec(p1);
 
 	/* Check if the to-be built/founded industry is available for this climate. */
@@ -1629,7 +1627,7 @@
 		if (CreateNewIndustryHelper(tile, p1, flags, indspec, num) == NULL) return CMD_ERROR;
 	}
 
-	return CommandCost(indspec->GetConstructionCost());
+	return CommandCost(indspec->GetConstructionCost(), EXPENSES_OTHER);
 }
 
 
@@ -2069,10 +2067,10 @@
 			if (HASBIT(itspec->callback_flags, CBM_INDT_AUTOSLOPE)) {
 				/* If the callback fails, allow autoslope. */
 				uint16 res = GetIndustryTileCallback(CBID_INDUSTRY_AUTOSLOPE, 0, 0, gfx, GetIndustryByTile(tile), tile);
-				if ((res == 0) || (res == CALLBACK_FAILED)) return _price.terraform;
+				if ((res == 0) || (res == CALLBACK_FAILED)) return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 			} else {
 				// allow autoslope
-				return _price.terraform;
+				return CommandCost(_price.terraform, EXPENSES_CONSTRUCTION);
 			}
 		}
 	}
=== src/autoreplace_cmd.cpp
==================================================================
--- src/autoreplace_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/autoreplace_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -158,12 +158,10 @@
 	/* We give the player a loan of the same amount as the sell value.
 	 * This is needed in case he needs the income from the sale to build the new vehicle.
 	 * We take it back if building fails or when we really sell the old engine */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	SubtractMoneyFromPlayer(sell_value);
 
 	cost = DoCommand(old_v->tile, new_engine_type, 3, flags, GetCmdBuildVeh(old_v));
 	if (CmdFailed(cost)) {
-		SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 		/* Take back the money we just gave the player */
 		sell_value.MultiplyCost(-1);
 		SubtractMoneyFromPlayer(sell_value);
@@ -263,7 +261,7 @@
 		/* Ensure that the player will not end up having negative money while autoreplacing
 		 * This is needed because the only other check is done after the income from selling the old vehicle is substracted from the cost */
 		if (CmdFailed(tmp_move) || p->player_money < (cost.GetCost() + total_cost)) {
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+			
 			/* Pay back the loan */
 			sell_value.MultiplyCost(-1);
 			SubtractMoneyFromPlayer(sell_value);
@@ -273,7 +271,6 @@
 
 	/* Take back the money we just gave the player just before building the vehicle
 	 * The player will get the same amount now that the sale actually takes place */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	sell_value.MultiplyCost(-1);
 	SubtractMoneyFromPlayer(sell_value);
 
@@ -333,7 +330,7 @@
 	v->leave_depot_instantly = false;
 
 	for (;;) {
-		cost = CommandCost();
+		cost = CommandCost(EXPENSES_NEW_VEHICLES);
 		w = v;
 		do {
 			if (w->type == VEH_TRAIN && IsRearDualheaded(w)) {
=== src/aircraft_cmd.cpp
==================================================================
--- src/aircraft_cmd.cpp	(/openttd/trunk)	(revision 388)
+++ src/aircraft_cmd.cpp	(/openttd/commandcost)	(revision 388)
@@ -231,7 +231,7 @@
 
 static CommandCost EstimateAircraftCost(EngineID engine, const AircraftVehicleInfo *avi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5, EXPENSES_NEW_VEHICLES);
 }
 
 
@@ -279,7 +279,7 @@
 
 	if (!IsHangarTile(tile) || !IsTileOwner(tile, _current_player)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+	
 
 	/* Prevent building aircraft types at places which can't handle them */
 	if (!CanAircraftUseStation(p1, tile)) return CMD_ERROR;
@@ -489,10 +489,8 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+	CommandCost ret(-v->value, EXPENSES_NEW_VEHICLES);
 
-	CommandCost ret(-v->value);
-
 	if (flags & DC_EXEC) {
 		// Invalidate depot
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
@@ -646,8 +644,6 @@
 	CargoID new_cid = GB(p2, 0, 8);
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
-
 	/* Check the refit capacity callback */
 	uint16 callback = CALLBACK_FAILED;
 	if (HASBIT(EngInfo(v->engine_type)->callbackmask, CBM_VEHICLE_REFIT_CAPACITY)) {
@@ -737,11 +733,10 @@
 
 	if (v->vehstatus & VS_STOPPED) return;
 
-	CommandCost cost = CommandCost(GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364);
+	CommandCost cost = CommandCost(GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364, EXPENSES_AIRCRAFT_RUN);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
 	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);


