Index: src/rail_cmd.cpp
===================================================================
--- src/rail_cmd.cpp	(revision 10908)
+++ src/rail_cmd.cpp	(working copy)
@@ -224,7 +224,7 @@
 	RailType railtype;
 	Track track;
 	TrackBits trackbit;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (!ValParamRailtype(p1) || !ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
@@ -234,8 +234,6 @@
 	tileh = GetTileSlope(tile, NULL);
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY:
 			if (!CheckTrackCombination(tile, trackbit, flags) ||
@@ -346,14 +344,12 @@
 {
 	Track track = (Track)p2;
 	TrackBits trackbit;
-	CommandCost cost(_price.remove_rail);
+	CommandCost cost(_price.remove_rail,EXPENSES_CONSTRUCTION);
 	bool crossing = false;
 
 	if (!ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_ROAD: {
 			if (!IsLevelCrossing(tile) ||
@@ -493,7 +489,7 @@
  */
 static CommandCost CmdRailTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	Track track = (Track)GB(p2, 4, 3);
 	Trackdir trackdir;
 	byte mode = HASBIT(p2, 7);
@@ -505,8 +501,6 @@
 	end_tile = p1;
 	trackdir = TrackToTrackdir(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (CmdFailed(ValidateAutoDrag(&trackdir, tile, end_tile))) return CMD_ERROR;
 
 	if (flags & DC_EXEC) SndPlayTileFx(SND_20_SPLAT_2, tile);
@@ -575,11 +569,9 @@
  */
 CommandCost CmdBuildTrainDepot(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* check railtype and valid direction for depot (0 through 3), 4 in total */
 	if (!ValParamRailtype(p1)) return CMD_ERROR;
 
@@ -670,15 +662,13 @@
 		}
 	}
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!HasSignalOnTrack(tile, track)) {
 		/* build new signals */
-		cost = CommandCost(_price.build_signals);
+		cost = CommandCost(_price.build_signals,EXPENSES_CONSTRUCTION);
 	} else {
 		if (p2 != 0 && sigvar != GetSignalVariant(tile, track)) {
 			/* convert signals <-> semaphores */
-			cost = CommandCost(_price.build_signals + _price.remove_signals);
+			cost = CommandCost(_price.build_signals + _price.remove_signals,EXPENSES_CONSTRUCTION);
 		} else {
 			/* it is free to change orientation/pre-exit-combo signals */
 			cost = CommandCost();
@@ -798,7 +788,7 @@
  */
 static CommandCost CmdSignalTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	int signal_ctr;
 	byte signals;
 	bool error = true;
@@ -819,8 +809,6 @@
 
 	if (!IsTileType(tile, MP_RAILWAY)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* for vertical/horizontal tracks, double the given signals density
 	 * since the original amount will be too dense (shorter tracks) */
 	signal_density *= 2;
@@ -943,8 +931,6 @@
 	/* Only water can remove signals from anyone */
 	if (_current_player != OWNER_WATER && !CheckTileOwnership(tile)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do it? */
 	if (flags & DC_EXEC) {
 		SetPresentSignals(tile, GetPresentSignals(tile) & ~SignalOnTrack(track));
@@ -962,7 +948,7 @@
 		MarkTileDirtyByTile(tile);
 	}
 
-	return CommandCost(_price.remove_signals);
+	return CommandCost(_price.remove_signals,EXPENSES_CONSTRUCTION);
 }
 
 /** Remove signals on a stretch of track.
@@ -1049,14 +1035,12 @@
  */
 CommandCost CmdConvertRail(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, cost;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
 	Money money;
 	int ex;
 	int ey;
 	int sx, sy, x, y;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!ValParamRailtype(p2)) return CMD_ERROR;
 	if (p1 >= MapSize()) return CMD_ERROR;
 
@@ -1123,7 +1107,7 @@
 
 static CommandCost ClearTile_Track(TileIndex tile, byte flags)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (flags & DC_AUTO) {
Index: src/station_cmd.cpp
===================================================================
--- src/station_cmd.cpp	(revision 10908)
+++ src/station_cmd.cpp	(working copy)
@@ -652,7 +652,7 @@
 // Or an error code if it failed.
 CommandCost CheckFlatLandBelow(TileIndex tile, uint w, uint h, uint flags, uint invalid_dirs, StationID* station, bool check_clear = true)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int allowed_z = -1;
 
 	BEGIN_TILE_LOOP(tile_cur, w, h, tile) {
@@ -840,8 +840,6 @@
 	int w_org, h_org;
 	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Does the authority allow this? */
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
 	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
@@ -872,7 +870,7 @@
 	//  for detail info, see: https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365
 	ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags & ~DC_EXEC, 5 << axis, _patches.nonuniform_stations ? &est : NULL);
 	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len);
+	CommandCost cost(ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len,EXPENSES_CONSTRUCTION);
 
 	Station *st = NULL;
 	bool check_surrounding = true;
@@ -1109,8 +1107,6 @@
 	int size_x = ex - sx + 1;
 	int size_y = ey - sy + 1;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do the action for every tile into the area */
 	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
 		/* Make sure the specified tile belongs to the current player, and that it is a railroad station. */
@@ -1155,7 +1151,7 @@
 	/* If we've not removed any tiles, give an error */
 	if (quantity == 0) return CMD_ERROR;
 
-	return CommandCost(_price.remove_rail_station * quantity);
+	return CommandCost(_price.remove_rail_station * quantity,EXPENSES_CONSTRUCTION);
 }
 
 
@@ -1176,7 +1172,7 @@
 
 	assert(w != 0 && h != 0);
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	/* clear all areas of the station */
 	do {
 		int w_bak = w;
@@ -1245,7 +1241,7 @@
 		YapfNotifyTrackLayoutChange(tile, GetRailStationTrack(tile));
 	}
 
-	return CommandCost(_price.build_rail / 2);
+	return CommandCost(_price.build_rail / 2,EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -1297,8 +1293,6 @@
 	/* Road bits in the wrong direction */
 	if (build_over_road && (GetAllRoadBits(tile) & ((Axis)p1 == AXIS_X ? ROAD_Y : ROAD_X)) != 0) return_cmd_error(STR_DRIVE_THROUGH_ERROR_DIRECTION);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile)) return CMD_ERROR;
 
 	CommandCost cost;
@@ -1450,7 +1444,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost((is_truck) ? _price.remove_truck_station : _price.remove_bus_station);
+	return CommandCost((is_truck) ? _price.remove_truck_station : _price.remove_bus_station,EXPENSES_CONSTRUCTION);
 }
 
 /** Remove a bus or truck stop
@@ -1588,8 +1582,6 @@
 {
 	bool airport_upgrade = true;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Check if a valid, buildable airport was chosen for construction */
 	if (p1 > lengthof(_airport_sections) || !HASBIT(GetValidAirports(), p1)) return CMD_ERROR;
 
@@ -1616,9 +1608,8 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost ret = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
-	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost());
+	CommandCost cost = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
+	if (CmdFailed(cost)) return cost;
 
 	Station *st = NULL;
 
@@ -1722,7 +1713,7 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost cost(w * h * _price.remove_airport);
+	CommandCost cost(w * h * _price.remove_airport,EXPENSES_CONSTRUCTION);
 
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
@@ -1767,8 +1758,6 @@
  */
 CommandCost CmdBuildBuoy(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!IsClearWaterTile(tile) || tile == 0) return_cmd_error(STR_304B_SITE_UNSUITABLE);
 	if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) return_cmd_error(STR_5007_MUST_DEMOLISH_BRIDGE_FIRST);
 
@@ -1804,7 +1793,7 @@
 		st_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_dock);
+	return CommandCost(_price.build_dock,EXPENSES_CONSTRUCTION);
 }
 
 /* Checks if any ship is servicing the buoy specified. Returns yes or no */
@@ -1856,7 +1845,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_truck_station);
+	return CommandCost(_price.remove_truck_station,EXPENSES_CONSTRUCTION);
 }
 
 static const TileIndexDiffC _dock_tileoffs_chkaround[] = {
@@ -1878,8 +1867,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection direction;
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: direction = DIAGDIR_NE; break;
@@ -1970,7 +1957,7 @@
 		/* success, so don't delete the new station */
 		st_auto_delete.Detach();
 	}
-	return CommandCost(_price.build_dock);
+	return CommandCost(_price.build_dock,EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveDock(Station *st, uint32 flags)
@@ -1999,7 +1986,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_dock);
+	return CommandCost(_price.remove_dock,EXPENSES_CONSTRUCTION);
 }
 
 #include "table/station_land.h"
Index: src/town_cmd.cpp
===================================================================
--- src/town_cmd.cpp	(revision 10908)
+++ src/town_cmd.cpp	(working copy)
@@ -470,7 +470,7 @@
 static CommandCost ClearTile_Town(TileIndex tile, byte flags)
 {
 	int rating;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Town *t;
 	HouseSpec *hs = GetHouseSpecs(GetHouseType(tile));
 
@@ -1450,8 +1450,6 @@
 	if (_game_mode != GM_EDITOR) return CMD_ERROR;
 	if (p2 > TSM_CITY) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* Check if too close to the edge of map */
 	if (DistanceFromEdge(tile) < 12)
 		return_cmd_error(STR_0237_TOO_CLOSE_TO_EDGE_OF_MAP);
@@ -2043,7 +2041,6 @@
  */
 CommandCost CmdDoTownAction(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
 	Town *t;
 
 	if (!IsValidTownID(p1) || p2 > lengthof(_town_action_proc)) return CMD_ERROR;
@@ -2052,10 +2049,8 @@
 
 	if (!HASBIT(GetMaskOfTownActions(NULL, _current_player, t), p2)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+	CommandCost cost((_price.build_industry >> 8) * _town_action_costs[p2],EXPENSES_OTHER);
 
-	cost.AddCost((_price.build_industry >> 8) * _town_action_costs[p2]);
-
 	if (flags & DC_EXEC) {
 		_town_action_proc[p2](t);
 		InvalidateWindow(WC_TOWN_AUTHORITY, p1);
Index: src/ship_cmd.cpp
===================================================================
--- src/ship_cmd.cpp	(revision 10908)
+++ src/ship_cmd.cpp	(working copy)
@@ -178,7 +178,7 @@
 
 void OnNewDay_Ship(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 
 	if ((++v->day_counter & 7) == 0)
 		DecreaseVehicleValue(v);
@@ -194,8 +194,7 @@
 	cost.AddCost(GetVehicleProperty(v, 0x0F, ShipVehInfo(v->engine_type)->running_cost) * _price.ship_running / 364);
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	/* we need this for the profit */
@@ -409,7 +408,7 @@
 
 static CommandCost EstimateShipCost(EngineID engine_type)
 {
-	return CommandCost(GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5,EXPENSES_NEW_VEHICLES);
 }
 
 static void ShipArrivesAt(const Vehicle* v, Station* st)
@@ -824,8 +823,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_SHIP, _current_player)) return_cmd_error(STR_SHIP_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	value = EstimateShipCost(p1);
 	if (flags & DC_QUERY_COST) return value;
 
@@ -923,8 +920,6 @@
 
 	if (v->type != VEH_SHIP || !CheckOwnership(v->owner)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!IsShipInDepotStopped(v)) {
 		return_cmd_error(STR_980B_SHIP_MUST_BE_STOPPED_IN);
 	}
@@ -938,7 +933,7 @@
 		delete v;
 	}
 
-	return CommandCost(-v->value);
+	return CommandCost(-v->value,EXPENSES_NEW_VEHICLES);
 }
 
 /** Start/Stop a ship.
@@ -1068,7 +1063,7 @@
 CommandCost CmdRefitShip(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 	CargoID new_cid = GB(p2, 0, 8); //gets the cargo number
 	byte new_subtype = GB(p2, 8, 8);
 	uint16 capacity = CALLBACK_FAILED;
@@ -1087,8 +1082,6 @@
 	if (!ShipVehInfo(v->engine_type)->refittable) return CMD_ERROR;
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-
 	/* Check the refit capacity callback */
 	if (HASBIT(EngInfo(v->engine_type)->callbackmask, CBM_REFIT_CAPACITY)) {
 		/* Back up the existing cargo type */
Index: src/waypoint.cpp
===================================================================
--- src/waypoint.cpp	(revision 10908)
+++ src/waypoint.cpp	(working copy)
@@ -161,8 +161,6 @@
 	Slope tileh;
 	Axis axis;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* if custom gfx are used, make sure it is within bounds */
 	if (p1 >= GetNumCustomStations(STAT_CLASS_WAYP)) return CMD_ERROR;
 
@@ -228,7 +226,7 @@
 		wp_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_train_depot);
+	return CommandCost(_price.build_train_depot,EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -280,7 +278,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 	}
 
-	return CommandCost(_price.remove_train_depot);
+	return CommandCost(_price.remove_train_depot,EXPENSES_CONSTRUCTION);
 }
 
 /**
@@ -293,7 +291,6 @@
  */
 CommandCost CmdRemoveTrainWaypoint(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 	return RemoveTrainWaypoint(tile, flags, true);
 }
 
Index: src/train_cmd.cpp
===================================================================
--- src/train_cmd.cpp	(revision 10908)
+++ src/train_cmd.cpp	(working copy)
@@ -506,10 +506,8 @@
 
 static CommandCost CmdBuildRailWagon(EngineID engine, TileIndex tile, uint32 flags)
 {
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(engine);
-	CommandCost value((GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8);
+	CommandCost value((GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8,EXPENSES_NEW_VEHICLES);
 
 	uint num_vehicles = 1 + CountArticulatedParts(engine);
 
@@ -594,7 +592,7 @@
 		}
 	}
 
-	return CommandCost(value);
+	return value;
 }
 
 /** Move all free vehicles in the depot to the train */
@@ -615,7 +613,7 @@
 
 static CommandCost EstimateTrainCost(EngineID engine, const RailVehicleInfo* rvi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5,EXPENSES_NEW_VEHICLES);
 }
 
 static void AddRearEngineToMultiheadedTrain(Vehicle* v, Vehicle* u, bool building)
@@ -665,8 +663,6 @@
 		if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
 	}
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(p1);
 
 	/* Check if depot and new engine uses the same kind of tracks */
@@ -1216,8 +1212,6 @@
 
 	if (v->type != VEH_TRAIN || !CheckOwnership(v->owner)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	while (IsArticulatedPart(v)) v = GetPrevVehicleInChain(v);
 	Vehicle *first = GetFirstVehicleInChain(v);
 
@@ -1237,7 +1231,7 @@
 		RebuildVehicleLists();
 	}
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
 	switch (p2) {
 		case 0: case 2: { /* Delete given wagon */
 			bool switch_engine = false;    // update second wagon to engine?
@@ -1706,9 +1700,7 @@
 	/* Check cargo */
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
-
-	CommandCost cost;
+	CommandCost cost(EXPENSES_TRAIN_RUN);
 	uint num = 0;
 
 	do {
@@ -3420,11 +3412,10 @@
 
 		if ((v->vehstatus & VS_STOPPED) == 0) {
 			/* running costs */
-			CommandCost cost(GetTrainRunningCost(v) / 364);
+			CommandCost cost(GetTrainRunningCost(v) / 364,EXPENSES_TRAIN_RUN);
 
 			v->profit_this_year -= cost.GetCost() >> 8;
 
-			SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
 			SubtractMoneyFromPlayerFract(v->owner, cost);
 
 			InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
Index: src/road_cmd.cpp
===================================================================
--- src/road_cmd.cpp	(revision 10908)
+++ src/road_cmd.cpp	(working copy)
@@ -118,8 +118,6 @@
 	 * false if it was a center piece. Affects town ratings drop */
 	bool edge_road;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	RoadType rt = (RoadType)GB(p1, 4, 2);
 	if (!IsValidRoadType(rt)) return CMD_ERROR;
 
@@ -159,7 +157,7 @@
 		/* If it's the last roadtype, just clear the whole tile */
 		if (rts == RoadTypeToRoadTypes(rt)) return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 
-		CommandCost cost;
+		CommandCost cost(EXPENSES_CONSTRUCTION);
 		if (IsTileType(tile, MP_TUNNELBRIDGE)) {
 			TileIndex other_end = IsTunnel(tile) ? GetOtherTunnelEnd(tile) : GetOtherBridgeEnd(tile);
 			/* Pay for *every* tile of the bridge or tunnel */
@@ -184,7 +182,7 @@
 				MarkTileDirtyByTile(tile);
 			}
 		}
-		return CommandCost(cost);
+		return cost;
 	}
 
 	switch (GetRoadTileType(tile)) {
@@ -225,7 +223,7 @@
 					MarkTileDirtyByTile(tile);
 				}
 			}
-			return CommandCost(CountRoadBits(c) * _price.remove_road);
+			return CommandCost(CountRoadBits(c) * _price.remove_road,EXPENSES_CONSTRUCTION);
 		}
 
 		case ROAD_TILE_CROSSING: {
@@ -251,7 +249,7 @@
 				MarkTileDirtyByTile(tile);
 				YapfNotifyTrackLayoutChange(tile, FindFirstTrack(GetTrackBits(tile)));
 			}
-			return CommandCost(_price.remove_road * 2);
+			return CommandCost(_price.remove_road * 2,EXPENSES_CONSTRUCTION);
 		}
 
 		default:
@@ -343,14 +341,12 @@
  */
 CommandCost CmdBuildRoad(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 	RoadBits existing = ROAD_NONE;
 	RoadBits all_bits = ROAD_NONE;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Road pieces are max 4 bitset values (NE, NW, SE, SW) and town can only be non-zero
 	 * if a non-player is building the road */
 	if ((IsValidPlayer(_current_player) && p2 != 0) || (_current_player == OWNER_TOWN && !IsValidTownID(p2))) return CMD_ERROR;
@@ -586,14 +582,12 @@
 CommandCost CmdBuildLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret;
+	CommandCost ret,cost(EXPENSES_CONSTRUCTION);
 	bool had_bridge = false;
 	bool had_tunnel = false;
 	bool had_success = false;
 	DisallowedRoadDirections drd = DRD_NORTHBOUND;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -673,10 +667,9 @@
 CommandCost CmdRemoveLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret, money;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
+	Money money;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -695,7 +688,7 @@
 		p2 ^= IS_INT_INSIDE(p2 & 3, 1, 3) ? 3 : 0;
 	}
 
-	money.AddCost(GetAvailableMoneyForCommand());
+	money = GetAvailableMoneyForCommand();
 	tile = start_tile;
 	/* Start tile is the small number. */
 	for (;;) {
@@ -709,8 +702,8 @@
 			ret = DoCommand(tile, rt << 4 | bits, 0, flags & ~DC_EXEC, CMD_REMOVE_ROAD);
 			if (CmdSucceeded(ret)) {
 				if (flags & DC_EXEC) {
-					money.AddCost(-ret.GetCost());
-					if (money.GetCost() < 0) {
+					money -= ret.GetCost();
+					if (money < 0) {
 						_additional_cash_required = DoCommand(end_tile, start_tile, p2, flags & ~DC_EXEC, CMD_REMOVE_LONG_ROAD).GetCost();
 						return cost;
 					}
@@ -743,8 +736,6 @@
 	CommandCost cost;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection dir = Extract<DiagDirection, 0>(p1);
 	RoadType rt = (RoadType)GB(p1, 2, 2);
 
@@ -807,7 +798,7 @@
 			    !(flags & DC_AUTO)
 				) {
 				RoadTypes rts = GetRoadTypes(tile);
-				CommandCost ret;
+				CommandCost ret(EXPENSES_CONSTRUCTION);
 				for (RoadType rt = ROADTYPE_ROAD; rt < ROADTYPE_END; rt++) {
 					if (HASBIT(rts, rt)) {
 						CommandCost tmp_ret = DoCommand(tile, rt << 4 | GetRoadBits(tile, rt), 0, flags, CMD_REMOVE_ROAD);
@@ -823,7 +814,7 @@
 
 		case ROAD_TILE_CROSSING: {
 			RoadTypes rts = GetRoadTypes(tile);
-			CommandCost ret;
+			CommandCost ret(EXPENSES_CONSTRUCTION);
 
 			if (flags & DC_AUTO) return_cmd_error(STR_1801_MUST_REMOVE_ROAD_FIRST);
 
Index: src/command.cpp
===================================================================
--- src/command.cpp	(revision 10908)
+++ src/command.cpp	(working copy)
@@ -398,7 +398,7 @@
 	}
 
 	/* Execute the command here. All cost-relevant functions set the expenses type
-	 * themselves with "SET_EXPENSES_TYPE(...);" at the beginning of the function */
+	 * themselves to the cost object at some point */
 	res = proc(tile, flags, p1, p2);
 	if (CmdFailed(res)) {
 		res.SetGlobalErrorMessage();
@@ -411,6 +411,7 @@
 	/* if toplevel, subtract the money. */
 	if (--_docommand_recursive == 0) {
 		SubtractMoneyFromPlayer(res);
+	
 		/* XXX - Old AI hack which doesn't use DoCommandDP; update last build coord of player */
 		if (tile != 0 && IsValidPlayer(_current_player)) {
 			GetPlayer(_current_player)->last_build_coordinate = tile;
@@ -553,7 +554,6 @@
 
 	/* Actually try and execute the command. If no cost-type is given
 	 * use the construction one */
-	_yearly_expenses_type = EXPENSES_CONSTRUCTION;
 	res2 = proc(tile, flags | DC_EXEC, p1, p2);
 
 	/* If notest is on, it means the result of the test can be different than
@@ -566,9 +566,8 @@
 			goto show_error;
 		}
 	}
-
 	SubtractMoneyFromPlayer(res2);
-
+	
 	if (IsLocalPlayer() && _game_mode != GM_EDITOR) {
 		if (res2.GetCost() != 0) ShowCostOrIncomeAnimation(x, y, GetSlopeZ(x, y), res2.GetCost());
 		if (_additional_cash_required != 0) {
@@ -601,6 +600,7 @@
 
 CommandCost CommandCost::AddCost(CommandCost ret)
 {
+	assert(this->GetExpensesType() != EXPENSES_INVALID);
 	this->AddCost(ret.cost);
 	if (this->success && !ret.success) {
 		this->message = ret.message;
@@ -638,6 +638,11 @@
 	return this->cost;
 }
 
+ExpensesType CommandCost::GetExpensesType() const 
+{
+	return this->expense_type;	
+}
+
 void CommandCost::SetGlobalErrorMessage() const
 {
 	extern StringID _error_message;
Index: src/tree_cmd.cpp
===================================================================
--- src/tree_cmd.cpp	(revision 10908)
+++ src/tree_cmd.cpp	(working copy)
@@ -216,7 +216,7 @@
 CommandCost CmdPlantTree(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	StringID msg = INVALID_STRING_ID;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 	int ex;
 	int ey;
 	int sx, sy, x, y;
@@ -225,8 +225,6 @@
 	/* Check the tree type. It can be random or some valid value within the current climate */
 	if (p1 != (uint)-1 && p1 - _tree_base_by_landscape[_opt.landscape] >= _tree_count_by_landscape[_opt.landscape]) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	// make sure sx,sy are smaller than ex,ey
 	ex = TileX(tile);
 	ey = TileY(tile);
@@ -436,7 +434,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(num * _price.remove_trees);
+	return CommandCost(num * _price.remove_trees,EXPENSES_CONSTRUCTION);
 }
 
 static void GetAcceptedCargo_Trees(TileIndex tile, AcceptedCargo ac)
Index: src/tunnelbridge_cmd.cpp
===================================================================
--- src/tunnelbridge_cmd.cpp	(revision 10908)
+++ src/tunnelbridge_cmd.cpp	(working copy)
@@ -195,13 +195,12 @@
 	TileIndexDiff delta;
 	uint bridge_len;
 	Axis direction;
-	CommandCost cost, terraformcost, ret;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+	CommandCost terraformcost, ret;
 	bool allow_on_slopes;
 	bool replace_bridge = false;
 	uint replaced_bridge_type;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* unpack parameters */
 	bridge_type = GB(p2, 0, 8);
 
@@ -457,7 +456,7 @@
 	Slope end_tileh;
 	uint start_z;
 	uint end_z;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	_build_tunnel_endtile = 0;
@@ -610,8 +609,6 @@
 	TileIndex endtile;
 	uint length;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = CheckTunnelBusy(tile, &length);
@@ -648,7 +645,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
-	return CommandCost(_price.clear_tunnel * (length + 1));
+	return CommandCost(_price.clear_tunnel * (length + 1),EXPENSES_CONSTRUCTION);
 }
 
 
@@ -671,8 +668,6 @@
 	TileIndex endtile;
 	Town *t = NULL;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = GetOtherBridgeEnd(tile);
@@ -721,7 +716,7 @@
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
 
-	return CommandCost((DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge);
+	return CommandCost((DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge,EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost ClearTile_TunnelBridge(TileIndex tile, byte flags)
Index: src/ai/default/default.cpp
===================================================================
--- src/ai/default/default.cpp	(revision 10908)
+++ src/ai/default/default.cpp	(working copy)
@@ -1641,7 +1641,7 @@
 static CommandCost AiDoBuildDefaultRailTrack(TileIndex tile, const AiDefaultBlockData* p, RailType railtype, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int i, j, k;
@@ -2628,7 +2628,7 @@
 static CommandCost AiDoBuildDefaultRoadBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int roadflag = 0;
@@ -3389,7 +3389,7 @@
 static CommandCost AiDoBuildDefaultAirportBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	uint32 avail_airports = GetValidAirports();
-	CommandCost total_cost, ret;
+	CommandCost ret,total_cost(EXPENSES_CONSTRUCTION);
 
 	for (; p->mode == 0; p++) {
 		if (!HASBIT(avail_airports, p->attr)) return CMD_ERROR;
Index: src/clear_cmd.cpp
===================================================================
--- src/clear_cmd.cpp	(revision 10908)
+++ src/clear_cmd.cpp	(working copy)
@@ -249,14 +249,12 @@
 	TerraformerHeightMod modheight_data[576];
 	TileIndex tile_table_data[625];
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	_terraform_err_tile = 0;
 
 	ts.direction = direction = p2 ? 1 : -1;
 	ts.flags = flags;
 	ts.modheight_count = ts.tile_table_count = 0;
-	ts.cost = CommandCost();
+	ts.cost = CommandCost(EXPENSES_CONSTRUCTION);
 	ts.modheight = modheight_data;
 	ts.tile_table = tile_table_data;
 
@@ -374,12 +372,10 @@
 	uint h, curh;
 	CommandCost money;
 	CommandCost ret;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* remember level height */
 	h = TileHeight(p1);
 
@@ -432,8 +428,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!EnsureNoVehicle(tile)) return CMD_ERROR;
 
 	if (IsOwnedLandTile(tile) && IsTileOwner(tile, _current_player)) {
@@ -463,15 +457,15 @@
 		&_price.purchase_land,
 		&_price.clear_2, // XXX unused?
 	};
-	CommandCost price;
+	Money price = 0;
 
 	if (!IsClearGround(tile, CLEAR_GRASS) || GetClearDensity(tile) != 0) {
-		price.AddCost(*clear_price_table[GetClearGround(tile)]);
+		price = *clear_price_table[GetClearGround(tile)];
 	}
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return price;
+	return CommandCost(price,EXPENSES_CONSTRUCTION);
 }
 
 /** Sell a land area. Actually you only sell one tile, so
@@ -484,7 +478,6 @@
  */
 CommandCost CmdSellLandArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
 	if (!IsOwnedLandTile(tile)) return CMD_ERROR;
 	if (!CheckTileOwnership(tile) && _current_player != OWNER_WATER) return CMD_ERROR;
@@ -494,7 +487,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(- _price.purchase_land * 2);
+	return CommandCost(- _price.purchase_land * 2,EXPENSES_CONSTRUCTION);
 }
 
 
Index: src/unmovable_cmd.cpp
===================================================================
--- src/unmovable_cmd.cpp	(revision 10908)
+++ src/unmovable_cmd.cpp	(working copy)
@@ -36,8 +36,6 @@
 {
 	Player* p = GetPlayer(pid);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	if (flags & DC_EXEC) {
 		TileIndex t = p->location_of_house;
 
@@ -50,7 +48,7 @@
 	}
 
 	/* cost of relocating company is 1% of company value */
-	return CommandCost(CalculateCompanyValue(p) / 100);
+	return CommandCost(CalculateCompanyValue(p) / 100,EXPENSES_PROPERTY);
 }
 
 void UpdateCompanyHQ(Player *p, uint score)
@@ -85,10 +83,8 @@
 CommandCost CmdBuildCompanyHQ(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p = GetPlayer(_current_player);
-	CommandCost cost;
+	CommandCost cost(EXPENSES_PROPERTY);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	cost = CheckFlatLandBelow(tile, 2, 2, flags, 0, NULL);
 	if (CmdFailed(cost)) return cost;
 
Index: src/water_cmd.cpp
===================================================================
--- src/water_cmd.cpp	(revision 10908)
+++ src/water_cmd.cpp	(working copy)
@@ -62,10 +62,8 @@
 {
 	TileIndex tile2;
 
-	CommandCost cost, ret;
+	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!EnsureNoVehicle(tile)) return CMD_ERROR;
 
 	Axis axis = Extract<Axis, 0>(p1);
@@ -97,7 +95,7 @@
 		d_auto_delete.Detach();
 	}
 
-	return cost.AddCost(_price.build_ship_depot);
+	return CommandCost(_price.build_ship_depot,EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveShipDepot(TileIndex tile, uint32 flags)
@@ -122,7 +120,7 @@
 		MarkTileDirtyByTile(tile2);
 	}
 
-	return CommandCost(_price.remove_ship_depot);
+	return CommandCost(_price.remove_ship_depot,EXPENSES_CONSTRUCTION);
 }
 
 /** build a shiplift */
@@ -163,7 +161,7 @@
 		MarkTileDirtyByTile(tile + delta);
 	}
 
-	return CommandCost(_price.clear_water * 22 >> 3);
+	return CommandCost(_price.clear_water * 22 >> 3,EXPENSES_CONSTRUCTION);
 }
 
 static CommandCost RemoveShiplift(TileIndex tile, uint32 flags)
@@ -203,8 +201,6 @@
 {
 	DiagDirection dir;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: dir = DIAGDIR_SW; break;
 		case SLOPE_SE: dir = DIAGDIR_SE; break;
@@ -223,7 +219,7 @@
  */
 CommandCost CmdBuildCanal(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int size_x, size_y;
 	int x;
 	int y;
@@ -238,8 +234,6 @@
 	sx = TileX(p1);
 	sy = TileY(p1);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (x < sx) Swap(x, sx);
 	if (y < sy) Swap(y, sy);
 	size_x = (x - sx) + 1;
@@ -300,7 +294,7 @@
 			if (GetTileOwner(tile) != OWNER_WATER && GetTileOwner(tile) != OWNER_NONE && !CheckTileOwnership(tile)) return CMD_ERROR;
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
-			return CommandCost(_price.clear_water);
+			return CommandCost(_price.clear_water,EXPENSES_CONSTRUCTION);
 
 		case WATER_TILE_COAST: {
 			Slope slope = GetTileSlope(tile, NULL);
@@ -316,9 +310,9 @@
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
 			if (slope == SLOPE_N || slope == SLOPE_E || slope == SLOPE_S || slope == SLOPE_W) {
-				return CommandCost(_price.clear_water);
+				return CommandCost(_price.clear_water,EXPENSES_CONSTRUCTION);
 			} else {
-				return CommandCost(_price.purchase_land);
+				return CommandCost(_price.purchase_land,EXPENSES_CONSTRUCTION);
 			}
 		}
 
Index: src/economy.cpp
===================================================================
--- src/economy.cpp	(revision 10908)
+++ src/economy.cpp	(working copy)
@@ -619,8 +619,8 @@
 
 	FOR_ALL_STATIONS(st) {
 		_current_player = st->owner;
-		SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-		SubtractMoneyFromPlayer(_price.station_value >> 1);
+		CommandCost cost(_price.station_value >> 1,EXPENSES_PROPERTY);
+		SubtractMoneyFromPlayer(cost);
 	}
 
 	if (!HASBIT(1<<0|1<<3|1<<6|1<<9, _cur_month))
@@ -720,12 +720,11 @@
 		if (!p->is_active) continue;
 
 		_current_player = p->index;
-		SET_EXPENSES_TYPE(EXPENSES_LOAN_INT);
+		
 
-		SubtractMoneyFromPlayer(CommandCost((Money)BIGMULUS(p->current_loan, interest, 16)));
+		SubtractMoneyFromPlayer(CommandCost((Money)BIGMULUS(p->current_loan, interest, 16),EXPENSES_LOAN_INT));
 
-		SET_EXPENSES_TYPE(EXPENSES_OTHER);
-		SubtractMoneyFromPlayer(_price.station_value >> 2);
+		SubtractMoneyFromPlayer(CommandCost(_price.station_value >> 2,EXPENSES_OTHER));
 	}
 }
 
@@ -1479,7 +1478,7 @@
 
 	if (route_profit != 0) {
 		front_v->profit_this_year += vehicle_profit;
-		SubtractMoneyFromPlayer(-route_profit);
+		SubtractMoneyFromPlayer( CommandCost( -route_profit, front_v->GetExpenseType(true) ) );
 
 		if (IsLocalPlayer() && !PlayVehicleSound(front_v, VSE_LOAD_UNLOAD)) {
 			SndPlayVehicleFx(SND_14_CASHTILL, front_v);
@@ -1781,9 +1780,9 @@
 	PlayerID old_player = _current_player;
 	for (i = 0; i != 4; i++) {
 		if (p->share_owners[i] != PLAYER_SPECTATOR) {
-			SET_EXPENSES_TYPE(EXPENSES_OTHER);
+			
 			_current_player = p->share_owners[i];
-			SubtractMoneyFromPlayer(CommandCost(-value));
+			SubtractMoneyFromPlayer(CommandCost( -value, EXPENSES_OTHER ) );
 		}
 	}
 	_current_player = old_player;
@@ -1805,12 +1804,12 @@
 CommandCost CmdBuyShareInCompany(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 
 	/* Check if buying shares is allowed (protection against modified clients */
 	if (!IsValidPlayer((PlayerID)p1) || !_patches.allow_shares) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+	
 	p = GetPlayer((PlayerID)p1);
 
 	/* Protect new companies from hostile takeovers */
@@ -1856,7 +1855,6 @@
 	/* Check if buying shares is allowed (protection against modified clients */
 	if (!IsValidPlayer((PlayerID)p1) || !_patches.allow_shares) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 	p = GetPlayer((PlayerID)p1);
 
 	/* Those lines are here for network-protection (clients can be slow) */
@@ -1872,7 +1870,7 @@
 		*b = PLAYER_SPECTATOR;
 		InvalidateWindow(WC_COMPANY, p1);
 	}
-	return CommandCost(cost);
+	return CommandCost(cost,EXPENSES_OTHER);
 }
 
 /** Buy up another company.
@@ -1895,7 +1893,6 @@
 	/* Do not allow players to take over themselves */
 	if (pid == _current_player) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 	p = GetPlayer(pid);
 
 	if (!p->is_ai) return CMD_ERROR;
@@ -1903,7 +1900,7 @@
 	if (flags & DC_EXEC) {
 		DoAcquireCompany(p);
 	}
-	return CommandCost(p->bankrupt_value);
+	return CommandCost(p->bankrupt_value,EXPENSES_OTHER);
 }
 
 /** Prices */
Index: src/variables.h
===================================================================
--- src/variables.h	(revision 10908)
+++ src/variables.h	(working copy)
@@ -292,7 +292,6 @@
 VARDEF bool _rightclick_emulate;
 
 /* IN/OUT parameters to commands */
-VARDEF byte _yearly_expenses_type;
 VARDEF TileIndex _terraform_err_tile;
 VARDEF TileIndex _build_tunnel_endtile;
 VARDEF bool _generating_world;
@@ -326,8 +325,6 @@
 VARDEF char *_log_file;
 
 
-#define SET_EXPENSES_TYPE(x) _yearly_expenses_type = x;
-
 /* landscape.cpp */
 extern const byte _tileh_to_sprite[32];
 
Index: src/players.cpp
===================================================================
--- src/players.cpp	(revision 10908)
+++ src/players.cpp	(working copy)
@@ -188,18 +188,22 @@
 
 static void SubtractMoneyFromAnyPlayer(Player *p, CommandCost cost)
 {
-	CommandCost tmp(p->player_money);
+	if(cost.GetCost() == 0) return;
+	
+	assert(cost.GetExpensesType() != EXPENSES_INVALID);
+
+	CommandCost tmp(p->player_money,cost.GetExpensesType());
 	tmp.AddCost(-cost.GetCost());
 	p->player_money = tmp.GetCost();
 
-	tmp = CommandCost(p->yearly_expenses[0][_yearly_expenses_type]);
+	tmp = CommandCost(p->yearly_expenses[0][cost.GetExpensesType()],cost.GetExpensesType());
 	tmp.AddCost(cost);
-	p->yearly_expenses[0][_yearly_expenses_type] = tmp.GetCost();
+	p->yearly_expenses[0][cost.GetExpensesType()] = tmp.GetCost();
 
 	if (HASBIT(1 << EXPENSES_TRAIN_INC    |
 	           1 << EXPENSES_ROADVEH_INC  |
 	           1 << EXPENSES_AIRCRAFT_INC |
-	           1 << EXPENSES_SHIP_INC, _yearly_expenses_type)) {
+	           1 << EXPENSES_SHIP_INC, cost.GetExpensesType())) {
 		tmp = CommandCost(p->cur_economy.income);
 		tmp.AddCost(-cost.GetCost());
 		p->cur_economy.income = tmp.GetCost();
@@ -208,7 +212,7 @@
 	                  1 << EXPENSES_AIRCRAFT_RUN |
 	                  1 << EXPENSES_SHIP_RUN     |
 	                  1 << EXPENSES_PROPERTY     |
-	                  1 << EXPENSES_LOAN_INT, _yearly_expenses_type)) {
+	                  1 << EXPENSES_LOAN_INT, cost.GetExpensesType())) {
 		tmp = CommandCost(p->cur_economy.expenses);
 		tmp.AddCost(-cost.GetCost());
 		p->cur_economy.expenses = tmp.GetCost();
@@ -233,7 +237,7 @@
 	p->player_money_fraction = m - (byte)cost;
 	cost >>= 8;
 	if (p->player_money_fraction > m) cost++;
-	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cost));
+	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cost,cst.GetExpensesType()));
 }
 
 void GetNameOfOwner(Owner owner, TileIndex tile)
Index: src/openttd.h
===================================================================
--- src/openttd.h	(revision 10908)
+++ src/openttd.h	(working copy)
@@ -361,6 +361,22 @@
 	int32 top;
 	byte width_1, width_2;
 };
+enum ExpensesType {
+	EXPENSES_CONSTRUCTION =  0,
+	EXPENSES_NEW_VEHICLES =  1,
+	EXPENSES_TRAIN_RUN    =  2,
+	EXPENSES_ROADVEH_RUN  =  3,
+	EXPENSES_AIRCRAFT_RUN =  4,
+	EXPENSES_SHIP_RUN     =  5,
+	EXPENSES_PROPERTY     =  6,
+	EXPENSES_TRAIN_INC    =  7,
+	EXPENSES_ROADVEH_INC  =  8,
+	EXPENSES_AIRCRAFT_INC =  9,
+	EXPENSES_SHIP_INC     = 10,
+	EXPENSES_LOAN_INT     = 11,
+	EXPENSES_OTHER        = 12,
+	EXPENSES_INVALID      = 0xFF,
+};
 
 /**
  * Common return value for all commands. Wraps the cost and
@@ -370,25 +386,38 @@
 	Money cost;       ///< The cost of this action
 	StringID message; ///< Warning message for when success is unset
 	bool success;     ///< Whether the comment went fine up to this moment
-
+	ExpensesType expense_type;
 public:
 	/**
 	 * Creates a command cost return with no cost and no error
 	 */
-	CommandCost() : cost(0), message(INVALID_STRING_ID), success(true) {}
+	CommandCost() : cost(0), message(INVALID_STRING_ID), success(true),expense_type(EXPENSES_INVALID) {}
 
 	/**
 	 * Creates a command return value the is failed with the given message
 	 */
-	CommandCost(StringID msg) : cost(0), message(msg), success(false) {}
+	CommandCost(StringID msg) : cost(0), message(msg), success(false),expense_type(EXPENSES_INVALID) {}
 
 	/**
+	 * Creates a command cost return with given expense type
+	 * @param ex_t the expense type
+	 */
+	CommandCost(ExpensesType ex_t) : cost(0), message(INVALID_STRING_ID), success(true),expense_type(ex_t) {}
+	
+	/**
 	 * Creates a command return value with the given start cost
 	 * @param cst the initial cost of this command
 	 */
-	CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true) {}
+	//CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true),expense_type(EXPENSES_INVALID) {}
 
 	/**
+	 * Creates a command return value with the given start cost and expense type
+	 * @param cst the initial cost of this command
+	 * @param ex_t the expense type
+	 */
+	CommandCost(Money cst,ExpensesType ex_t) : cost(cst), message(INVALID_STRING_ID), success(true),expense_type(ex_t) {}
+	
+	/**
 	 * Adds the cost of the given command return value to this cost.
 	 * Also takes a possible error message when it is set.
 	 * @param ret the command to add the cost of.
@@ -417,6 +446,12 @@
 	Money GetCost() const;
 
 	/**
+	 * The expense type of the cost
+	 * @return the expense type 
+	 */
+	ExpensesType GetExpensesType() const;
+
+	/**
 	 * Sets the global error message *if* this class has one.
 	 */
 	void SetGlobalErrorMessage() const;
@@ -434,7 +469,6 @@
 	bool Failed() const;
 };
 
-
 typedef void DrawTileProc(TileInfo *ti);
 typedef uint GetSlopeZProc(TileIndex tile, uint x, uint y);
 typedef CommandCost ClearTileProc(TileIndex tile, byte flags);
@@ -574,23 +608,6 @@
 	WC_VEHICLE_TIMETABLE,
 };
 
-
-enum ExpensesType {
-	EXPENSES_CONSTRUCTION =  0,
-	EXPENSES_NEW_VEHICLES =  1,
-	EXPENSES_TRAIN_RUN    =  2,
-	EXPENSES_ROADVEH_RUN  =  3,
-	EXPENSES_AIRCRAFT_RUN =  4,
-	EXPENSES_SHIP_RUN     =  5,
-	EXPENSES_PROPERTY     =  6,
-	EXPENSES_TRAIN_INC    =  7,
-	EXPENSES_ROADVEH_INC  =  8,
-	EXPENSES_AIRCRAFT_INC =  9,
-	EXPENSES_SHIP_INC     = 10,
-	EXPENSES_LOAN_INT     = 11,
-	EXPENSES_OTHER        = 12,
-};
-
 enum {
 	MAX_LANG = 64,
 };
Index: src/landscape.cpp
===================================================================
--- src/landscape.cpp	(revision 10908)
+++ src/landscape.cpp	(working copy)
@@ -413,9 +413,7 @@
  * @param p2 unused
  */
 CommandCost CmdLandscapeClear(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
-{
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
+{	
 	return _tile_type_procs[GetTileType(tile)]->clear_tile_proc(tile, flags);
 }
 
@@ -427,7 +425,8 @@
  */
 CommandCost CmdClearArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost, ret, money;
+	CommandCost ret, money;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int ex;
 	int ey;
 	int sx, sy;
@@ -436,8 +435,6 @@
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* make sure sx,sy are smaller than ex,ey */
 	ex = TileX(tile);
 	ey = TileY(tile);
Index: src/roadveh_cmd.cpp
===================================================================
--- src/roadveh_cmd.cpp	(revision 10908)
+++ src/roadveh_cmd.cpp	(working copy)
@@ -120,7 +120,7 @@
 
 static CommandCost EstimateRoadVehCost(EngineID engine_type)
 {
-	return CommandCost(((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5);
+	return CommandCost(((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5,EXPENSES_NEW_VEHICLES);
 }
 
 byte GetRoadVehLength(const Vehicle *v)
@@ -167,8 +167,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_ROAD, _current_player)) return_cmd_error(STR_ROAD_VEHICLE_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	cost = EstimateRoadVehCost(p1);
 	if (flags & DC_QUERY_COST) return cost;
 
@@ -359,8 +357,6 @@
 
 	if (v->type != VEH_ROAD || !CheckOwnership(v->owner)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!CheckRoadVehInDepotStopped(v)) {
 		return_cmd_error(STR_9013_MUST_BE_STOPPED_INSIDE);
 	}
@@ -375,7 +371,7 @@
 		delete v;
 	}
 
-	return CommandCost(-v->value);
+	return CommandCost(-v->value,EXPENSES_NEW_VEHICLES);
 }
 
 struct RoadFindDepotData {
@@ -1898,7 +1894,7 @@
 
 void OnNewDay_RoadVeh(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 
 	if (!IsRoadVehFront(v)) return;
 
@@ -1978,12 +1974,11 @@
 		}
 	}
 
-	cost = RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364;
+	cost = CommandCost(RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364,EXPENSES_ROADVEH_RUN);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	InvalidateWindowClasses(WC_ROADVEH_LIST);
@@ -2016,7 +2011,7 @@
 CommandCost CmdRefitRoadVeh(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 	CargoID new_cid = GB(p2, 0, 8);
 	byte new_subtype = GB(p2, 8, 8);
 	bool only_this = HASBIT(p2, 16);
@@ -2032,8 +2027,6 @@
 
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-
 	for (; v != NULL; v = v->next) {
 		/* XXX: We refit all the attached wagons en-masse if they can be
 		 * refitted. This is how TTDPatch does it.  TODO: Have some nice
Index: src/vehicle.cpp
===================================================================
--- src/vehicle.cpp	(revision 10908)
+++ src/vehicle.cpp	(working copy)
@@ -735,18 +735,28 @@
 CommandCost GetRefitCost(EngineID engine_type)
 {
 	CommandCost base_cost;
-
+	ExpensesType expense_type;
 	switch (GetEngine(engine_type)->type) {
-		case VEH_SHIP: base_cost.AddCost(_price.ship_base); break;
-		case VEH_ROAD: base_cost.AddCost(_price.roadveh_base); break;
-		case VEH_AIRCRAFT: base_cost.AddCost(_price.aircraft_base); break;
+		case VEH_SHIP: 
+			base_cost.AddCost(_price.ship_base); 
+			expense_type = EXPENSES_SHIP_RUN;
+			break;
+		case VEH_ROAD: 
+			base_cost.AddCost(_price.roadveh_base); 
+			expense_type = EXPENSES_ROADVEH_RUN;
+			break;
+		case VEH_AIRCRAFT: 
+			base_cost.AddCost(_price.aircraft_base); 
+			expense_type = EXPENSES_AIRCRAFT_RUN;
+			break;
 		case VEH_TRAIN:
 			base_cost.AddCost(2 * ((RailVehInfo(engine_type)->railveh_type == RAILVEH_WAGON) ?
 							 _price.build_railwagon : _price.build_railvehicle));
+			expense_type = EXPENSES_TRAIN_RUN;
 			break;
 		default: NOT_REACHED(); break;
 	}
-	return CommandCost((EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10);
+	return CommandCost((EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10,expense_type);
 }
 
 static void DoDrawVehicle(const Vehicle *v)
@@ -1720,8 +1730,8 @@
 			 * Because of this, we can't estimate costs due to wagon removal and we will have to always return 0 and pay manually
 			 * Since we pay after each vehicle is replaced and MaybeReplaceVehicle() check if the player got enough money
 			 * we should never reach a condition where the player will end up with negative money from doing this */
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 			SubtractMoneyFromPlayer(ret);
+
 		}
 	}
 
@@ -1749,7 +1759,7 @@
 {
 	Vehicle *v_front, *v;
 	Vehicle *w_front, *w, *w_rear;
-	CommandCost cost, total_cost;
+	CommandCost cost, total_cost(EXPENSES_NEW_VEHICLES);
 	uint32 build_argument = 2;
 
 	if (!IsValidVehicleID(p1)) return CMD_ERROR;
@@ -1895,9 +1905,6 @@
 		return CMD_ERROR;
 	}
 
-	/* Set the expense type last as refitting will make the cost go towards
-	 * running costs... */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	return total_cost;
 }
 
@@ -3112,7 +3119,6 @@
 	current_order.type = OT_LOADING;
 	GetStation(this->last_station_visited)->loading_vehicles.push_back(this);
 
-	SET_EXPENSES_TYPE(this->GetExpenseType(true));
 	VehiclePayment(this);
 
 	InvalidateWindow(this->GetVehicleListWindowClass(), this->owner);
Index: src/misc_cmd.cpp
===================================================================
--- src/misc_cmd.cpp	(revision 10908)
+++ src/misc_cmd.cpp	(working copy)
@@ -154,7 +154,7 @@
 		InvalidatePlayerWindows(p);
 	}
 
-	return CommandCost();
+	return CommandCost(EXPENSES_OTHER);
 }
 
 /** Decrease the loan of your company.
@@ -326,8 +326,7 @@
 #ifndef _DEBUG
 	if (_networking) return CMD_ERROR;
 #endif
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-	return CommandCost(-(Money)p1);
+	return CommandCost(-(Money)p1,EXPENSES_OTHER);
 }
 
 /** Transfer funds (money) from one player to another.
@@ -342,10 +341,8 @@
 CommandCost CmdGiveMoney(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	const Player *p = GetPlayer(_current_player);
-	CommandCost amount(min((Money)p1, (Money)20000000LL));
+	CommandCost amount(min((Money)p1, (Money)20000000LL),EXPENSES_OTHER);
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* You can only transfer funds that is in excess of your loan */
 	if (p->player_money - p->current_loan < amount.GetCost() || amount.GetCost() <= 0) return CMD_ERROR;
 	if (!_networking || !IsValidPlayer((PlayerID)p2)) return CMD_ERROR;
@@ -354,7 +351,7 @@
 		/* Add money to player */
 		PlayerID old_cp = _current_player;
 		_current_player = (PlayerID)p2;
-		SubtractMoneyFromPlayer(CommandCost(-amount.GetCost()));
+		SubtractMoneyFromPlayer( CommandCost( -amount.GetCost(), EXPENSES_OTHER ) );
 		_current_player = old_cp;
 	}
 
Index: src/industry_cmd.cpp
===================================================================
--- src/industry_cmd.cpp	(revision 10908)
+++ src/industry_cmd.cpp	(working copy)
@@ -393,7 +393,7 @@
 	}
 
 	if (flags & DC_EXEC) delete i;
-	return CommandCost();
+	return CommandCost(EXPENSES_CONSTRUCTION);
 }
 
 static void TransportIndustryGoods(TileIndex tile)
@@ -1540,8 +1540,6 @@
 	const IndustryTileTable *it;
 	const IndustrySpec *indspec;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	indspec = GetIndustrySpec(p1);
 
 	/* Check if the to-be built/founded industry is available for this climate. */
@@ -1586,7 +1584,7 @@
 		if (CreateNewIndustryHelper(tile, p1, flags, indspec, num) == NULL) return CMD_ERROR;
 	}
 
-	return CommandCost(indspec->GetConstructionCost());
+	return CommandCost(indspec->GetConstructionCost(),EXPENSES_OTHER);
 }
 
 
Index: src/autoreplace_cmd.cpp
===================================================================
--- src/autoreplace_cmd.cpp	(revision 10908)
+++ src/autoreplace_cmd.cpp	(working copy)
@@ -158,12 +158,10 @@
 	/* We give the player a loan of the same amount as the sell value.
 	 * This is needed in case he needs the income from the sale to build the new vehicle.
 	 * We take it back if building fails or when we really sell the old engine */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	SubtractMoneyFromPlayer(sell_value);
 
 	cost = DoCommand(old_v->tile, new_engine_type, 3, flags, GetCmdBuildVeh(old_v));
 	if (CmdFailed(cost)) {
-		SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 		/* Take back the money we just gave the player */
 		sell_value.MultiplyCost(-1);
 		SubtractMoneyFromPlayer(sell_value);
@@ -259,7 +257,7 @@
 		/* Ensure that the player will not end up having negative money while autoreplacing
 		 * This is needed because the only other check is done after the income from selling the old vehicle is substracted from the cost */
 		if (CmdFailed(tmp_move) || p->player_money < (cost.GetCost() + total_cost)) {
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+			
 			/* Pay back the loan */
 			sell_value.MultiplyCost(-1);
 			SubtractMoneyFromPlayer(sell_value);
@@ -269,7 +267,6 @@
 
 	/* Take back the money we just gave the player just before building the vehicle
 	 * The player will get the same amount now that the sale actually takes place */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	sell_value.MultiplyCost(-1);
 	SubtractMoneyFromPlayer(sell_value);
 
@@ -329,7 +326,7 @@
 	v->leave_depot_instantly = false;
 
 	for (;;) {
-		cost = CommandCost();
+		cost = CommandCost(EXPENSES_NEW_VEHICLES);
 		w = v;
 		do {
 			if (w->type == VEH_TRAIN && IsMultiheaded(w) && !IsTrainEngine(w)) {
Index: src/aircraft_cmd.cpp
===================================================================
--- src/aircraft_cmd.cpp	(revision 10908)
+++ src/aircraft_cmd.cpp	(working copy)
@@ -231,7 +231,7 @@
 
 static CommandCost EstimateAircraftCost(EngineID engine, const AircraftVehicleInfo *avi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5);
+	return CommandCost(GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5,EXPENSES_NEW_VEHICLES);
 }
 
 
@@ -279,7 +279,7 @@
 
 	if (!IsHangarTile(tile) || !IsTileOwner(tile, _current_player)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+	
 
 	/* Prevent building aircraft types at places which can't handle them */
 	if (!IsAircraftBuildableAtStation(p1, tile)) return CMD_ERROR;
@@ -487,15 +487,13 @@
 	if (v->type != VEH_AIRCRAFT || !CheckOwnership(v->owner)) return CMD_ERROR;
 	if (!IsAircraftInHangarStopped(v)) return_cmd_error(STR_A01B_AIRCRAFT_MUST_BE_STOPPED);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (flags & DC_EXEC) {
 		// Invalidate depot
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
 		DoDeleteAircraft(v);
 	}
 
-	return CommandCost(-v->value);
+	return CommandCost(-v->value,EXPENSES_NEW_VEHICLES);
 }
 
 /** Start/Stop an aircraft.
@@ -640,8 +638,6 @@
 	CargoID new_cid = GB(p2, 0, 8);
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
-
 	/* Check the refit capacity callback */
 	uint16 callback = CALLBACK_FAILED;
 	if (HASBIT(EngInfo(v->engine_type)->callbackmask, CBM_REFIT_CAPACITY)) {
@@ -741,11 +737,10 @@
 
 	if (v->vehstatus & VS_STOPPED) return;
 
-	CommandCost cost = CommandCost(GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364);
+	CommandCost cost = CommandCost(GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364,EXPENSES_AIRCRAFT_RUN);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
 	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
