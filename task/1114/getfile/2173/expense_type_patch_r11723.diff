=== src/rail_cmd.cpp
==================================================================
--- src/rail_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/rail_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -287,7 +287,7 @@
 	   ) return_cmd_error(STR_1000_LAND_SLOPED_IN_WRONG_DIRECTION);
 
 	Foundation f_old = GetRailFoundation(tileh, existing);
-	return CommandCost(f_new != f_old ? _price.terraform : (Money)0);
+	return CommandCost(EXPENSES_CONSTRUCTION, f_new != f_old ? _price.terraform : (Money)0);
 }
 
 /* Validate functions for rail building */
@@ -305,7 +305,7 @@
 	RailType railtype;
 	Track track;
 	TrackBits trackbit;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (!ValParamRailtype(p1) || !ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
@@ -315,8 +315,6 @@
 	tileh = GetTileSlope(tile, NULL);
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_RAILWAY:
 			if (!CheckTrackCombination(tile, trackbit, flags) ||
@@ -437,14 +435,12 @@
 {
 	Track track = (Track)p2;
 	TrackBits trackbit;
-	CommandCost cost(_price.remove_rail);
+	CommandCost cost(EXPENSES_CONSTRUCTION, _price.remove_rail );
 	bool crossing = false;
 
 	if (!ValParamTrackOrientation((Track)p2)) return CMD_ERROR;
 	trackbit = TrackToTrackBits(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileType(tile)) {
 		case MP_ROAD: {
 			if (!IsLevelCrossing(tile) ||
@@ -623,7 +619,7 @@
  */
 static CommandCost CmdRailTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	Track track = (Track)GB(p2, 4, 3);
 	Trackdir trackdir;
 	byte mode = HasBit(p2, 7);
@@ -635,8 +631,6 @@
 	end_tile = p1;
 	trackdir = TrackToTrackdir(track);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (CmdFailed(ValidateAutoDrag(&trackdir, tile, end_tile))) return CMD_ERROR;
 
 	if (flags & DC_EXEC) SndPlayTileFx(SND_20_SPLAT_2, tile);
@@ -705,11 +699,9 @@
  */
 CommandCost CmdBuildTrainDepot(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* check railtype and valid direction for depot (0 through 3), 4 in total */
 	if (!ValParamRailtype(p1)) return CMD_ERROR;
 
@@ -805,21 +797,19 @@
 	/* you can not convert a signal if no signal is on track */
 	if (convert_signal && !HasSignalOnTrack(tile, track)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!HasSignalOnTrack(tile, track)) {
 		/* build new signals */
-		cost = CommandCost(_price.build_signals);
+		cost = CommandCost(EXPENSES_CONSTRUCTION, _price.build_signals);
 	} else {
 		if (p2 != 0 && sigvar != GetSignalVariant(tile, track)) {
 			/* convert signals <-> semaphores */
-			cost = CommandCost(_price.build_signals + _price.remove_signals);
+			cost = CommandCost(EXPENSES_CONSTRUCTION, _price.build_signals + _price.remove_signals);
 
 		} else if (convert_signal) {
 			/* convert button pressed */
 			if (ctrl_pressed || GetSignalVariant(tile, track) != sigvar) {
 				/* convert electric <-> semaphore */
-				cost = CommandCost(_price.build_signals + _price.remove_signals);
+				cost = CommandCost(EXPENSES_CONSTRUCTION, _price.build_signals + _price.remove_signals);
 			} else {
 				/* it is free to change signal type: normal-pre-exit-combo */
 				cost = CommandCost();
@@ -955,7 +945,7 @@
  */
 static CommandCost CmdSignalTrackHelper(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost ret, total_cost;
+	CommandCost ret, total_cost(EXPENSES_CONSTRUCTION);
 	int signal_ctr;
 	byte signals;
 	bool error = true;
@@ -976,8 +966,6 @@
 
 	if (!IsTileType(tile, MP_RAILWAY)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* for vertical/horizontal tracks, double the given signals density
 	 * since the original amount will be too dense (shorter tracks) */
 	signal_density *= 2;
@@ -1100,8 +1088,6 @@
 	/* Only water can remove signals from anyone */
 	if (_current_player != OWNER_WATER && !CheckTileOwnership(tile)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do it? */
 	if (flags & DC_EXEC) {
 		SetPresentSignals(tile, GetPresentSignals(tile) & ~SignalOnTrack(track));
@@ -1119,7 +1105,7 @@
 		MarkTileDirtyByTile(tile);
 	}
 
-	return CommandCost(_price.remove_signals);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_signals);
 }
 
 /** Remove signals on a stretch of track.
@@ -1163,7 +1149,7 @@
  */
 CommandCost CmdConvertRail(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 
 	if (!ValParamRailtype(p2)) return CMD_ERROR;
 	if (p1 >= MapSize()) return CMD_ERROR;
@@ -1179,8 +1165,6 @@
 	if (ex < sx) Swap(ex, sx);
 	if (ey < sy) Swap(ey, sy);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	_error_message = STR_1005_NO_SUITABLE_RAILROAD_TRACK; // by default, there is no track to convert
 
 	for (uint x = sx; x <= ex; ++x) {
@@ -1330,12 +1314,12 @@
 		YapfNotifyTrackLayoutChange(tile, TrackdirToTrack(DiagdirToDiagTrackdir(dir)));
 	}
 
-	return CommandCost(_price.remove_train_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_train_depot);
 }
 
 static CommandCost ClearTile_Track(TileIndex tile, byte flags)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	if (flags & DC_AUTO) {
@@ -2433,7 +2417,7 @@
 		case TRACK_BIT_UPPER: track_corner = CORNER_N; break;
 
 		/* Surface slope must not be changed */
-		default: return (((z_old != z_new) || (tileh_old != tileh_new)) ? CMD_ERROR : _price.terraform);
+		default: return (((z_old != z_new) || (tileh_old != tileh_new)) ? CMD_ERROR : CommandCost(EXPENSES_CONSTRUCTION, _price.terraform));
 	}
 
 	/* The height of the track_corner must not be changed. The rest ensures GetRailFoundation() already. */
@@ -2441,7 +2425,7 @@
 	z_new += GetSlopeZInCorner((Slope)(tileh_new & ~SLOPE_HALFTILE_MASK), track_corner);
 	if (z_old != z_new) return CMD_ERROR;
 
-	CommandCost cost = CommandCost(_price.terraform);
+	CommandCost cost = CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 	/* Make the ground dirty, if surface slope has changed */
 	if (tileh_old != tileh_new) {
 		if (GetRailGroundType(tile) == RAIL_GROUND_WATER) cost.AddCost(_price.clear_water);
@@ -2488,7 +2472,7 @@
 		if ((flags & DC_EXEC) != 0) SetRailGroundType(tile, RAIL_GROUND_BARREN);
 
 		/* allow terraforming */
-		return (was_water ? CommandCost(_price.clear_water) : CommandCost());
+		return (was_water ? CommandCost(EXPENSES_CONSTRUCTION, _price.clear_water) : CommandCost());
 	} else {
 		if (_patches.build_on_slopes && AutoslopeEnabled()) {
 			switch (GetRailTileType(tile)) {
@@ -2499,7 +2483,7 @@
 				}
 
 				case RAIL_TILE_DEPOT:
-					if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRailDepotDirection(tile))) return _price.terraform;
+					if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRailDepotDirection(tile))) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 					break;
 
 				default: NOT_REACHED();
=== src/station_cmd.cpp
==================================================================
--- src/station_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/station_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -705,7 +705,7 @@
  */
 CommandCost CheckFlatLandBelow(TileIndex tile, uint w, uint h, uint flags, uint invalid_dirs, StationID *station, bool check_clear = true)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int allowed_z = -1;
 
 	BEGIN_TILE_LOOP(tile_cur, w, h, tile) {
@@ -902,8 +902,6 @@
 	int w_org, h_org;
 	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Does the authority allow this? */
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile_org)) return CMD_ERROR;
 	if (!ValParamRailtype(p2 & 0xF)) return CMD_ERROR;
@@ -935,7 +933,7 @@
 	 * https://sourceforge.net/tracker/index.php?func=detail&aid=1029064&group_id=103924&atid=636365 */
 	ret = CheckFlatLandBelow(tile_org, w_org, h_org, flags & ~DC_EXEC, 5 << axis, _patches.nonuniform_stations ? &est : NULL);
 	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len);
+	CommandCost cost(EXPENSES_CONSTRUCTION, ret.GetCost() + (numtracks * _price.train_station_track + _price.train_station_length) * plat_len);
 
 	Station *st = NULL;
 	bool check_surrounding = true;
@@ -1175,8 +1173,6 @@
 	int size_x = ex - sx + 1;
 	int size_y = ey - sy + 1;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Do the action for every tile into the area */
 	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
 		/* Make sure the specified tile is a railroad station */
@@ -1233,7 +1229,7 @@
 	/* If we've not removed any tiles, give an error */
 	if (quantity == 0) return CMD_ERROR;
 
-	return CommandCost(_price.remove_rail_station * quantity);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_rail_station * quantity);
 }
 
 
@@ -1254,7 +1250,7 @@
 
 	assert(w != 0 && h != 0);
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	/* clear all areas of the station */
 	do {
 		int w_bak = w;
@@ -1345,8 +1341,6 @@
 	/* Road bits in the wrong direction */
 	if (build_over_road && (GetAllRoadBits(tile) & ((Axis)p1 == AXIS_X ? ROAD_Y : ROAD_X)) != 0) return_cmd_error(STR_DRIVE_THROUGH_ERROR_DIRECTION);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!(flags & DC_NO_TOWN_RATING) && !CheckIfAuthorityAllows(tile)) return CMD_ERROR;
 
 	CommandCost cost;
@@ -1505,7 +1499,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost((is_truck) ? _price.remove_truck_station : _price.remove_bus_station);
+	return CommandCost(EXPENSES_CONSTRUCTION, (is_truck) ? _price.remove_truck_station : _price.remove_bus_station);
 }
 
 /** Remove a bus or truck stop
@@ -1644,8 +1638,6 @@
 {
 	bool airport_upgrade = true;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Check if a valid, buildable airport was chosen for construction */
 	if (p1 > lengthof(_airport_sections) || !HasBit(GetValidAirports(), p1)) return CMD_ERROR;
 
@@ -1672,9 +1664,8 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost ret = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
-	if (CmdFailed(ret)) return ret;
-	CommandCost cost(ret.GetCost());
+	CommandCost cost = CheckFlatLandBelow(tile, w, h, flags, 0, NULL);
+	if (CmdFailed(cost)) return cost;
 
 	Station *st = NULL;
 
@@ -1779,7 +1770,7 @@
 	int w = afc->size_x;
 	int h = afc->size_y;
 
-	CommandCost cost(w * h * _price.remove_airport);
+	CommandCost cost(EXPENSES_CONSTRUCTION, w * h * _price.remove_airport);
 
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
@@ -1825,8 +1816,6 @@
  */
 CommandCost CmdBuildBuoy(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!IsWaterTile(tile) || tile == 0) return_cmd_error(STR_304B_SITE_UNSUITABLE);
 	if (MayHaveBridgeAbove(tile) && IsBridgeAbove(tile)) return_cmd_error(STR_5007_MUST_DEMOLISH_BRIDGE_FIRST);
 
@@ -1863,7 +1852,7 @@
 		st_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_dock);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.build_dock);
 }
 
 /**
@@ -1917,7 +1906,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_truck_station);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_truck_station);
 }
 
 static const TileIndexDiffC _dock_tileoffs_chkaround[] = {
@@ -1939,8 +1928,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection direction;
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: direction = DIAGDIR_NE; break;
@@ -2032,7 +2019,7 @@
 		/* success, so don't delete the new station */
 		st_auto_delete.Detach();
 	}
-	return CommandCost(_price.build_dock);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.build_dock);
 }
 
 static CommandCost RemoveDock(Station *st, uint32 flags)
@@ -2062,7 +2049,7 @@
 		DeleteStationIfEmpty(st);
 	}
 
-	return CommandCost(_price.remove_dock);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_dock);
 }
 
 #include "table/station_land.h"
@@ -2980,11 +2967,11 @@
 					DiagDirection direction = AxisToDiagDir(GetRailStationAxis(tile));
 					if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, direction)) break;
 					if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, ReverseDiagDir(direction))) break;
-					return _price.terraform;
+					return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 				}
 
 				case STATION_AIRPORT:
-					return _price.terraform;
+					return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 
 				case STATION_TRUCK:
 				case STATION_BUS: {
@@ -2993,7 +2980,7 @@
 					if (IsDriveThroughStopTile(tile)) {
 						if (!AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, ReverseDiagDir(direction))) break;
 					}
-					return _price.terraform;
+					return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 				}
 
 				default: break;
=== src/town_cmd.cpp
==================================================================
--- src/town_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/town_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -502,7 +502,7 @@
 static CommandCost ClearTile_Town(TileIndex tile, byte flags)
 {
 	int rating;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	Town *t;
 	HouseSpec *hs = GetHouseSpecs(GetHouseType(tile));
 
@@ -1496,8 +1496,6 @@
 	if (_game_mode != GM_EDITOR) return CMD_ERROR;
 	if (p2 > TSM_CITY) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* Check if too close to the edge of map */
 	if (DistanceFromEdge(tile) < 12)
 		return_cmd_error(STR_0237_TOO_CLOSE_TO_EDGE_OF_MAP);
@@ -2097,7 +2095,6 @@
  */
 CommandCost CmdDoTownAction(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
 	Town *t;
 
 	if (!IsValidTownID(p1) || p2 > lengthof(_town_action_proc)) return CMD_ERROR;
@@ -2106,10 +2103,8 @@
 
 	if (!HasBit(GetMaskOfTownActions(NULL, _current_player, t), p2)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
+	CommandCost cost(EXPENSES_OTHER, (_price.build_industry >> 8) * _town_action_costs[p2]);
 
-	cost.AddCost((_price.build_industry >> 8) * _town_action_costs[p2]);
-
 	if (flags & DC_EXEC) {
 		_town_action_proc[p2](t);
 		InvalidateWindow(WC_TOWN_AUTHORITY, p1);
@@ -2364,7 +2359,7 @@
 
 		/* Here we differ from TTDP by checking TILE_NOT_SLOPED */
 		if (((hs->building_flags & TILE_NOT_SLOPED) == 0) && !IsSteepSlope(tileh_new) &&
-			(GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new))) return _price.terraform;
+			(GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new))) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 	}
 
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
=== src/ship_cmd.cpp
==================================================================
--- src/ship_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/ship_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -166,7 +166,7 @@
 
 void OnNewDay_Ship(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 
 	if ((++v->day_counter & 7) == 0)
 		DecreaseVehicleValue(v);
@@ -182,8 +182,7 @@
 	cost.AddCost(GetVehicleProperty(v, 0x0F, ShipVehInfo(v->engine_type)->running_cost) * _price.ship_running / 364);
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	/* we need this for the profit */
@@ -397,7 +396,7 @@
 
 static CommandCost EstimateShipCost(EngineID engine_type)
 {
-	return CommandCost(GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5);
+	return CommandCost(EXPENSES_NEW_VEHICLES, GetEngineProperty(engine_type, 0x0A, ShipVehInfo(engine_type)->base_cost) * (_price.ship_base >> 3) >> 5);
 }
 
 static void ShipArrivesAt(const Vehicle* v, Station* st)
@@ -811,8 +810,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_SHIP, _current_player)) return_cmd_error(STR_SHIP_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	value = EstimateShipCost(p1);
 	if (flags & DC_QUERY_COST) return value;
 
@@ -908,13 +905,11 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!v->IsStoppedInDepot()) {
 		return_cmd_error(STR_980B_SHIP_MUST_BE_STOPPED_IN);
 	}
 
-	CommandCost ret(-v->value);
+	CommandCost ret(EXPENSES_NEW_VEHICLES, -v->value);
 
 	if (flags & DC_EXEC) {
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
@@ -1057,7 +1052,7 @@
 CommandCost CmdRefitShip(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_SHIP_RUN);
 	CargoID new_cid = GB(p2, 0, 8); //gets the cargo number
 	byte new_subtype = GB(p2, 8, 8);
 	uint16 capacity = CALLBACK_FAILED;
@@ -1074,8 +1069,6 @@
 	if (!ShipVehInfo(v->engine_type)->refittable) return CMD_ERROR;
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_SHIP_RUN);
-
 	/* Check the refit capacity callback */
 	if (HasBit(EngInfo(v->engine_type)->callbackmask, CBM_VEHICLE_REFIT_CAPACITY)) {
 		/* Back up the existing cargo type */
=== src/waypoint.cpp
==================================================================
--- src/waypoint.cpp	(/openttd/trunk)	(revision 732)
+++ src/waypoint.cpp	(/openttd/commandcost)	(revision 732)
@@ -163,8 +163,6 @@
 	Slope tileh;
 	Axis axis;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* if custom gfx are used, make sure it is within bounds */
 	if (p1 >= GetNumCustomStations(STAT_CLASS_WAYP)) return CMD_ERROR;
 
@@ -247,7 +245,7 @@
 		wp_auto_delete.Detach();
 	}
 
-	return CommandCost(_price.build_train_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.build_train_depot);
 }
 
 /**
@@ -299,7 +297,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 	}
 
-	return CommandCost(_price.remove_train_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_train_depot);
 }
 
 /**
@@ -312,7 +310,6 @@
  */
 CommandCost CmdRemoveTrainWaypoint(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 	return RemoveTrainWaypoint(tile, flags, true);
 }
 
=== src/train_cmd.cpp
==================================================================
--- src/train_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/train_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -517,10 +517,8 @@
 
 static CommandCost CmdBuildRailWagon(EngineID engine, TileIndex tile, uint32 flags)
 {
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(engine);
-	CommandCost value((GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8);
+	CommandCost value(EXPENSES_NEW_VEHICLES, (GetEngineProperty(engine, 0x17, rvi->base_cost) * _price.build_railwagon) >> 8);
 
 	uint num_vehicles = 1 + CountArticulatedParts(engine, false);
 
@@ -606,7 +604,7 @@
 		}
 	}
 
-	return CommandCost(value);
+	return value;
 }
 
 /** Move all free vehicles in the depot to the train */
@@ -627,7 +625,7 @@
 
 static CommandCost EstimateTrainCost(EngineID engine, const RailVehicleInfo* rvi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5);
+	return CommandCost(EXPENSES_NEW_VEHICLES, GetEngineProperty(engine, 0x17, rvi->base_cost) * (_price.build_railvehicle >> 3) >> 5);
 }
 
 static void AddRearEngineToMultiheadedTrain(Vehicle* v, Vehicle* u, bool building)
@@ -677,8 +675,6 @@
 		if (!IsTileOwner(tile, _current_player)) return CMD_ERROR;
 	}
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	const RailVehicleInfo *rvi = RailVehInfo(p1);
 
 	/* Check if depot and new engine uses the same kind of tracks */
@@ -1308,8 +1304,6 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	while (IsArticulatedPart(v)) v = v->Previous();
 	Vehicle *first = v->First();
 
@@ -1329,7 +1323,7 @@
 		RebuildVehicleLists();
 	}
 
-	CommandCost cost;
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
 	switch (p2) {
 		case 0: case 2: { /* Delete given wagon */
 			bool switch_engine = false;    // update second wagon to engine?
@@ -1799,9 +1793,7 @@
 	/* Check cargo */
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
-
-	CommandCost cost;
+	CommandCost cost(EXPENSES_TRAIN_RUN);
 	uint num = 0;
 
 	do {
@@ -3480,11 +3472,11 @@
 
 		if ((v->vehstatus & VS_STOPPED) == 0) {
 			/* running costs */
-			CommandCost cost(v->GetRunningCost() / 364);
+			CommandCost cost(EXPENSES_TRAIN_RUN, v->GetRunningCost() / 364);
 
+
 			v->profit_this_year -= cost.GetCost() >> 8;
 
-			SET_EXPENSES_TYPE(EXPENSES_TRAIN_RUN);
 			SubtractMoneyFromPlayerFract(v->owner, cost);
 
 			InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
=== src/road_cmd.cpp
==================================================================
--- src/road_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/road_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -113,8 +113,6 @@
 	 * false if it was a center piece. Affects town ratings drop */
 	bool edge_road;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	RoadType rt = (RoadType)GB(p1, 4, 2);
 	if (!IsValidRoadType(rt)) return CMD_ERROR;
 
@@ -156,7 +154,7 @@
 		/* If it's the last roadtype, just clear the whole tile */
 		if (rts == RoadTypeToRoadTypes(rt)) return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 
-		CommandCost cost;
+		CommandCost cost(EXPENSES_CONSTRUCTION);
 		if (IsTileType(tile, MP_TUNNELBRIDGE)) {
 			TileIndex other_end = IsTunnel(tile) ? GetOtherTunnelEnd(tile) : GetOtherBridgeEnd(tile);
 			/* Pay for *every* tile of the bridge or tunnel */
@@ -181,7 +179,7 @@
 				MarkTileDirtyByTile(tile);
 			}
 		}
-		return CommandCost(cost);
+		return cost;
 	}
 
 	switch (GetRoadTileType(tile)) {
@@ -224,7 +222,7 @@
 					MarkTileDirtyByTile(tile);
 				}
 			}
-			return CommandCost(CountBits(c) * _price.remove_road);
+			return CommandCost(EXPENSES_CONSTRUCTION, CountBits(c) * _price.remove_road);
 		}
 
 		case ROAD_TILE_CROSSING: {
@@ -250,7 +248,7 @@
 				MarkTileDirtyByTile(tile);
 				YapfNotifyTrackLayoutChange(tile, FindFirstTrack(GetTrackBits(tile)));
 			}
-			return CommandCost(_price.remove_road * 2);
+			return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_road * 2);
 		}
 
 		default:
@@ -346,7 +344,7 @@
 		*pieces |= MirrorRoadBits(*pieces);
 
 		if (existing == ROAD_NONE || existing == *pieces) {
-			if (*pieces == ROAD_X || *pieces == ROAD_Y) return _price.terraform;
+			if (*pieces == ROAD_X || *pieces == ROAD_Y) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 		}
 		return CMD_ERROR;
 	}
@@ -358,7 +356,7 @@
 	if (_patches.build_on_slopes && !_is_old_ai_player &&
 			existing == ROAD_NONE && CountBits(*pieces) == 1 &&
 			(_valid_tileh_slopes_road[2][tileh] & *pieces) == ROAD_NONE) {
-		return CommandCost(_price.terraform);
+		return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 	}
 
 	/* no special foundation */
@@ -370,7 +368,7 @@
 
 	/* foundation is used. Whole tile is leveled up */
 	if ((~_valid_tileh_slopes_road[1][tileh] & road_bits) == ROAD_NONE) {
-		return CommandCost(existing != ROAD_NONE ? (Money)0 : _price.terraform);
+		return CommandCost(EXPENSES_CONSTRUCTION, existing != ROAD_NONE ? (Money)0 : _price.terraform);
 	}
 
 	/* Force straight roads. */
@@ -378,7 +376,7 @@
 
 	/* partly leveled up tile, only if there's no road on that tile */
 	if ((existing == ROAD_NONE || existing == *pieces) && (tileh == SLOPE_W || tileh == SLOPE_S || tileh == SLOPE_E || tileh == SLOPE_N)) {
-		if (*pieces == ROAD_X || *pieces == ROAD_Y) return _price.terraform;
+		if (*pieces == ROAD_X || *pieces == ROAD_Y) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 	}
 	return CMD_ERROR;
 }
@@ -393,14 +391,12 @@
  */
 CommandCost CmdBuildRoad(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 	RoadBits existing = ROAD_NONE;
 	RoadBits all_bits = ROAD_NONE;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* Road pieces are max 4 bitset values (NE, NW, SE, SW) and town can only be non-zero
 	 * if a non-player is building the road */
 	if ((IsValidPlayer(_current_player) && p2 != 0) || (_current_player == OWNER_TOWN && !IsValidTownID(p2))) return CMD_ERROR;
@@ -494,7 +490,7 @@
 				MakeRoadCrossing(tile, _current_player, _current_player, _current_player, GetTileOwner(tile), roaddir, GetRailType(tile), RoadTypeToRoadTypes(rt) | ROADTYPES_ROAD, p2);
 				MarkTileDirtyByTile(tile);
 			}
-			return CommandCost(_price.build_road * (rt == ROADTYPE_ROAD ? 2 : 4));
+			return CommandCost(EXPENSES_CONSTRUCTION, _price.build_road * (rt == ROADTYPE_ROAD ? 2 : 4));
 		}
 
 		case MP_STATION:
@@ -606,14 +602,12 @@
 CommandCost CmdBuildLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
 	bool had_bridge = false;
 	bool had_tunnel = false;
 	bool had_success = false;
 	DisallowedRoadDirections drd = DRD_NORTHBOUND;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -693,10 +687,9 @@
 CommandCost CmdRemoveLongRoad(TileIndex end_tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TileIndex start_tile, tile;
-	CommandCost cost, ret, money;
+	CommandCost ret, cost(EXPENSES_CONSTRUCTION);
+	Money money;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (p1 >= MapSize()) return CMD_ERROR;
 
 	start_tile = p1;
@@ -715,7 +708,7 @@
 		p2 ^= IsInsideMM(p2 & 3, 1, 3) ? 3 : 0;
 	}
 
-	money.AddCost(GetAvailableMoneyForCommand());
+	money = GetAvailableMoneyForCommand();
 	tile = start_tile;
 	/* Start tile is the small number. */
 	for (;;) {
@@ -729,8 +722,8 @@
 			ret = DoCommand(tile, rt << 4 | bits, 0, flags & ~DC_EXEC, CMD_REMOVE_ROAD);
 			if (CmdSucceeded(ret)) {
 				if (flags & DC_EXEC) {
-					money.AddCost(-ret.GetCost());
-					if (money.GetCost() < 0) {
+					money -= ret.GetCost();
+					if (money < 0) {
 						_additional_cash_required = DoCommand(end_tile, start_tile, p2, flags & ~DC_EXEC, CMD_REMOVE_LONG_ROAD).GetCost();
 						return cost;
 					}
@@ -763,8 +756,6 @@
 	CommandCost cost;
 	Slope tileh;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	DiagDirection dir = Extract<DiagDirection, 0>(p1);
 	RoadType rt = (RoadType)GB(p1, 2, 2);
 
@@ -810,7 +801,7 @@
 		delete GetDepotByTile(tile);
 	}
 
-	return CommandCost(_price.remove_road_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_road_depot);
 }
 
 static CommandCost ClearTile_Road(TileIndex tile, byte flags)
@@ -826,7 +817,7 @@
 			    !(flags & DC_AUTO)
 				) {
 				RoadTypes rts = GetRoadTypes(tile);
-				CommandCost ret;
+				CommandCost ret(EXPENSES_CONSTRUCTION);
 				for (RoadType rt = ROADTYPE_ROAD; rt < ROADTYPE_END; rt++) {
 					if (HasBit(rts, rt)) {
 						CommandCost tmp_ret = DoCommand(tile, rt << 4 | GetRoadBits(tile, rt), 0, flags, CMD_REMOVE_ROAD);
@@ -841,7 +832,7 @@
 
 		case ROAD_TILE_CROSSING: {
 			RoadTypes rts = GetRoadTypes(tile);
-			CommandCost ret;
+			CommandCost ret(EXPENSES_CONSTRUCTION);
 
 			if (flags & DC_AUTO) return_cmd_error(STR_1801_MUST_REMOVE_ROAD_FIRST);
 
@@ -1422,11 +1413,11 @@
 	if (_patches.build_on_slopes && AutoslopeEnabled()) {
 		switch (GetRoadTileType(tile)) {
 			case ROAD_TILE_CROSSING:
-				if (!IsSteepSlope(tileh_new) && (GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new)) && HasBit(VALID_LEVEL_CROSSING_SLOPES, tileh_new)) return _price.terraform;
+				if (!IsSteepSlope(tileh_new) && (GetTileMaxZ(tile) == z_new + GetSlopeMaxZ(tileh_new)) && HasBit(VALID_LEVEL_CROSSING_SLOPES, tileh_new)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 				break;
 
 			case ROAD_TILE_DEPOT:
-				if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRoadDepotDirection(tile))) return _price.terraform;
+				if (AutoslopeCheckForEntranceEdge(tile, z_new, tileh_new, GetRoadDepotDirection(tile))) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 				break;
 
 			case ROAD_TILE_NORMAL: {
@@ -1444,7 +1435,7 @@
 						z_new += ApplyFoundationToSlope(GetRoadFoundation(tileh_new, bits), &tileh_new);
 
 						/* The surface slope must not be changed */
-						if ((z_old == z_new) && (tileh_old == tileh_new)) return _price.terraform;
+						if ((z_old == z_new) && (tileh_old == tileh_new)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 					}
 				}
 				break;
=== src/command.cpp
==================================================================
--- src/command.cpp	(/openttd/trunk)	(revision 732)
+++ src/command.cpp	(/openttd/commandcost)	(revision 732)
@@ -441,7 +441,7 @@
 	}
 
 	/* Execute the command here. All cost-relevant functions set the expenses type
-	 * themselves with "SET_EXPENSES_TYPE(...);" at the beginning of the function */
+	 * themselves to the cost object at some point */
 	res = proc(tile, flags, p1, p2);
 	if (CmdFailed(res)) {
 		res.SetGlobalErrorMessage();
@@ -454,6 +454,7 @@
 	/* if toplevel, subtract the money. */
 	if (--_docommand_recursive == 0) {
 		SubtractMoneyFromPlayer(res);
+	
 		/* XXX - Old AI hack which doesn't use DoCommandDP; update last build coord of player */
 		if (tile != 0 && IsValidPlayer(_current_player)) {
 			GetPlayer(_current_player)->last_build_coordinate = tile;
@@ -620,7 +621,6 @@
 
 	/* Actually try and execute the command. If no cost-type is given
 	 * use the construction one */
-	_yearly_expenses_type = EXPENSES_CONSTRUCTION;
 	res2 = proc(tile, flags | DC_EXEC, p1, p2);
 
 	/* If notest is on, it means the result of the test can be different than
@@ -633,9 +633,8 @@
 			goto show_error;
 		}
 	}
-
 	SubtractMoneyFromPlayer(res2);
-
+	
 	if (IsLocalPlayer() && _game_mode != GM_EDITOR) {
 		if (res2.GetCost() != 0 && tile != 0) ShowCostOrIncomeAnimation(x, y, GetSlopeZ(x, y), res2.GetCost());
 		if (_additional_cash_required != 0) {
@@ -684,7 +683,7 @@
 	return *this;
 }
 
-CommandCost CommandCost::MultiplyCost(int factor)
+CommandCost CommandCost::MultiplyCost(int64 factor)
 {
 	this->cost *= factor;
 	return *this;
@@ -695,6 +694,11 @@
 	return this->cost;
 }
 
+ExpensesType CommandCost::GetExpensesType() const 
+{
+	return this->expense_type;	
+}
+
 void CommandCost::SetGlobalErrorMessage() const
 {
 	extern StringID _error_message;
=== src/tree_cmd.cpp
==================================================================
--- src/tree_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/tree_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -273,7 +273,7 @@
 CommandCost CmdPlantTree(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	StringID msg = INVALID_STRING_ID;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 	int ex;
 	int ey;
 	int sx, sy, x, y;
@@ -282,8 +282,6 @@
 	/* Check the tree type. It can be random or some valid value within the current climate */
 	if (p1 != (uint)-1 && p1 - _tree_base_by_landscape[_opt.landscape] >= _tree_count_by_landscape[_opt.landscape]) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	// make sure sx,sy are smaller than ex,ey
 	ex = TileX(tile);
 	ey = TileY(tile);
@@ -499,7 +497,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(num * _price.remove_trees);
+	return CommandCost(EXPENSES_CONSTRUCTION, num * _price.remove_trees);
 }
 
 static void GetAcceptedCargo_Trees(TileIndex tile, AcceptedCargo ac)
=== src/tunnelbridge_cmd.cpp
==================================================================
--- src/tunnelbridge_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/tunnelbridge_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -123,7 +123,7 @@
 	valid =
 		BRIDGE_FULL_LEVELED_FOUNDATION | M(SLOPE_N) | M(SLOPE_STEEP_N) |
 		(axis == AXIS_X ? M(SLOPE_E) | M(SLOPE_STEEP_E) : M(SLOPE_W) | M(SLOPE_STEEP_W));
-	if (HasBit(valid, tileh)) return CommandCost(_price.terraform);
+	if (HasBit(valid, tileh)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 
 	return CMD_ERROR;
 }
@@ -138,7 +138,7 @@
 	valid =
 		BRIDGE_FULL_LEVELED_FOUNDATION | M(SLOPE_S) | M(SLOPE_STEEP_S) |
 		(axis == AXIS_X ? M(SLOPE_W) | M(SLOPE_STEEP_W) : M(SLOPE_E) | M(SLOPE_STEEP_E));
-	if (HasBit(valid, tileh)) return CommandCost(_price.terraform);
+	if (HasBit(valid, tileh)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 
 	return CMD_ERROR;
 }
@@ -197,13 +197,12 @@
 	TileIndexDiff delta;
 	uint bridge_len;
 	Axis direction;
-	CommandCost cost, terraformcost, ret;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
+	CommandCost terraformcost, ret;
 	bool allow_on_slopes;
 	bool replace_bridge = false;
 	uint replaced_bridge_type;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* unpack parameters */
 	bridge_type = GB(p2, 0, 8);
 
@@ -458,7 +457,7 @@
 	Slope end_tileh;
 	uint start_z;
 	uint end_z;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	CommandCost ret;
 
 	_build_tunnel_endtile = 0;
@@ -578,8 +577,6 @@
 	Town *t = NULL;
 	TileIndex endtile;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = GetOtherTunnelEnd(tile);
@@ -617,7 +614,7 @@
 		YapfNotifyTrackLayoutChange(tile, track);
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
-	return CommandCost(_price.clear_tunnel * (DistanceManhattan(tile, endtile) + 1));
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_tunnel * (DistanceManhattan(tile, endtile) + 1));
 }
 
 
@@ -628,8 +625,6 @@
 	TileIndex endtile;
 	Town *t = NULL;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (!CheckAllowRemoveTunnelBridge(tile)) return CMD_ERROR;
 
 	endtile = GetOtherBridgeEnd(tile);
@@ -673,7 +668,7 @@
 		YapfNotifyTrackLayoutChange(endtile, track);
 	}
 
-	return CommandCost((DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge);
+	return CommandCost(EXPENSES_CONSTRUCTION, (DistanceManhattan(tile, endtile) + 1) * _price.clear_bridge);
 }
 
 static CommandCost ClearTile_TunnelBridge(TileIndex tile, byte flags)
@@ -1398,7 +1393,7 @@
 			z_new += ApplyFoundationToSlope(GetBridgeFoundation(tileh_new, axis), &tileh_new);
 
 			/* Surface slope remains unchanged? */
-			if ((z_old == z_new) && (tileh_old == tileh_new)) return _price.terraform;
+			if ((z_old == z_new) && (tileh_old == tileh_new)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 		}
 	}
 
=== src/ai/default/default.cpp
==================================================================
--- src/ai/default/default.cpp	(/openttd/trunk)	(revision 732)
+++ src/ai/default/default.cpp	(/openttd/commandcost)	(revision 732)
@@ -1615,7 +1615,7 @@
 static CommandCost AiDoBuildDefaultRailTrack(TileIndex tile, const AiDefaultBlockData* p, RailType railtype, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int i, j, k;
@@ -2604,7 +2604,7 @@
 static CommandCost AiDoBuildDefaultRoadBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	CommandCost ret;
-	CommandCost total_cost;
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	Town *t = NULL;
 	int rating = 0;
 	int roadflag = 0;
@@ -3365,7 +3365,7 @@
 static CommandCost AiDoBuildDefaultAirportBlock(TileIndex tile, const AiDefaultBlockData *p, byte flag)
 {
 	uint32 avail_airports = GetValidAirports();
-	CommandCost total_cost, ret;
+	CommandCost ret,total_cost(EXPENSES_CONSTRUCTION);
 
 	for (; p->mode == 0; p++) {
 		if (!HasBit(avail_airports, p->attr)) return CMD_ERROR;
=== src/clear_cmd.cpp
==================================================================
--- src/clear_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/clear_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -237,11 +237,9 @@
 CommandCost CmdTerraformLand(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	TerraformerState ts;
-	CommandCost total_cost = CommandCost();
+	CommandCost total_cost(EXPENSES_CONSTRUCTION);
 	int direction = (p2 != 0 ? 1 : -1);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	_terraform_err_tile = 0;
 
 	ts.modheight_count = ts.tile_table_count = 0;
@@ -365,14 +363,12 @@
 	int ey;
 	int sx, sy;
 	uint h, curh;
-	CommandCost money;
+	Money money;
 	CommandCost ret;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* remember level height */
 	h = TileHeight(p1);
 
@@ -388,7 +384,7 @@
 	size_x = ex - sx + 1;
 	size_y = ey - sy + 1;
 
-	money.AddCost(GetAvailableMoneyForCommand());
+	money = GetAvailableMoneyForCommand();
 
 	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
 		curh = TileHeight(tile2);
@@ -397,8 +393,8 @@
 			if (CmdFailed(ret)) break;
 
 			if (flags & DC_EXEC) {
-				money.AddCost(-ret.GetCost());
-				if (money.GetCost() < 0) {
+				money -= ret.GetCost();
+				if (money < 0) {
 					_additional_cash_required = ret.GetCost();
 					return cost;
 				}
@@ -425,8 +421,6 @@
 {
 	CommandCost cost;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (IsOwnedLandTile(tile) && IsTileOwner(tile, _current_player)) {
 		return_cmd_error(STR_5807_YOU_ALREADY_OWN_IT);
 	}
@@ -453,15 +447,15 @@
 		&_price.clear_roughland,
 		&_price.clear_roughland,
 	};
-	CommandCost price;
+	Money price = 0;
 
 	if (!IsClearGround(tile, CLEAR_GRASS) || GetClearDensity(tile) != 0) {
-		price.AddCost(*clear_price_table[GetClearGround(tile)]);
+		price = *clear_price_table[GetClearGround(tile)];
 	}
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return price;
+	return CommandCost(EXPENSES_CONSTRUCTION, price);
 }
 
 /** Sell a land area. Actually you only sell one tile, so
@@ -474,7 +468,6 @@
  */
 CommandCost CmdSellLandArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
 
 	if (!IsOwnedLandTile(tile)) return CMD_ERROR;
 	if (!CheckTileOwnership(tile) && _current_player != OWNER_WATER) return CMD_ERROR;
@@ -484,7 +477,7 @@
 
 	if (flags & DC_EXEC) DoClearSquare(tile);
 
-	return CommandCost(- _price.clear_roughland * 2);
+	return CommandCost(EXPENSES_CONSTRUCTION, - _price.clear_roughland * 2);
 }
 
 
=== src/command_type.h
==================================================================
--- src/command_type.h	(/openttd/trunk)	(revision 732)
+++ src/command_type.h	(/openttd/commandcost)	(revision 732)
@@ -14,28 +14,43 @@
  * a possible error message/state together.
  */
 class CommandCost {
+	ExpensesType expense_type; ///< the type of expence as shown on the finances view
 	Money cost;       ///< The cost of this action
 	StringID message; ///< Warning message for when success is unset
 	bool success;     ///< Whether the comment went fine up to this moment
+	
 
 public:
 	/**
 	 * Creates a command cost return with no cost and no error
 	 */
-	CommandCost() : cost(0), message(INVALID_STRING_ID), success(true) {}
+	CommandCost() : expense_type(EXPENSES_INVALID), cost(0), message(INVALID_STRING_ID), success(true) {}
 
 	/**
 	 * Creates a command return value the is failed with the given message
 	 */
-	CommandCost(StringID msg) : cost(0), message(msg), success(false) {}
+	CommandCost(StringID msg) : expense_type(EXPENSES_INVALID), cost(0), message(msg), success(false) {}
 
 	/**
+	 * Creates a command cost with given expense type and start cost of 0
+	 * @param ex_t the expense type
+	 */
+	CommandCost(ExpensesType ex_t) : expense_type(ex_t), cost(0), message(INVALID_STRING_ID), success(true) {}
+
+	/**
 	 * Creates a command return value with the given start cost
 	 * @param cst the initial cost of this command
 	 */
-	CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true) {}
+	//CommandCost(Money cst) : cost(cst), message(INVALID_STRING_ID), success(true) {}
 
 	/**
+	 * Creates a command return value with the given start cost and expense type
+	 * @param ex_t the expense type
+	 * @param cst the initial cost of this command
+	 */
+	CommandCost(ExpensesType ex_t, Money cst) : expense_type(ex_t), cost(cst), message(INVALID_STRING_ID), success(true) {}
+	
+	/**
 	 * Adds the cost of the given command return value to this cost.
 	 * Also takes a possible error message when it is set.
 	 * @param ret the command to add the cost of.
@@ -55,7 +70,7 @@
 	 * @param cost factor to multiply the costs with
 	 * @return this class
 	 */
-	CommandCost MultiplyCost(int factor);
+	CommandCost MultiplyCost(int64 factor);
 
 	/**
 	 * The costs as made up to this moment
@@ -64,6 +79,12 @@
 	Money GetCost() const;
 
 	/**
+	 * The expense type of the cost
+	 * @return the expense type
+	 */
+	ExpensesType GetExpensesType() const;
+
+	/**
 	 * Sets the global error message *if* this class has one.
 	 */
 	void SetGlobalErrorMessage() const;
=== src/strings.cpp
==================================================================
--- src/strings.cpp	(/openttd/trunk)	(revision 732)
+++ src/strings.cpp	(/openttd/commandcost)	(revision 732)
@@ -342,6 +342,9 @@
 	int j;
 
 	number *= spec->rate;
+	
+	
+	
 
 	/* convert from negative */
 	if (number < 0) {
=== src/unmovable_cmd.cpp
==================================================================
--- src/unmovable_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/unmovable_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -37,8 +37,6 @@
 {
 	Player* p = GetPlayer(pid);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	if (flags & DC_EXEC) {
 		TileIndex t = p->location_of_house;
 
@@ -51,7 +49,7 @@
 	}
 
 	/* cost of relocating company is 1% of company value */
-	return CommandCost(CalculateCompanyValue(p) / 100);
+	return CommandCost(EXPENSES_PROPERTY, CalculateCompanyValue(p) / 100);
 }
 
 void UpdateCompanyHQ(Player *p, uint score)
@@ -86,10 +84,8 @@
 CommandCost CmdBuildCompanyHQ(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p = GetPlayer(_current_player);
-	CommandCost cost;
+	CommandCost cost(EXPENSES_PROPERTY);
 
-	SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-
 	cost = CheckFlatLandBelow(tile, 2, 2, flags, 0, NULL);
 	if (CmdFailed(cost)) return cost;
 
@@ -410,7 +406,7 @@
 	if (IsOwnedLand(tile) && CheckTileOwnership(tile)) return CommandCost();
 
 	if (AutoslopeEnabled() && (IsStatue(tile) || IsCompanyHQ(tile))) {
-		if (!IsSteepSlope(tileh_new) && (z_new + GetSlopeMaxZ(tileh_new) == GetTileMaxZ(tile))) return _price.terraform;
+		if (!IsSteepSlope(tileh_new) && (z_new + GetSlopeMaxZ(tileh_new) == GetTileMaxZ(tile))) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 	}
 
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
=== src/water_cmd.cpp
==================================================================
--- src/water_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/water_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -85,10 +85,8 @@
 {
 	TileIndex tile2;
 
-	CommandCost cost, ret;
+	CommandCost ret;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	Axis axis = Extract<Axis, 0>(p1);
 
 	tile2 = tile + (axis == AXIS_X ? TileDiffXY(1, 0) : TileDiffXY(0, 1));
@@ -119,7 +117,7 @@
 		d_auto_delete.Detach();
 	}
 
-	return cost.AddCost(_price.build_ship_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.build_ship_depot);
 }
 
 void MakeWaterOrCanalDependingOnOwner(TileIndex tile, Owner o)
@@ -153,7 +151,7 @@
 		MarkTileDirtyByTile(tile2);
 	}
 
-	return CommandCost(_price.remove_ship_depot);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.remove_ship_depot);
 }
 
 /** build a shiplift */
@@ -194,7 +192,7 @@
 		MarkTileDirtyByTile(tile + delta);
 	}
 
-	return CommandCost(_price.clear_water * 22 >> 3);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_water * 22 >> 3);
 }
 
 static CommandCost RemoveShiplift(TileIndex tile, uint32 flags)
@@ -213,7 +211,7 @@
 		MakeWaterOrCanalDependingOnSurroundings(tile - delta, _current_player);
 	}
 
-	return CommandCost(_price.clear_water * 2);
+	return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_water * 2);
 }
 
 /**
@@ -243,8 +241,6 @@
 {
 	DiagDirection dir;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	switch (GetTileSlope(tile, NULL)) {
 		case SLOPE_SW: dir = DIAGDIR_SW; break;
 		case SLOPE_SE: dir = DIAGDIR_SE; break;
@@ -263,7 +259,7 @@
  */
 CommandCost CmdBuildCanal(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int size_x, size_y;
 	int x;
 	int y;
@@ -278,8 +274,6 @@
 	sx = TileX(p1);
 	sy = TileY(p1);
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	if (x < sx) Swap(x, sx);
 	if (y < sy) Swap(y, sy);
 	size_x = (x - sx) + 1;
@@ -340,7 +334,7 @@
 			if (GetTileOwner(tile) != OWNER_WATER && GetTileOwner(tile) != OWNER_NONE && !CheckTileOwnership(tile)) return CMD_ERROR;
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
-			return CommandCost(_price.clear_water);
+			return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_water);
 
 		case WATER_TILE_COAST: {
 			Slope slope = GetTileSlope(tile, NULL);
@@ -350,9 +344,9 @@
 
 			if (flags & DC_EXEC) DoClearSquare(tile);
 			if (slope == SLOPE_N || slope == SLOPE_E || slope == SLOPE_S || slope == SLOPE_W) {
-				return CommandCost(_price.clear_water);
+				return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_water);
 			} else {
-				return CommandCost(_price.clear_roughland);
+				return CommandCost(EXPENSES_CONSTRUCTION, _price.clear_roughland);
 			}
 		}
 
=== src/economy.cpp
==================================================================
--- src/economy.cpp	(/openttd/trunk)	(revision 732)
+++ src/economy.cpp	(/openttd/commandcost)	(revision 732)
@@ -99,7 +99,6 @@
 Money CalculateCompanyValue(const Player* p)
 {
 	PlayerID owner = p->index;
-	/* Do a little nasty by using CommandCost, so we can use the "overflow" protection of CommandCost */
 	Money value = 0;
 
 	Station *st;
@@ -641,8 +640,8 @@
 
 	FOR_ALL_STATIONS(st) {
 		_current_player = st->owner;
-		SET_EXPENSES_TYPE(EXPENSES_PROPERTY);
-		SubtractMoneyFromPlayer(_price.station_value >> 1);
+		CommandCost cost(EXPENSES_PROPERTY, _price.station_value >> 1);
+		SubtractMoneyFromPlayer(cost);
 	}
 
 	if (!HasBit(1<<0|1<<3|1<<6|1<<9, _cur_month))
@@ -742,12 +741,11 @@
 		if (!p->is_active) continue;
 
 		_current_player = p->index;
-		SET_EXPENSES_TYPE(EXPENSES_LOAN_INT);
+		
 
-		SubtractMoneyFromPlayer(CommandCost((Money)BigMulSU(p->current_loan, interest, 16)));
+		SubtractMoneyFromPlayer(CommandCost(EXPENSES_LOAN_INT, (Money)BigMulSU(p->current_loan, interest, 16)));
 
-		SET_EXPENSES_TYPE(EXPENSES_OTHER);
-		SubtractMoneyFromPlayer(_price.station_value >> 2);
+		SubtractMoneyFromPlayer(CommandCost(EXPENSES_OTHER, _price.station_value >> 2));
 	}
 }
 
@@ -1495,7 +1493,7 @@
 
 	if (route_profit != 0) {
 		front_v->profit_this_year += vehicle_profit;
-		SubtractMoneyFromPlayer(-route_profit);
+		SubtractMoneyFromPlayer( CommandCost(front_v->GetExpenseType(true), -route_profit ) );
 
 		if (IsLocalPlayer() && !PlayVehicleSound(front_v, VSE_LOAD_UNLOAD)) {
 			SndPlayVehicleFx(SND_14_CASHTILL, front_v);
@@ -1804,9 +1802,9 @@
 	PlayerID old_player = _current_player;
 	for (i = 0; i != 4; i++) {
 		if (p->share_owners[i] != PLAYER_SPECTATOR) {
-			SET_EXPENSES_TYPE(EXPENSES_OTHER);
+			
 			_current_player = p->share_owners[i];
-			SubtractMoneyFromPlayer(CommandCost(-value));
+			SubtractMoneyFromPlayer(CommandCost(  EXPENSES_OTHER, -value) );
 		}
 	}
 	_current_player = old_player;
@@ -1828,7 +1826,7 @@
 CommandCost CmdBuyShareInCompany(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Player *p;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_OTHER);
 
 	/* Check if buying shares is allowed (protection against modified clients) */
 	/* Cannot buy own shares */
@@ -1839,8 +1837,6 @@
 	/* Cannot buy shares of non-existent nor bankrupted company */
 	if (!p->is_active) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* Protect new companies from hostile takeovers */
 	if (_cur_year - p->inaugurated_year < 6) return_cmd_error(STR_7080_PROTECTED);
 
@@ -1890,7 +1886,6 @@
 	/* Cannot sell shares of non-existent nor bankrupted company */
 	if (!p->is_active) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 
 	/* Those lines are here for network-protection (clients can be slow) */
 	if (GetAmountOwnedBy(p, _current_player) == 0) return CommandCost();
@@ -1905,7 +1900,7 @@
 		*b = PLAYER_SPECTATOR;
 		InvalidateWindow(WC_COMPANY, p1);
 	}
-	return CommandCost(cost);
+	return CommandCost(EXPENSES_OTHER, cost);
 }
 
 /** Buy up another company.
@@ -1928,7 +1923,6 @@
 	/* Do not allow players to take over themselves */
 	if (pid == _current_player) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
 	p = GetPlayer(pid);
 
 	if (!p->is_ai) return CMD_ERROR;
@@ -1936,7 +1930,7 @@
 	if (flags & DC_EXEC) {
 		DoAcquireCompany(p);
 	}
-	return CommandCost(p->bankrupt_value);
+	return CommandCost(EXPENSES_OTHER, p->bankrupt_value);
 }
 
 /** Prices */
=== src/variables.h
==================================================================
--- src/variables.h	(/openttd/trunk)	(revision 732)
+++ src/variables.h	(/openttd/commandcost)	(revision 732)
@@ -292,7 +292,6 @@
 VARDEF PlayerFace _player_face; ///< for player face storage in openttd.cfg
 
 /* IN/OUT parameters to commands */
-VARDEF byte _yearly_expenses_type;
 VARDEF TileIndex _terraform_err_tile;
 VARDEF TileIndex _build_tunnel_endtile;
 VARDEF bool _generating_world;
@@ -314,8 +313,6 @@
 VARDEF char *_log_file;
 
 
-#define SET_EXPENSES_TYPE(x) _yearly_expenses_type = x;
-
 /* landscape.cpp */
 extern const byte _tileh_to_sprite[32];
 
=== src/players.cpp
==================================================================
--- src/players.cpp	(/openttd/trunk)	(revision 732)
+++ src/players.cpp	(/openttd/commandcost)	(revision 732)
@@ -189,30 +189,32 @@
 
 static void SubtractMoneyFromAnyPlayer(Player *p, CommandCost cost)
 {
-	CommandCost tmp(p->player_money);
-	tmp.AddCost(-cost.GetCost());
-	p->player_money = tmp.GetCost();
+	if(cost.GetCost() == 0) return;
+	assert(cost.GetExpensesType() != EXPENSES_INVALID);
+	
+	if(p->player_money > cost.GetCost())
+	{
+		p->player_money -= cost.GetCost();
+	}
+	else
+	{
+		p->player_money = 0;
+	}
+	p->yearly_expenses[0][cost.GetExpensesType()] += cost.GetCost();
 
-	tmp = CommandCost(p->yearly_expenses[0][_yearly_expenses_type]);
-	tmp.AddCost(cost);
-	p->yearly_expenses[0][_yearly_expenses_type] = tmp.GetCost();
-
 	if (HasBit(1 << EXPENSES_TRAIN_INC    |
 	           1 << EXPENSES_ROADVEH_INC  |
 	           1 << EXPENSES_AIRCRAFT_INC |
-	           1 << EXPENSES_SHIP_INC, _yearly_expenses_type)) {
-		tmp = CommandCost(p->cur_economy.income);
-		tmp.AddCost(-cost.GetCost());
-		p->cur_economy.income = tmp.GetCost();
+	           1 << EXPENSES_SHIP_INC, cost.GetExpensesType())) {
+		
+		p->cur_economy.income += cost.GetCost();
 	} else if (HasBit(1 << EXPENSES_TRAIN_RUN    |
 	                  1 << EXPENSES_ROADVEH_RUN  |
 	                  1 << EXPENSES_AIRCRAFT_RUN |
 	                  1 << EXPENSES_SHIP_RUN     |
 	                  1 << EXPENSES_PROPERTY     |
-	                  1 << EXPENSES_LOAN_INT, _yearly_expenses_type)) {
-		tmp = CommandCost(p->cur_economy.expenses);
-		tmp.AddCost(-cost.GetCost());
-		p->cur_economy.expenses = tmp.GetCost();
+	                  1 << EXPENSES_LOAN_INT, cost.GetExpensesType())) {
+		p->cur_economy.expenses += cost.GetCost();
 	}
 
 	InvalidatePlayerWindows(p);
@@ -234,7 +236,7 @@
 	p->player_money_fraction = m - (byte)cost;
 	cost >>= 8;
 	if (p->player_money_fraction > m) cost++;
-	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cost));
+	if (cost != 0) SubtractMoneyFromAnyPlayer(p, CommandCost(cst.GetExpensesType(), cost));
 }
 
 void GetNameOfOwner(Owner owner, TileIndex tile)
=== src/openttd.h
==================================================================
--- src/openttd.h	(/openttd/trunk)	(revision 732)
+++ src/openttd.h	(/openttd/commandcost)	(revision 732)
@@ -201,7 +201,6 @@
 	int32 top;
 	byte width_1, width_2;
 };
-
 enum {
 	SORT_ASCENDING  = 0,
 	SORT_DESCENDING = 1,
=== src/landscape.cpp
==================================================================
--- src/landscape.cpp	(/openttd/trunk)	(revision 732)
+++ src/landscape.cpp	(/openttd/commandcost)	(revision 732)
@@ -523,9 +523,7 @@
  * @param p2 unused
  */
 CommandCost CmdLandscapeClear(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
-{
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
+{	
 	return _tile_type_procs[GetTileType(tile)]->clear_tile_proc(tile, flags);
 }
 
@@ -537,7 +535,8 @@
  */
 CommandCost CmdClearArea(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
-	CommandCost cost, ret, money;
+	CommandCost ret, money;
+	CommandCost cost(EXPENSES_CONSTRUCTION);
 	int ex;
 	int ey;
 	int sx, sy;
@@ -546,8 +545,6 @@
 
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_CONSTRUCTION);
-
 	/* make sure sx,sy are smaller than ex,ey */
 	ex = TileX(tile);
 	ey = TileY(tile);
=== src/roadveh_cmd.cpp
==================================================================
--- src/roadveh_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/roadveh_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -122,7 +122,7 @@
 
 static CommandCost EstimateRoadVehCost(EngineID engine_type)
 {
-	return CommandCost(((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5);
+	return CommandCost(EXPENSES_NEW_VEHICLES, ((_price.roadveh_base >> 3) * GetEngineProperty(engine_type, 0x11, RoadVehInfo(engine_type)->base_cost)) >> 5);
 }
 
 byte GetRoadVehLength(const Vehicle *v)
@@ -169,8 +169,6 @@
 
 	if (!IsEngineBuildable(p1, VEH_ROAD, _current_player)) return_cmd_error(STR_ROAD_VEHICLE_NOT_AVAILABLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	cost = EstimateRoadVehCost(p1);
 	if (flags & DC_QUERY_COST) return cost;
 
@@ -276,7 +274,7 @@
 		GetPlayer(_current_player)->num_engines[p1]++;
 	}
 
-	return CommandCost(cost);
+	return cost;
 }
 
 /** Start/Stop a road vehicle.
@@ -363,13 +361,11 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
-
 	if (!CheckRoadVehInDepotStopped(v)) {
 		return_cmd_error(STR_9013_MUST_BE_STOPPED_INSIDE);
 	}
 
-	CommandCost ret(-v->value);
+	CommandCost ret(EXPENSES_NEW_VEHICLES, -v->value);
 
 	if (flags & DC_EXEC) {
 		// Invalidate depot
@@ -2003,7 +1999,7 @@
 
 void OnNewDay_RoadVeh(Vehicle *v)
 {
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 
 	if (!IsRoadVehFront(v)) return;
 
@@ -2083,12 +2079,11 @@
 		}
 	}
 
-	cost = RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364;
+	cost = CommandCost(EXPENSES_ROADVEH_RUN, RoadVehInfo(v->engine_type)->running_cost * _price.roadveh_running / 364);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-	SubtractMoneyFromPlayerFract(v->owner, CommandCost(cost));
+	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);
 	InvalidateWindowClasses(WC_ROADVEH_LIST);
@@ -2121,7 +2116,7 @@
 CommandCost CmdRefitRoadVeh(TileIndex tile, uint32 flags, uint32 p1, uint32 p2)
 {
 	Vehicle *v;
-	CommandCost cost;
+	CommandCost cost(EXPENSES_ROADVEH_RUN);
 	CargoID new_cid = GB(p2, 0, 8);
 	byte new_subtype = GB(p2, 8, 8);
 	bool only_this = HasBit(p2, 16);
@@ -2138,8 +2133,6 @@
 
 	if (new_cid >= NUM_CARGO) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_ROADVEH_RUN);
-
 	for (; v != NULL; v = v->Next()) {
 		/* XXX: We refit all the attached wagons en-masse if they can be
 		 * refitted. This is how TTDPatch does it.  TODO: Have some nice
=== src/economy_type.h
==================================================================
--- src/economy_type.h	(/openttd/trunk)	(revision 732)
+++ src/economy_type.h	(/openttd/commandcost)	(revision 732)
@@ -124,6 +124,7 @@
 	EXPENSES_SHIP_INC     = 10,
 	EXPENSES_LOAN_INT     = 11,
 	EXPENSES_OTHER        = 12,
+	EXPENSES_INVALID      = 0xFF,
 };
 
 #endif /* ECONOMY_TYPE_H */
=== src/vehicle.cpp
==================================================================
--- src/vehicle.cpp	(/openttd/trunk)	(revision 732)
+++ src/vehicle.cpp	(/openttd/commandcost)	(revision 732)
@@ -702,18 +702,28 @@
 CommandCost GetRefitCost(EngineID engine_type)
 {
 	CommandCost base_cost;
-
+	ExpensesType expense_type;
 	switch (GetEngine(engine_type)->type) {
-		case VEH_SHIP: base_cost.AddCost(_price.ship_base); break;
-		case VEH_ROAD: base_cost.AddCost(_price.roadveh_base); break;
-		case VEH_AIRCRAFT: base_cost.AddCost(_price.aircraft_base); break;
+		case VEH_SHIP: 
+			base_cost.AddCost(_price.ship_base); 
+			expense_type = EXPENSES_SHIP_RUN;
+			break;
+		case VEH_ROAD: 
+			base_cost.AddCost(_price.roadveh_base); 
+			expense_type = EXPENSES_ROADVEH_RUN;
+			break;
+		case VEH_AIRCRAFT: 
+			base_cost.AddCost(_price.aircraft_base); 
+			expense_type = EXPENSES_AIRCRAFT_RUN;
+			break;
 		case VEH_TRAIN:
 			base_cost.AddCost(2 * ((RailVehInfo(engine_type)->railveh_type == RAILVEH_WAGON) ?
 							 _price.build_railwagon : _price.build_railvehicle));
+			expense_type = EXPENSES_TRAIN_RUN;
 			break;
 		default: NOT_REACHED(); break;
 	}
-	return CommandCost((EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10);
+	return CommandCost(expense_type, (EngInfo(engine_type)->refit_cost * base_cost.GetCost()) >> 10);
 }
 
 static void DoDrawVehicle(const Vehicle *v)
@@ -1692,8 +1702,8 @@
 			 * Because of this, we can't estimate costs due to wagon removal and we will have to always return 0 and pay manually
 			 * Since we pay after each vehicle is replaced and MaybeReplaceVehicle() check if the player got enough money
 			 * we should never reach a condition where the player will end up with negative money from doing this */
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 			SubtractMoneyFromPlayer(ret);
+
 		}
 	}
 
@@ -1721,7 +1731,7 @@
 {
 	Vehicle *v_front, *v;
 	Vehicle *w_front, *w, *w_rear;
-	CommandCost cost, total_cost;
+	CommandCost cost, total_cost(EXPENSES_NEW_VEHICLES);
 	uint32 build_argument = 2;
 
 	if (!IsValidVehicleID(p1)) return CMD_ERROR;
@@ -1875,9 +1885,6 @@
 		return CMD_ERROR;
 	}
 
-	/* Set the expense type last as refitting will make the cost go towards
-	 * running costs... */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	return total_cost;
 }
 
@@ -3100,7 +3107,6 @@
 	current_order.type = OT_LOADING;
 	GetStation(this->last_station_visited)->loading_vehicles.push_back(this);
 
-	SET_EXPENSES_TYPE(this->GetExpenseType(true));
 	VehiclePayment(this);
 
 	InvalidateWindow(this->GetVehicleListWindowClass(), this->owner);
=== src/misc_cmd.cpp
==================================================================
--- src/misc_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/misc_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -157,7 +157,7 @@
 		InvalidatePlayerWindows(p);
 	}
 
-	return CommandCost();
+	return CommandCost(EXPENSES_OTHER);
 }
 
 /** Decrease the loan of your company.
@@ -357,8 +357,7 @@
 #ifndef _DEBUG
 	if (_networking) return CMD_ERROR;
 #endif
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-	return CommandCost(-(Money)p1);
+	return CommandCost(EXPENSES_OTHER, -(Money)p1);
 }
 
 /** Transfer funds (money) from one player to another.
@@ -375,10 +374,8 @@
 	if (!_patches.give_money) return CMD_ERROR;
 
 	const Player *p = GetPlayer(_current_player);
-	CommandCost amount(min((Money)p1, (Money)20000000LL));
+	CommandCost amount(EXPENSES_OTHER, min((Money)p1, (Money)20000000LL));
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	/* You can only transfer funds that is in excess of your loan */
 	if (p->player_money - p->current_loan < amount.GetCost() || amount.GetCost() <= 0) return CMD_ERROR;
 	if (!_networking || !IsValidPlayer((PlayerID)p2)) return CMD_ERROR;
@@ -387,7 +384,7 @@
 		/* Add money to player */
 		PlayerID old_cp = _current_player;
 		_current_player = (PlayerID)p2;
-		SubtractMoneyFromPlayer(CommandCost(-amount.GetCost()));
+		SubtractMoneyFromPlayer( CommandCost(EXPENSES_OTHER, -amount.GetCost() ) );
 		_current_player = old_cp;
 	}
 
=== src/industry_cmd.cpp
==================================================================
--- src/industry_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/industry_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -400,7 +400,7 @@
 	}
 
 	if (flags & DC_EXEC) delete i;
-	return CommandCost(indspec->GetRemovalCost());
+	return CommandCost(EXPENSES_CONSTRUCTION, indspec->GetRemovalCost());
 }
 
 static void TransportIndustryGoods(TileIndex tile)
@@ -1590,8 +1590,6 @@
 {
 	const IndustrySpec *indspec;
 
-	SET_EXPENSES_TYPE(EXPENSES_OTHER);
-
 	indspec = GetIndustrySpec(p1);
 
 	/* Check if the to-be built/founded industry is available for this climate. */
@@ -1646,7 +1644,7 @@
 		if (CreateNewIndustryHelper(tile, p1, flags, indspec, num) == NULL) return CMD_ERROR;
 	}
 
-	return CommandCost(indspec->GetConstructionCost());
+	return CommandCost(EXPENSES_OTHER, indspec->GetConstructionCost());
 }
 
 
@@ -2254,10 +2252,10 @@
 			if (HasBit(itspec->callback_flags, CBM_INDT_AUTOSLOPE)) {
 				/* If the callback fails, allow autoslope. */
 				uint16 res = GetIndustryTileCallback(CBID_INDUSTRY_AUTOSLOPE, 0, 0, gfx, GetIndustryByTile(tile), tile);
-				if ((res == 0) || (res == CALLBACK_FAILED)) return _price.terraform;
+				if ((res == 0) || (res == CALLBACK_FAILED)) return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 			} else {
 				/* allow autoslope */
-				return _price.terraform;
+				return CommandCost(EXPENSES_CONSTRUCTION, _price.terraform);
 			}
 		}
 	}
=== src/autoreplace_cmd.cpp
==================================================================
--- src/autoreplace_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/autoreplace_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -159,12 +159,10 @@
 	/* We give the player a loan of the same amount as the sell value.
 	 * This is needed in case he needs the income from the sale to build the new vehicle.
 	 * We take it back if building fails or when we really sell the old engine */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	SubtractMoneyFromPlayer(sell_value);
 
 	cost = DoCommand(old_v->tile, new_engine_type, 3, flags, GetCmdBuildVeh(old_v));
 	if (CmdFailed(cost)) {
-		SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 		/* Take back the money we just gave the player */
 		sell_value.MultiplyCost(-1);
 		SubtractMoneyFromPlayer(sell_value);
@@ -264,7 +262,7 @@
 		/* Ensure that the player will not end up having negative money while autoreplacing
 		 * This is needed because the only other check is done after the income from selling the old vehicle is substracted from the cost */
 		if (CmdFailed(tmp_move) || p->player_money < (cost.GetCost() + total_cost)) {
-			SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+			
 			/* Pay back the loan */
 			sell_value.MultiplyCost(-1);
 			SubtractMoneyFromPlayer(sell_value);
@@ -274,7 +272,6 @@
 
 	/* Take back the money we just gave the player just before building the vehicle
 	 * The player will get the same amount now that the sale actually takes place */
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
 	sell_value.MultiplyCost(-1);
 	SubtractMoneyFromPlayer(sell_value);
 
@@ -334,7 +331,7 @@
 	v->leave_depot_instantly = false;
 
 	for (;;) {
-		cost = CommandCost();
+		cost = CommandCost(EXPENSES_NEW_VEHICLES);
 		w = v;
 		do {
 			if (w->type == VEH_TRAIN && IsRearDualheaded(w)) {
=== src/aircraft_cmd.cpp
==================================================================
--- src/aircraft_cmd.cpp	(/openttd/trunk)	(revision 732)
+++ src/aircraft_cmd.cpp	(/openttd/commandcost)	(revision 732)
@@ -230,7 +230,7 @@
 
 static CommandCost EstimateAircraftCost(EngineID engine, const AircraftVehicleInfo *avi)
 {
-	return CommandCost(GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5);
+	return CommandCost(EXPENSES_NEW_VEHICLES, GetEngineProperty(engine, 0x0B, avi->base_cost) * (_price.aircraft_base >> 3) >> 5);
 }
 
 
@@ -278,7 +278,7 @@
 
 	if (!IsHangarTile(tile) || !IsTileOwner(tile, _current_player)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+	
 
 	/* Prevent building aircraft types at places which can't handle them */
 	if (!CanAircraftUseStation(p1, tile)) return CMD_ERROR;
@@ -488,10 +488,8 @@
 
 	if (HASBITS(v->vehstatus, VS_CRASHED)) return_cmd_error(STR_CAN_T_SELL_DESTROYED_VEHICLE);
 
-	SET_EXPENSES_TYPE(EXPENSES_NEW_VEHICLES);
+	CommandCost ret(EXPENSES_NEW_VEHICLES, -v->value);
 
-	CommandCost ret(-v->value);
-
 	if (flags & DC_EXEC) {
 		// Invalidate depot
 		InvalidateWindow(WC_VEHICLE_DEPOT, v->tile);
@@ -646,8 +644,6 @@
 	CargoID new_cid = GB(p2, 0, 8);
 	if (new_cid >= NUM_CARGO || !CanRefitTo(v->engine_type, new_cid)) return CMD_ERROR;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
-
 	/* Check the refit capacity callback */
 	uint16 callback = CALLBACK_FAILED;
 	if (HasBit(EngInfo(v->engine_type)->callbackmask, CBM_VEHICLE_REFIT_CAPACITY)) {
@@ -737,11 +733,10 @@
 
 	if (v->vehstatus & VS_STOPPED) return;
 
-	CommandCost cost = CommandCost(GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364);
+	CommandCost cost = CommandCost(EXPENSES_AIRCRAFT_RUN, GetVehicleProperty(v, 0x0E, AircraftVehInfo(v->engine_type)->running_cost) * _price.aircraft_running / 364);
 
 	v->profit_this_year -= cost.GetCost() >> 8;
 
-	SET_EXPENSES_TYPE(EXPENSES_AIRCRAFT_RUN);
 	SubtractMoneyFromPlayerFract(v->owner, cost);
 
 	InvalidateWindow(WC_VEHICLE_DETAILS, v->index);

Property changes on: 
___________________________________________________________________
Name: svk:merge
 +6aa0318a-3be1-0310-93fa-89fd2396df07:/trunk:11729

