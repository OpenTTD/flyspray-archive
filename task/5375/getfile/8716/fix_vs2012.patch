diff --git a/src/3rdparty/md5/md5.cpp b/src/3rdparty/md5/md5.cpp
--- a/src/3rdparty/md5/md5.cpp
+++ b/src/3rdparty/md5/md5.cpp
@@ -126,14 +126,14 @@
 #define T63    0x2ad7d2bb
 #define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)
 
-static inline void Md5Set1(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
+static INLINE void Md5Set1(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
 {
 	uint32 t = (*b & *c) | (~*b & *d);
 	t += *a + X[k] + Ti;
 	*a = ROL(t, s) + *b;
 }
 
-static inline void Md5Set2(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
+static INLINE void Md5Set2(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
 {
 	uint32 t = (*b & *d) | (*c & ~*d);
 	t += *a + X[k] + Ti;
@@ -141,14 +141,14 @@
 }
 
 
-static inline void Md5Set3(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
+static INLINE void Md5Set3(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
 {
 	uint32 t = *b ^ *c ^ *d;
 	t += *a + X[k] + Ti;
 	*a = ROL(t, s) + *b;
 }
 
-static inline void Md5Set4(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
+static INLINE void Md5Set4(const uint32 *X, uint32 *a, const uint32 *b, const uint32 *c, const uint32 *d, const uint8 k, const uint8 s, const uint32 Ti)
 {
 	uint32 t = *c ^ (*b | ~*d);
 	t += *a + X[k] + Ti;
diff --git a/src/3rdparty/squirrel/include/squirrel.h b/src/3rdparty/squirrel/include/squirrel.h
--- a/src/3rdparty/squirrel/include/squirrel.h
+++ b/src/3rdparty/squirrel/include/squirrel.h
@@ -36,7 +36,9 @@
 #endif
 
 #if defined(_MSC_VER)
-# define inline __forceinline
+# define INLINE __forceinline
+#else
+# define INLINE inline
 #endif /* _MSC_VER */
 
 #if defined(_MSC_VER) && _MSC_VER >= 1400 // MSVC 2005 safety checks
diff --git a/src/3rdparty/squirrel/squirrel/sqobject.h b/src/3rdparty/squirrel/squirrel/sqobject.h
--- a/src/3rdparty/squirrel/squirrel/sqobject.h
+++ b/src/3rdparty/squirrel/squirrel/sqobject.h
@@ -273,7 +273,7 @@
 	{
 		__Release(_type,_unVal);
 	}
-	inline void Null()
+	INLINE void Null()
 	{
 		SQObjectType tOldType;
 		SQObjectValue unOldVal;
@@ -283,7 +283,7 @@
 		_unVal.pUserPointer = NULL;
 		__Release(tOldType,unOldVal);
 	}
-	inline SQObjectPtr& operator=(SQInteger i)
+	INLINE SQObjectPtr& operator=(SQInteger i)
 	{
 		__Release(_type,_unVal);
 		SQ_OBJECT_RAWINIT()
@@ -291,7 +291,7 @@
 		_type = OT_INTEGER;
 		return *this;
 	}
-	inline SQObjectPtr& operator=(SQFloat f)
+	INLINE SQObjectPtr& operator=(SQFloat f)
 	{
 		__Release(_type,_unVal);
 		SQ_OBJECT_RAWINIT()
@@ -299,7 +299,7 @@
 		_type = OT_FLOAT;
 		return *this;
 	}
-	inline SQObjectPtr& operator=(const SQObjectPtr& obj)
+	INLINE SQObjectPtr& operator=(const SQObjectPtr& obj)
 	{
 		SQObjectType tOldType;
 		SQObjectValue unOldVal;
@@ -311,7 +311,7 @@
 		__Release(tOldType,unOldVal);
 		return *this;
 	}
-	inline SQObjectPtr& operator=(const SQObject& obj)
+	INLINE SQObjectPtr& operator=(const SQObject& obj)
 	{
 		SQObjectType tOldType;
 		SQObjectValue unOldVal;
@@ -327,7 +327,7 @@
 		SQObjectPtr(const SQChar *){} //safety
 };
 
-inline void _Swap(SQObject &a,SQObject &b)
+INLINE void _Swap(SQObject &a,SQObject &b)
 {
 	SQObjectType tOldType = a._type;
 	SQObjectValue unOldVal = a._unVal;
diff --git a/src/3rdparty/squirrel/squirrel/sqstring.h b/src/3rdparty/squirrel/squirrel/sqstring.h
--- a/src/3rdparty/squirrel/squirrel/sqstring.h
+++ b/src/3rdparty/squirrel/squirrel/sqstring.h
@@ -2,7 +2,7 @@
 #ifndef _SQSTRING_H_
 #define _SQSTRING_H_
 
-inline SQHash _hashstr (const SQChar *s, size_t l)
+INLINE SQHash _hashstr (const SQChar *s, size_t l)
 {
 		SQHash h = (SQHash)l;  /* seed */
 		size_t step = (l>>5)|1;  /* if string is too long, don't hash all its chars */
diff --git a/src/3rdparty/squirrel/squirrel/sqtable.h b/src/3rdparty/squirrel/squirrel/sqtable.h
--- a/src/3rdparty/squirrel/squirrel/sqtable.h
+++ b/src/3rdparty/squirrel/squirrel/sqtable.h
@@ -12,7 +12,7 @@
 
 #define hashptr(p)  ((SQHash)(((SQInteger)p) >> 3))
 
-inline SQHash HashObj(const SQObjectPtr &key)
+INLINE SQHash HashObj(const SQObjectPtr &key)
 {
 	switch(type(key)) {
 		case OT_STRING:		return _string(key)->_hash;
@@ -62,7 +62,7 @@
 #ifndef NO_GARBAGE_COLLECTOR
 	void Mark(SQCollectable **chain);
 #endif
-	inline _HashNode *_Get(const SQObjectPtr &key,SQHash hash)
+	INLINE _HashNode *_Get(const SQObjectPtr &key,SQHash hash)
 	{
 		_HashNode *n = &_nodes[hash];
 		do{
diff --git a/src/3rdparty/squirrel/squirrel/squtils.h b/src/3rdparty/squirrel/squirrel/squtils.h
--- a/src/3rdparty/squirrel/squirrel/squtils.h
+++ b/src/3rdparty/squirrel/squirrel/squtils.h
@@ -62,15 +62,15 @@
 	}
 	void shrinktofit() { if(_size > 4) { _realloc(_size); } }
 	T& top() const { return _vals[_size - 1]; }
-	inline SQUnsignedInteger size() const { return _size; }
+	INLINE SQUnsignedInteger size() const { return _size; }
 	bool empty() const { return (_size <= 0); }
-	inline T &push_back(const T& val = T())
+	INLINE T &push_back(const T& val = T())
 	{
 		if(_allocated <= _size)
 			_realloc(_size * 2);
 		return *(new ((void *)&_vals[_size++]) T(val));
 	}
-	inline void pop_back()
+	INLINE void pop_back()
 	{
 		_size--; _vals[_size].~T();
 	}
@@ -91,8 +91,8 @@
 		_size--;
 	}
 	SQUnsignedInteger capacity() { return _allocated; }
-	inline T &back() const { return _vals[_size - 1]; }
-	inline T& operator[](SQUnsignedInteger pos) const{ assert(pos < _allocated); return _vals[pos]; }
+	INLINE T &back() const { return _vals[_size - 1]; }
+	INLINE T& operator[](SQUnsignedInteger pos) const{ assert(pos < _allocated); return _vals[pos]; }
 	T* _vals;
 private:
 	void _realloc(SQUnsignedInteger newsize)
diff --git a/src/3rdparty/squirrel/squirrel/sqvm.h b/src/3rdparty/squirrel/squirrel/sqvm.h
--- a/src/3rdparty/squirrel/squirrel/sqvm.h
+++ b/src/3rdparty/squirrel/squirrel/sqvm.h
@@ -188,7 +188,7 @@
 	SQInteger *_n;
 };
 
-inline SQObjectPtr &stack_get(HSQUIRRELVM v,SQInteger idx){return ((idx>=0)?(v->GetAt(idx+v->_stackbase-1)):(v->GetUp(idx)));}
+INLINE SQObjectPtr &stack_get(HSQUIRRELVM v,SQInteger idx){return ((idx>=0)?(v->GetAt(idx+v->_stackbase-1)):(v->GetUp(idx)));}
 
 #define _ss(_vm_) (_vm_)->_sharedstate
 
diff --git a/src/aircraft.h b/src/aircraft.h
--- a/src/aircraft.h
+++ b/src/aircraft.h
@@ -97,7 +97,7 @@
 	 * @return Returns true if the aircraft is a helicopter/airplane and
 	 * false if it is a shadow or a rotor
 	 */
-	inline bool IsNormalAircraft() const
+	INLINE bool IsNormalAircraft() const
 	{
 		/* To be fully correct the commented out functionality is the proper one,
 		 * but since value can only be 0 or 2, it is sufficient to only check <= 2
diff --git a/src/articulated_vehicles.cpp b/src/articulated_vehicles.cpp
--- a/src/articulated_vehicles.cpp
+++ b/src/articulated_vehicles.cpp
@@ -102,7 +102,7 @@
  * @param cargo_type returns the default cargo type, if needed
  * @return capacity
  */
-static inline uint16 GetVehicleDefaultCapacity(EngineID engine, CargoID *cargo_type)
+static INLINE uint16 GetVehicleDefaultCapacity(EngineID engine, CargoID *cargo_type)
 {
 	const Engine *e = Engine::Get(engine);
 	CargoID cargo = (e->CanCarryCargo() ? e->GetDefaultCargoType() : (CargoID)CT_INVALID);
@@ -117,7 +117,7 @@
  * @param include_initial_cargo_type if true the default cargo type of the vehicle is included; if false only the refit_mask
  * @return bit set of CargoIDs
  */
-static inline uint32 GetAvailableVehicleCargoTypes(EngineID engine, bool include_initial_cargo_type)
+static INLINE uint32 GetAvailableVehicleCargoTypes(EngineID engine, bool include_initial_cargo_type)
 {
 	const Engine *e = Engine::Get(engine);
 	if (!e->CanCarryCargo()) return 0;
diff --git a/src/autoreplace_cmd.cpp b/src/autoreplace_cmd.cpp
--- a/src/autoreplace_cmd.cpp
+++ b/src/autoreplace_cmd.cpp
@@ -311,7 +311,7 @@
  * @param evaluate_callback shall the start/stop callback be evaluated?
  * @return success or error
  */
-static inline CommandCost CmdStartStopVehicle(const Vehicle *v, bool evaluate_callback)
+static INLINE CommandCost CmdStartStopVehicle(const Vehicle *v, bool evaluate_callback)
 {
 	return DoCommand(0, v->index, evaluate_callback ? 1 : 0, DC_EXEC | DC_AUTOREPLACE, CMD_START_STOP_VEHICLE);
 }
@@ -324,7 +324,7 @@
  * @param whole_chain move all vehicles following 'v' (true), or only 'v' (false)
  * @return success or error
  */
-static inline CommandCost CmdMoveVehicle(const Vehicle *v, const Vehicle *after, DoCommandFlag flags, bool whole_chain)
+static INLINE CommandCost CmdMoveVehicle(const Vehicle *v, const Vehicle *after, DoCommandFlag flags, bool whole_chain)
 {
 	return DoCommand(0, v->index | (whole_chain ? 1 : 0) << 20, after != NULL ? after->index : INVALID_VEHICLE, flags | DC_NO_CARGO_CAP_CHECK, CMD_MOVE_RAIL_VEHICLE);
 }
diff --git a/src/autoreplace_func.h b/src/autoreplace_func.h
--- a/src/autoreplace_func.h
+++ b/src/autoreplace_func.h
@@ -24,7 +24,7 @@
  * Remove all engine replacement settings for the given company.
  * @param c the company.
  */
-static inline void RemoveAllEngineReplacementForCompany(Company *c)
+static INLINE void RemoveAllEngineReplacementForCompany(Company *c)
 {
 	RemoveAllEngineReplacement(&c->engine_renew_list);
 }
@@ -38,7 +38,7 @@
  * @return The engine type to replace with, or INVALID_ENGINE if no
  * replacement is in the list.
  */
-static inline EngineID EngineReplacementForCompany(const Company *c, EngineID engine, GroupID group, bool *replace_when_old = NULL)
+static INLINE EngineID EngineReplacementForCompany(const Company *c, EngineID engine, GroupID group, bool *replace_when_old = NULL)
 {
 	return EngineReplacement(c->engine_renew_list, engine, group, replace_when_old);
 }
@@ -50,7 +50,7 @@
  * @param group The group related to this replacement.
  * @return true if a replacement was set up, false otherwise.
  */
-static inline bool EngineHasReplacementForCompany(const Company *c, EngineID engine, GroupID group)
+static INLINE bool EngineHasReplacementForCompany(const Company *c, EngineID engine, GroupID group)
 {
 	return EngineReplacementForCompany(c, engine, group) != INVALID_ENGINE;
 }
@@ -62,7 +62,7 @@
  * @param group The group related to this replacement.
  * @return True if a replacement when old was set up, false otherwise.
  */
-static inline bool EngineHasReplacementWhenOldForCompany(const Company *c, EngineID engine, GroupID group)
+static INLINE bool EngineHasReplacementWhenOldForCompany(const Company *c, EngineID engine, GroupID group)
 {
 	bool replace_when_old;
 	EngineReplacement(c->engine_renew_list, engine, group, &replace_when_old);
@@ -79,7 +79,7 @@
  * @param flags The calling command flags.
  * @return 0 on success, CMD_ERROR on failure.
  */
-static inline CommandCost AddEngineReplacementForCompany(Company *c, EngineID old_engine, EngineID new_engine, GroupID group, bool replace_when_old, DoCommandFlag flags)
+static INLINE CommandCost AddEngineReplacementForCompany(Company *c, EngineID old_engine, EngineID new_engine, GroupID group, bool replace_when_old, DoCommandFlag flags)
 {
 	return AddEngineReplacement(&c->engine_renew_list, old_engine, new_engine, group, replace_when_old, flags);
 }
@@ -92,7 +92,7 @@
  * @param flags The calling command flags.
  * @return 0 on success, CMD_ERROR on failure.
  */
-static inline CommandCost RemoveEngineReplacementForCompany(Company *c, EngineID engine, GroupID group, DoCommandFlag flags)
+static INLINE CommandCost RemoveEngineReplacementForCompany(Company *c, EngineID engine, GroupID group, DoCommandFlag flags)
 {
 	return RemoveEngineReplacement(&c->engine_renew_list, engine, group, flags);
 }
diff --git a/src/autoslope.h b/src/autoslope.h
--- a/src/autoslope.h
+++ b/src/autoslope.h
@@ -30,7 +30,7 @@
  * @param entrance Entrance edge.
  * @return true iff terraforming is allowed.
  */
-static inline bool AutoslopeCheckForEntranceEdge(TileIndex tile, int z_new, Slope tileh_new, DiagDirection entrance)
+static INLINE bool AutoslopeCheckForEntranceEdge(TileIndex tile, int z_new, Slope tileh_new, DiagDirection entrance)
 {
 	if (GetTileMaxZ(tile) != z_new + GetSlopeMaxZ(tileh_new)) return false;
 	return ((tileh_new == SLOPE_FLAT) || CanBuildDepotByTileh(entrance, tileh_new));
@@ -43,7 +43,7 @@
  *
  * @return true iff autoslope is enabled.
  */
-static inline bool AutoslopeEnabled()
+static INLINE bool AutoslopeEnabled()
 {
 	return (_settings_game.construction.autoslope &&
 	        (_current_company < MAX_COMPANIES ||
diff --git a/src/base_station_base.h b/src/base_station_base.h
--- a/src/base_station_base.h
+++ b/src/base_station_base.h
@@ -139,7 +139,7 @@
 	 * @param tile The tile to get the base station from.
 	 * @return the station associated with that tile.
 	 */
-	static inline BaseStation *GetByTile(TileIndex tile)
+	static INLINE BaseStation *GetByTile(TileIndex tile)
 	{
 		return BaseStation::Get(GetStationIndex(tile));
 	}
@@ -150,7 +150,7 @@
 	 * facilities left.
 	 * @return true if still in use
 	 */
-	inline bool IsInUse() const
+	INLINE bool IsInUse() const
 	{
 		return (this->facilities & ~FACIL_WAYPOINT) != 0;
 	}
@@ -172,7 +172,7 @@
 	 * Set station type correctly
 	 * @param tile The base tile of the station.
 	 */
-	inline SpecializedStation<T, Tis_waypoint>(TileIndex tile) :
+	INLINE SpecializedStation<T, Tis_waypoint>(TileIndex tile) :
 			BaseStation(tile)
 	{
 		this->facilities = EXPECTED_FACIL;
@@ -183,7 +183,7 @@
 	 * @param st the station to check.
 	 * @return true if the station is the type we expect it to be.
 	 */
-	static inline bool IsExpected(const BaseStation *st)
+	static INLINE bool IsExpected(const BaseStation *st)
 	{
 		return (st->facilities & FACIL_WAYPOINT) == EXPECTED_FACIL;
 	}
@@ -193,7 +193,7 @@
 	 * @param index tested index
 	 * @return is this index valid index of T?
 	 */
-	static inline bool IsValidID(size_t index)
+	static INLINE bool IsValidID(size_t index)
 	{
 		return BaseStation::IsValidID(index) && IsExpected(BaseStation::Get(index));
 	}
@@ -202,7 +202,7 @@
 	 * Gets station with given index
 	 * @return pointer to station with given index casted to T *
 	 */
-	static inline T *Get(size_t index)
+	static INLINE T *Get(size_t index)
 	{
 		return (T *)BaseStation::Get(index);
 	}
@@ -211,7 +211,7 @@
 	 * Returns station if the index is a valid index for this station type
 	 * @return pointer to station with given index if it's a station of this type
 	 */
-	static inline T *GetIfValid(size_t index)
+	static INLINE T *GetIfValid(size_t index)
 	{
 		return IsValidID(index) ? Get(index) : NULL;
 	}
@@ -221,7 +221,7 @@
 	 * @param tile The tile to get the station from.
 	 * @return the station associated with that tile.
 	 */
-	static inline T *GetByTile(TileIndex tile)
+	static INLINE T *GetByTile(TileIndex tile)
 	{
 		return GetIfValid(GetStationIndex(tile));
 	}
@@ -231,7 +231,7 @@
 	 * @param st BaseStation pointer
 	 * @return pointer to SpecializedStation
 	 */
-	static inline T *From(BaseStation *st)
+	static INLINE T *From(BaseStation *st)
 	{
 		assert(IsExpected(st));
 		return (T *)st;
@@ -242,7 +242,7 @@
 	 * @param st BaseStation pointer
 	 * @return pointer to SpecializedStation
 	 */
-	static inline const T *From(const BaseStation *st)
+	static INLINE const T *From(const BaseStation *st)
 	{
 		assert(IsExpected(st));
 		return (const T *)st;
diff --git a/src/blitter/32bpp_anim.cpp b/src/blitter/32bpp_anim.cpp
--- a/src/blitter/32bpp_anim.cpp
+++ b/src/blitter/32bpp_anim.cpp
@@ -19,7 +19,7 @@
 static FBlitter_32bppAnim iFBlitter_32bppAnim;
 
 template <BlitterMode mode>
-inline void Blitter_32bppAnim::Draw(const Blitter::BlitterParams *bp, ZoomLevel zoom)
+INLINE void Blitter_32bppAnim::Draw(const Blitter::BlitterParams *bp, ZoomLevel zoom)
 {
 	const SpriteData *src = (const SpriteData *)bp->sprite;
 
diff --git a/src/blitter/32bpp_anim.hpp b/src/blitter/32bpp_anim.hpp
--- a/src/blitter/32bpp_anim.hpp
+++ b/src/blitter/32bpp_anim.hpp
@@ -47,7 +47,7 @@
 	/**
 	 * Look up the colour in the current palette.
 	 */
-	inline Colour LookupColourInPalette(uint index)
+	INLINE Colour LookupColourInPalette(uint index)
 	{
 		return this->palette.palette[index];
 	}
diff --git a/src/blitter/32bpp_base.hpp b/src/blitter/32bpp_base.hpp
--- a/src/blitter/32bpp_base.hpp
+++ b/src/blitter/32bpp_base.hpp
@@ -36,7 +36,7 @@
 	/**
 	 * Look up the colour in the current palette.
 	 */
-	static inline Colour LookupColourInPalette(uint index)
+	static INLINE Colour LookupColourInPalette(uint index)
 	{
 		return _cur_palette.palette[index];
 	}
@@ -44,7 +44,7 @@
 	/**
 	 * Compose a colour based on RGBA values and the current pixel value.
 	 */
-	static inline Colour ComposeColourRGBANoCheck(uint r, uint g, uint b, uint a, Colour current)
+	static INLINE Colour ComposeColourRGBANoCheck(uint r, uint g, uint b, uint a, Colour current)
 	{
 		uint cr = current.r;
 		uint cg = current.g;
@@ -61,7 +61,7 @@
 	 * Compose a colour based on RGBA values and the current pixel value.
 	 * Handles fully transparent and solid pixels in a special (faster) way.
 	 */
-	static inline Colour ComposeColourRGBA(uint r, uint g, uint b, uint a, Colour current)
+	static INLINE Colour ComposeColourRGBA(uint r, uint g, uint b, uint a, Colour current)
 	{
 		if (a == 0) return current;
 		if (a >= 255) return Colour(r, g, b);
@@ -72,7 +72,7 @@
 	/**
 	 * Compose a colour based on Pixel value, alpha value, and the current pixel value.
 	 */
-	static inline Colour ComposeColourPANoCheck(Colour colour, uint a, Colour current)
+	static INLINE Colour ComposeColourPANoCheck(Colour colour, uint a, Colour current)
 	{
 		uint r  = colour.r;
 		uint g  = colour.g;
@@ -85,7 +85,7 @@
 	 * Compose a colour based on Pixel value, alpha value, and the current pixel value.
 	 * Handles fully transparent and solid pixels in a special (faster) way.
 	 */
-	static inline Colour ComposeColourPA(Colour colour, uint a, Colour current)
+	static INLINE Colour ComposeColourPA(Colour colour, uint a, Colour current)
 	{
 		if (a == 0) return current;
 		if (a >= 255) {
@@ -103,7 +103,7 @@
 	 * @param denom denominator, makes colour darker.
 	 * @return the new colour for the screen.
 	 */
-	static inline Colour MakeTransparent(Colour colour, uint nom, uint denom = 256)
+	static INLINE Colour MakeTransparent(Colour colour, uint nom, uint denom = 256)
 	{
 		uint r = colour.r;
 		uint g = colour.g;
@@ -117,7 +117,7 @@
 	 * @param colour the colour to make grey.
 	 * @return the new colour, now grey.
 	 */
-	static inline Colour MakeGrey(Colour colour)
+	static INLINE Colour MakeGrey(Colour colour)
 	{
 		uint r = colour.r;
 		uint g = colour.g;
@@ -133,7 +133,7 @@
 
 	static const int DEFAULT_BRIGHTNESS = 128;
 
-	static inline Colour AdjustBrightness(Colour colour, uint8 brightness)
+	static INLINE Colour AdjustBrightness(Colour colour, uint8 brightness)
 	{
 		/* Shortcut for normal brightness */
 		if (brightness == DEFAULT_BRIGHTNESS) return colour;
diff --git a/src/blitter/32bpp_optimized.cpp b/src/blitter/32bpp_optimized.cpp
--- a/src/blitter/32bpp_optimized.cpp
+++ b/src/blitter/32bpp_optimized.cpp
@@ -25,7 +25,7 @@
  * @param zoom zoom level at which we are drawing
  */
 template <BlitterMode mode>
-inline void Blitter_32bppOptimized::Draw(const Blitter::BlitterParams *bp, ZoomLevel zoom)
+INLINE void Blitter_32bppOptimized::Draw(const Blitter::BlitterParams *bp, ZoomLevel zoom)
 {
 	const SpriteData *src = (const SpriteData *)bp->sprite;
 
diff --git a/src/bmp.cpp b/src/bmp.cpp
--- a/src/bmp.cpp
+++ b/src/bmp.cpp
@@ -23,44 +23,44 @@
 	buffer->real_pos = ftell(file);
 }
 
-static inline void AdvanceBuffer(BmpBuffer *buffer)
+static INLINE void AdvanceBuffer(BmpBuffer *buffer)
 {
 	buffer->read = (int)fread(buffer->data, 1, BMP_BUFFER_SIZE, buffer->file);
 	buffer->pos  = 0;
 }
 
-static inline bool EndOfBuffer(BmpBuffer *buffer)
+static INLINE bool EndOfBuffer(BmpBuffer *buffer)
 {
 	if (buffer->pos == buffer->read || buffer->pos < 0) AdvanceBuffer(buffer);
 	return buffer->pos == buffer->read;
 }
 
-static inline byte ReadByte(BmpBuffer *buffer)
+static INLINE byte ReadByte(BmpBuffer *buffer)
 {
 	if (buffer->pos == buffer->read || buffer->pos < 0) AdvanceBuffer(buffer);
 	buffer->real_pos++;
 	return buffer->data[buffer->pos++];
 }
 
-static inline uint16 ReadWord(BmpBuffer *buffer)
+static INLINE uint16 ReadWord(BmpBuffer *buffer)
 {
 	uint16 var = ReadByte(buffer);
 	return var | (ReadByte(buffer) << 8);
 }
 
-static inline uint32 ReadDword(BmpBuffer *buffer)
+static INLINE uint32 ReadDword(BmpBuffer *buffer)
 {
 	uint32 var = ReadWord(buffer);
 	return var | (ReadWord(buffer) << 16);
 }
 
-static inline void SkipBytes(BmpBuffer *buffer, int bytes)
+static INLINE void SkipBytes(BmpBuffer *buffer, int bytes)
 {
 	int i;
 	for (i = 0; i < bytes; i++) ReadByte(buffer);
 }
 
-static inline void SetStreamOffset(BmpBuffer *buffer, int offset)
+static INLINE void SetStreamOffset(BmpBuffer *buffer, int offset)
 {
 	fseek(buffer->file, offset, SEEK_SET);
 	buffer->pos = -1;
@@ -72,7 +72,7 @@
  * Reads a 1 bpp uncompressed bitmap
  * The bitmap is converted to a 8 bpp bitmap
  */
-static inline bool BmpRead1(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead1(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint x, y, i;
 	byte pad = GB(4 - info->width / 8, 0, 2);
@@ -99,7 +99,7 @@
  * Reads a 4 bpp uncompressed bitmap
  * The bitmap is converted to a 8 bpp bitmap
  */
-static inline bool BmpRead4(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead4(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint x, y;
 	byte pad = GB(4 - info->width / 2, 0, 2);
@@ -128,7 +128,7 @@
  * Reads a 4-bit RLE compressed bitmap
  * The bitmap is converted to a 8 bpp bitmap
  */
-static inline bool BmpRead4Rle(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead4Rle(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint x = 0;
 	uint y = info->height - 1;
@@ -202,7 +202,7 @@
 /**
  * Reads a 8 bpp bitmap
  */
-static inline bool BmpRead8(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead8(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint i;
 	uint y;
@@ -221,7 +221,7 @@
 /**
  * Reads a 8-bit RLE compressed bpp bitmap
  */
-static inline bool BmpRead8Rle(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead8Rle(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint x = 0;
 	uint y = info->height - 1;
@@ -283,7 +283,7 @@
 /**
  * Reads a 24 bpp uncompressed bitmap
  */
-static inline bool BmpRead24(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
+static INLINE bool BmpRead24(BmpBuffer *buffer, BmpInfo *info, BmpData *data)
 {
 	uint x, y;
 	byte pad = GB(4 - info->width * 3, 0, 2);
diff --git a/src/bridge.h b/src/bridge.h
--- a/src/bridge.h
+++ b/src/bridge.h
@@ -64,7 +64,7 @@
  * @param i The type of bridge to get the specification for.
  * @return The specification.
  */
-static inline const BridgeSpec *GetBridgeSpec(BridgeType i)
+static INLINE const BridgeSpec *GetBridgeSpec(BridgeType i)
 {
 	assert(i < lengthof(_bridge));
 	return &_bridge[i];
diff --git a/src/bridge_map.h b/src/bridge_map.h
--- a/src/bridge_map.h
+++ b/src/bridge_map.h
@@ -21,7 +21,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return true if the structure is a bridge one
  */
-static inline bool IsBridge(TileIndex t)
+static INLINE bool IsBridge(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return HasBit(_m[t].m5, 7);
@@ -32,7 +32,7 @@
  * @param t The tile to analyze
  * @return true if a bridge is present
  */
-static inline bool IsBridgeTile(TileIndex t)
+static INLINE bool IsBridgeTile(TileIndex t)
 {
 	return IsTileType(t, MP_TUNNELBRIDGE) && IsBridge(t);
 }
@@ -43,7 +43,7 @@
  * @param t The tile to analyze
  * @return true if a bridge migh be present
  */
-static inline bool MayHaveBridgeAbove(TileIndex t)
+static INLINE bool MayHaveBridgeAbove(TileIndex t)
 {
 	return IsTileType(t, MP_CLEAR) || IsTileType(t, MP_RAILWAY) || IsTileType(t, MP_ROAD) ||
 			IsTileType(t, MP_WATER) || IsTileType(t, MP_TUNNELBRIDGE) || IsTileType(t, MP_OBJECT);
@@ -55,7 +55,7 @@
  * @pre MayHaveBridgeAbove(t)
  * @return true if a bridge is detected above
  */
-static inline bool IsBridgeAbove(TileIndex t)
+static INLINE bool IsBridgeAbove(TileIndex t)
 {
 	assert(MayHaveBridgeAbove(t));
 	return GB(_m[t].m6, 6, 2) != 0;
@@ -67,7 +67,7 @@
  * @pre IsBridgeTile(t)
  * @return The bridge type
  */
-static inline BridgeType GetBridgeType(TileIndex t)
+static INLINE BridgeType GetBridgeType(TileIndex t)
 {
 	assert(IsBridgeTile(t));
 	return GB(_m[t].m6, 2, 4);
@@ -79,7 +79,7 @@
  * @pre IsBridgeAbove(t)
  * @return the above mentioned axis
  */
-static inline Axis GetBridgeAxis(TileIndex t)
+static INLINE Axis GetBridgeAxis(TileIndex t)
 {
 	assert(IsBridgeAbove(t));
 	return (Axis)(GB(_m[t].m6, 6, 2) - 1);
@@ -95,7 +95,7 @@
  * @param tile the bridge ramp tile to get the bridge height from
  * @return the height of the bridge in pixels
  */
-static inline int GetBridgePixelHeight(TileIndex tile)
+static INLINE int GetBridgePixelHeight(TileIndex tile)
 {
 	return GetBridgeHeight(tile) * TILE_HEIGHT;
 }
@@ -106,7 +106,7 @@
  * @param a the axis of the bridge to remove
  * @pre MayHaveBridgeAbove(t)
  */
-static inline void ClearSingleBridgeMiddle(TileIndex t, Axis a)
+static INLINE void ClearSingleBridgeMiddle(TileIndex t, Axis a)
 {
 	assert(MayHaveBridgeAbove(t));
 	ClrBit(_m[t].m6, 6 + a);
@@ -117,7 +117,7 @@
  * @param t the tile to remove the bridge from
  * @pre MayHaveBridgeAbove(t)
  */
-static inline void ClearBridgeMiddle(TileIndex t)
+static INLINE void ClearBridgeMiddle(TileIndex t)
 {
 	ClearSingleBridgeMiddle(t, AXIS_X);
 	ClearSingleBridgeMiddle(t, AXIS_Y);
@@ -129,7 +129,7 @@
  * @param a the axis of the bridge to add
  * @pre MayHaveBridgeAbove(t)
  */
-static inline void SetBridgeMiddle(TileIndex t, Axis a)
+static INLINE void SetBridgeMiddle(TileIndex t, Axis a)
 {
 	assert(MayHaveBridgeAbove(t));
 	SetBit(_m[t].m6, 6 + a);
@@ -145,7 +145,7 @@
  * @param rt         the road or rail type
  * @note this function should not be called directly.
  */
-static inline void MakeBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt)
+static INLINE void MakeBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, TransportType tt, uint rt)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
@@ -165,7 +165,7 @@
  * @param d          the direction this ramp must be facing
  * @param r          the road type of the bridge
  */
-static inline void MakeRoadBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RoadTypes r)
+static INLINE void MakeRoadBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RoadTypes r)
 {
 	MakeBridgeRamp(t, o, bridgetype, d, TRANSPORT_ROAD, 0);
 	SetRoadOwner(t, ROADTYPE_ROAD, o);
@@ -181,7 +181,7 @@
  * @param d          the direction this ramp must be facing
  * @param r          the rail type of the bridge
  */
-static inline void MakeRailBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r)
+static INLINE void MakeRailBridgeRamp(TileIndex t, Owner o, BridgeType bridgetype, DiagDirection d, RailType r)
 {
 	MakeBridgeRamp(t, o, bridgetype, d, TRANSPORT_RAIL, r);
 }
@@ -192,7 +192,7 @@
  * @param o          the new owner of the bridge ramp
  * @param d          the direction this ramp must be facing
  */
-static inline void MakeAqueductBridgeRamp(TileIndex t, Owner o, DiagDirection d)
+static INLINE void MakeAqueductBridgeRamp(TileIndex t, Owner o, DiagDirection d)
 {
 	MakeBridgeRamp(t, o, 0, d, TRANSPORT_WATER, 0);
 }
diff --git a/src/cargo_type.h b/src/cargo_type.h
--- a/src/cargo_type.h
+++ b/src/cargo_type.h
@@ -77,13 +77,13 @@
 
 public:
 	/** Default constructor. */
-	inline CargoArray()
+	INLINE CargoArray()
 	{
 		this->Clear();
 	}
 
 	/** Reset all entries. */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		memset(this->amount, 0, sizeof(this->amount));
 	}
@@ -92,7 +92,7 @@
 	 * Read/write access to an amount of a specific cargo type.
 	 * @param cargo Cargo type to access.
 	 */
-	inline uint &operator[](CargoID cargo)
+	INLINE uint &operator[](CargoID cargo)
 	{
 		return this->amount[cargo];
 	}
@@ -101,7 +101,7 @@
 	 * Read-only access to an amount of a specific cargo type.
 	 * @param cargo Cargo type to access.
 	 */
-	inline const uint &operator[](CargoID cargo) const
+	INLINE const uint &operator[](CargoID cargo) const
 	{
 		return this->amount[cargo];
 	}
@@ -111,7 +111,7 @@
 	 * @return The sum.
 	 */
 	template <typename T>
-	inline const T GetSum() const
+	INLINE const T GetSum() const
 	{
 		T ret = 0;
 		for (size_t i = 0; i < lengthof(this->amount); i++) {
@@ -124,7 +124,7 @@
 	 * Get the amount of cargos that have an amount.
 	 * @return The amount.
 	 */
-	inline byte GetCount() const
+	INLINE byte GetCount() const
 	{
 		byte count = 0;
 		for (size_t i = 0; i < lengthof(this->amount); i++) {
diff --git a/src/cargomonitor.h b/src/cargomonitor.h
--- a/src/cargomonitor.h
+++ b/src/cargomonitor.h
@@ -57,7 +57,7 @@
  * @param ind %Industry providing or accepting the cargo.
  * @return The encoded cargo/company/industry number.
  */
-static inline CargoMonitorID EncodeCargoIndustryMonitor(CompanyID company, CargoID ctype, IndustryID ind)
+static INLINE CargoMonitorID EncodeCargoIndustryMonitor(CompanyID company, CargoID ctype, IndustryID ind)
 {
 	assert(ctype < (1 << CCB_CARGO_TYPE_LENGTH));
 
@@ -76,7 +76,7 @@
  * @param town %Town providing or accepting the cargo.
  * @return The encoded cargo/company/town number.
  */
-static inline CargoMonitorID EncodeCargoTownMonitor(CompanyID company, CargoID ctype, TownID town)
+static INLINE CargoMonitorID EncodeCargoTownMonitor(CompanyID company, CargoID ctype, TownID town)
 {
 	assert(ctype < (1 << CCB_CARGO_TYPE_LENGTH));
 
@@ -92,7 +92,7 @@
  * @param num Cargo monitoring number to decode.
  * @return The extracted company id.
  */
-static inline CompanyID DecodeMonitorCompany(CargoMonitorID num)
+static INLINE CompanyID DecodeMonitorCompany(CargoMonitorID num)
 {
 	return static_cast<CompanyID>(GB(num, CCB_COMPANY_START, CCB_COMPANY_LENGTH));
 }
@@ -102,7 +102,7 @@
  * @param num Cargo monitoring number to decode.
  * @return The extracted cargo type.
  */
-static inline CargoID DecodeMonitorCargoType(CargoMonitorID num)
+static INLINE CargoID DecodeMonitorCargoType(CargoMonitorID num)
 {
 	return GB(num, CCB_CARGO_TYPE_START, CCB_CARGO_TYPE_LENGTH);
 }
@@ -112,7 +112,7 @@
  * @param num Cargo monitoring number to decode.
  * @return true if monitoring an industry, false if monitoring a town.
  */
-static inline bool MonitorMonitorsIndustry(CargoMonitorID num)
+static INLINE bool MonitorMonitorsIndustry(CargoMonitorID num)
 {
 	return HasBit(num, CCB_IS_INDUSTRY_BIT);
 }
@@ -122,7 +122,7 @@
  * @param num Cargo monitoring number to decode.
  * @return The extracted industry id, or #INVALID_INDUSTRY if the number does not monitor an industry.
  */
-static inline IndustryID DecodeMonitorIndustry(CargoMonitorID num)
+static INLINE IndustryID DecodeMonitorIndustry(CargoMonitorID num)
 {
 	if (!MonitorMonitorsIndustry(num)) return INVALID_INDUSTRY;
 	return GB(num, CCB_TOWN_IND_NUMBER_START, CCB_TOWN_IND_NUMBER_LENGTH);
@@ -133,7 +133,7 @@
  * @param num Cargo monitoring number to decode.
  * @return The extracted town id, or #INVALID_TOWN if the number does not monitor a town.
  */
-static inline TownID DecodeMonitorTown(CargoMonitorID num)
+static INLINE TownID DecodeMonitorTown(CargoMonitorID num)
 {
 	if (MonitorMonitorsIndustry(num)) return INVALID_TOWN;
 	return GB(num, CCB_TOWN_IND_NUMBER_START, CCB_TOWN_IND_NUMBER_LENGTH);
diff --git a/src/cargopacket.cpp b/src/cargopacket.cpp
--- a/src/cargopacket.cpp
+++ b/src/cargopacket.cpp
@@ -82,7 +82,7 @@
  * @param new_size Size of the remaining part.
  * @return Split off part, or NULL if no packet could be allocated!
  */
-inline CargoPacket *CargoPacket::Split(uint new_size)
+INLINE CargoPacket *CargoPacket::Split(uint new_size)
 {
 	if (!CargoPacket::CanAllocateItem()) return NULL;
 
@@ -97,7 +97,7 @@
  * Merge another packet into this one.
  * @param cp Packet to be merged in.
  */
-inline void CargoPacket::Merge(CargoPacket *cp)
+INLINE void CargoPacket::Merge(CargoPacket *cp)
 {
 	this->count += cp->count;
 	this->feeder_share += cp->feeder_share;
diff --git a/src/cargopacket.h b/src/cargopacket.h
--- a/src/cargopacket.h
+++ b/src/cargopacket.h
@@ -69,7 +69,7 @@
 	 * Gets the number of 'items' in this packet.
 	 * @return Item count.
 	 */
-	inline uint16 Count() const
+	INLINE uint16 Count() const
 	{
 		return this->count;
 	}
@@ -79,7 +79,7 @@
 	 * the feeder chain.
 	 * @return Feeder share.
 	 */
-	inline Money FeederShare() const
+	INLINE Money FeederShare() const
 	{
 		return this->feeder_share;
 	}
@@ -90,7 +90,7 @@
 	 * it is capped at 255.
 	 * @return Length this cargo has been in transit.
 	 */
-	inline byte DaysInTransit() const
+	INLINE byte DaysInTransit() const
 	{
 		return this->days_in_transit;
 	}
@@ -99,7 +99,7 @@
 	 * Gets the type of the cargo's source. industry, town or head quarter.
 	 * @return Source type.
 	 */
-	inline SourceType SourceSubsidyType() const
+	INLINE SourceType SourceSubsidyType() const
 	{
 		return this->source_type;
 	}
@@ -108,7 +108,7 @@
 	 * Gets the ID of the cargo's source. An IndustryID, TownID or CompanyID.
 	 * @return Source ID.
 	 */
-	inline SourceID SourceSubsidyID() const
+	INLINE SourceID SourceSubsidyID() const
 	{
 		return this->source_id;
 	}
@@ -117,7 +117,7 @@
 	 * Gets the ID of the station where the cargo was loaded for the first time.
 	 * @return StationID.
 	 */
-	inline SourceID SourceStation() const
+	INLINE SourceID SourceStation() const
 	{
 		return this->source;
 	}
@@ -126,7 +126,7 @@
 	 * Gets the coordinates of the cargo's source station.
 	 * @return Source station's coordinates.
 	 */
-	inline TileIndex SourceStationXY() const
+	INLINE TileIndex SourceStationXY() const
 	{
 		return this->source_xy;
 	}
@@ -135,7 +135,7 @@
 	 * Gets the coordinates of the cargo's last loading station.
 	 * @return Last loading station's coordinates.
 	 */
-	inline TileIndex LoadedAtXY() const
+	INLINE TileIndex LoadedAtXY() const
 	{
 		return this->loaded_at_xy;
 	}
@@ -203,7 +203,7 @@
 	 * Returns a pointer to the cargo packet list (so you can iterate over it etc).
 	 * @return Pointer to the packet list.
 	 */
-	inline const List *Packets() const
+	INLINE const List *Packets() const
 	{
 		return &this->packets;
 	}
@@ -212,7 +212,7 @@
 	 * Checks whether this list is empty.
 	 * @return True if and only if the list is empty.
 	 */
-	inline bool Empty() const
+	INLINE bool Empty() const
 	{
 		return this->count == 0;
 	}
@@ -221,7 +221,7 @@
 	 * Returns the number of cargo entities in this list.
 	 * @return The before mentioned number.
 	 */
-	inline uint Count() const
+	INLINE uint Count() const
 	{
 		return this->count;
 	}
@@ -230,7 +230,7 @@
 	 * Returns source of the first cargo packet in this list.
 	 * @return The before mentioned source.
 	 */
-	inline StationID Source() const
+	INLINE StationID Source() const
 	{
 		return this->Empty() ? INVALID_STATION : this->packets.front()->source;
 	}
@@ -239,7 +239,7 @@
 	 * Returns average number of days in transit for a cargo entity.
 	 * @return The before mentioned number.
 	 */
-	inline uint DaysInTransit() const
+	INLINE uint DaysInTransit() const
 	{
 		return this->count == 0 ? 0 : this->cargo_days_in_transit / this->count;
 	}
@@ -277,7 +277,7 @@
 	 * Returns total sum of the feeder share for all packets.
 	 * @return The before mentioned number.
 	 */
-	inline Money FeederShare() const
+	INLINE Money FeederShare() const
 	{
 		return this->feeder_share;
 	}
diff --git a/src/cargotype.h b/src/cargotype.h
--- a/src/cargotype.h
+++ b/src/cargotype.h
@@ -86,7 +86,7 @@
 	 * Determines index of this cargospec
 	 * @return index (in the CargoSpec::array array)
 	 */
-	inline CargoID Index() const
+	INLINE CargoID Index() const
 	{
 		return this - CargoSpec::array;
 	}
@@ -96,7 +96,7 @@
 	 * @return is this cargospec valid?
 	 * @note assert(cs->IsValid()) can be triggered when GRF config is modified
 	 */
-	inline bool IsValid() const
+	INLINE bool IsValid() const
 	{
 		return this->bitnum != INVALID_CARGO;
 	}
@@ -105,7 +105,7 @@
 	 * Total number of cargospecs, both valid and invalid
 	 * @return length of CargoSpec::array
 	 */
-	static inline size_t GetArraySize()
+	static INLINE size_t GetArraySize()
 	{
 		return lengthof(CargoSpec::array);
 	}
@@ -115,7 +115,7 @@
 	 * @param index ID of cargo
 	 * @pre index is a valid cargo ID
 	 */
-	static inline CargoSpec *Get(size_t index)
+	static INLINE CargoSpec *Get(size_t index)
 	{
 		assert(index < lengthof(CargoSpec::array));
 		return &CargoSpec::array[index];
@@ -146,7 +146,7 @@
  * @param cc Cargo class.
  * @return The type fits in the class.
  */
-static inline bool IsCargoInClass(CargoID c, CargoClass cc)
+static INLINE bool IsCargoInClass(CargoID c, CargoClass cc)
 {
 	return (CargoSpec::Get(c)->classes & cc) != 0;
 }
diff --git a/src/clear_cmd.cpp b/src/clear_cmd.cpp
--- a/src/clear_cmd.cpp
+++ b/src/clear_cmd.cpp
@@ -210,7 +210,7 @@
  * @param tile tile to check
  * @return does this tile have at least one desert tile around?
  */
-static inline bool NeighbourIsDesert(TileIndex tile)
+static INLINE bool NeighbourIsDesert(TileIndex tile)
 {
 	return GetTropicZone(tile + TileDiffXY(  1,  0)) == TROPICZONE_DESERT ||
 			GetTropicZone(tile + TileDiffXY( -1,  0)) == TROPICZONE_DESERT ||
diff --git a/src/clear_map.h b/src/clear_map.h
--- a/src/clear_map.h
+++ b/src/clear_map.h
@@ -34,7 +34,7 @@
  * @pre IsTileType(t, MP_CLEAR)
  * @return whether the tile is covered with snow.
  */
-static inline bool IsSnowTile(TileIndex t)
+static INLINE bool IsSnowTile(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
 	return HasBit(_m[t].m3, 4);
@@ -46,7 +46,7 @@
  * @pre IsTileType(t, MP_CLEAR)
  * @return the ground type
  */
-static inline ClearGround GetRawClearGround(TileIndex t)
+static INLINE ClearGround GetRawClearGround(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
 	return (ClearGround)GB(_m[t].m5, 2, 3);
@@ -58,7 +58,7 @@
  * @pre IsTileType(t, MP_CLEAR)
  * @return the ground type
  */
-static inline ClearGround GetClearGround(TileIndex t)
+static INLINE ClearGround GetClearGround(TileIndex t)
 {
 	if (IsSnowTile(t)) return CLEAR_SNOW;
 	return GetRawClearGround(t);
@@ -70,7 +70,7 @@
  * @param ct the ground type
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline bool IsClearGround(TileIndex t, ClearGround ct)
+static INLINE bool IsClearGround(TileIndex t, ClearGround ct)
 {
 	return GetClearGround(t) == ct;
 }
@@ -82,7 +82,7 @@
  * @pre IsTileType(t, MP_CLEAR)
  * @return the density
  */
-static inline uint GetClearDensity(TileIndex t)
+static INLINE uint GetClearDensity(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
 	return GB(_m[t].m5, 0, 2);
@@ -94,7 +94,7 @@
  * @param d the amount to increment the density with
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void AddClearDensity(TileIndex t, int d)
+static INLINE void AddClearDensity(TileIndex t, int d)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
 	_m[t].m5 += d;
@@ -106,7 +106,7 @@
  * @param d the new density
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void SetClearDensity(TileIndex t, uint d)
+static INLINE void SetClearDensity(TileIndex t, uint d)
 {
 	assert(IsTileType(t, MP_CLEAR));
 	SB(_m[t].m5, 0, 2, d);
@@ -119,7 +119,7 @@
  * @pre IsTileType(t, MP_CLEAR)
  * @return the value of the counter
  */
-static inline uint GetClearCounter(TileIndex t)
+static INLINE uint GetClearCounter(TileIndex t)
 {
 	assert(IsTileType(t, MP_CLEAR));
 	return GB(_m[t].m5, 5, 3);
@@ -131,7 +131,7 @@
  * @param c the amount to increment the counter with
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void AddClearCounter(TileIndex t, int c)
+static INLINE void AddClearCounter(TileIndex t, int c)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
 	_m[t].m5 += c << 5;
@@ -143,7 +143,7 @@
  * @param c the amount to set the counter to
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void SetClearCounter(TileIndex t, uint c)
+static INLINE void SetClearCounter(TileIndex t, uint c)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
 	SB(_m[t].m5, 5, 3, c);
@@ -157,7 +157,7 @@
  * @param density the density of the ground tile
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void SetClearGroundDensity(TileIndex t, ClearGround type, uint density)
+static INLINE void SetClearGroundDensity(TileIndex t, ClearGround type, uint density)
 {
 	assert(IsTileType(t, MP_CLEAR)); // XXX incomplete
 	_m[t].m5 = 0 << 5 | type << 2 | density;
@@ -170,7 +170,7 @@
  * @pre GetClearGround(t) == CLEAR_FIELDS
  * @return the field type
  */
-static inline uint GetFieldType(TileIndex t)
+static INLINE uint GetFieldType(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
 	return GB(_m[t].m3, 0, 4);
@@ -182,7 +182,7 @@
  * @param f the field type
  * @pre GetClearGround(t) == CLEAR_FIELDS
  */
-static inline void SetFieldType(TileIndex t, uint f)
+static INLINE void SetFieldType(TileIndex t, uint f)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS); // XXX incomplete
 	SB(_m[t].m3, 0, 4, f);
@@ -194,7 +194,7 @@
  * @pre GetClearGround(t) == CLEAR_FIELDS
  * @return the industry that made the field
  */
-static inline IndustryID GetIndustryIndexOfField(TileIndex t)
+static INLINE IndustryID GetIndustryIndexOfField(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
 	return(IndustryID) _m[t].m2;
@@ -206,7 +206,7 @@
  * @param i the industry that made the field
  * @pre GetClearGround(t) == CLEAR_FIELDS
  */
-static inline void SetIndustryIndexOfField(TileIndex t, IndustryID i)
+static INLINE void SetIndustryIndexOfField(TileIndex t, IndustryID i)
 {
 	assert(GetClearGround(t) == CLEAR_FIELDS);
 	_m[t].m2 = i;
@@ -219,7 +219,7 @@
  * @pre IsClearGround(t, CLEAR_FIELDS)
  * @return 0 if there is no fence, otherwise the fence type
  */
-static inline uint GetFenceSE(TileIndex t)
+static INLINE uint GetFenceSE(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	return GB(_m[t].m4, 2, 3);
@@ -232,7 +232,7 @@
  * @param h 0 if there is no fence, otherwise the fence type
  * @pre IsClearGround(t, CLEAR_FIELDS)
  */
-static inline void SetFenceSE(TileIndex t, uint h)
+static INLINE void SetFenceSE(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	SB(_m[t].m4, 2, 3, h);
@@ -244,7 +244,7 @@
  * @pre IsClearGround(t, CLEAR_FIELDS)
  * @return 0 if there is no fence, otherwise the fence type
  */
-static inline uint GetFenceSW(TileIndex t)
+static INLINE uint GetFenceSW(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	return GB(_m[t].m4, 5, 3);
@@ -257,7 +257,7 @@
  * @param h 0 if there is no fence, otherwise the fence type
  * @pre IsClearGround(t, CLEAR_FIELDS)
  */
-static inline void SetFenceSW(TileIndex t, uint h)
+static INLINE void SetFenceSW(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	SB(_m[t].m4, 5, 3, h);
@@ -269,7 +269,7 @@
  * @pre IsClearGround(t, CLEAR_FIELDS)
  * @return 0 if there is no fence, otherwise the fence type
  */
-static inline uint GetFenceNE(TileIndex t)
+static INLINE uint GetFenceNE(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	return GB(_m[t].m3, 5, 3);
@@ -282,7 +282,7 @@
  * @param h 0 if there is no fence, otherwise the fence type
  * @pre IsClearGround(t, CLEAR_FIELDS)
  */
-static inline void SetFenceNE(TileIndex t, uint h)
+static INLINE void SetFenceNE(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	SB(_m[t].m3, 5, 3, h);
@@ -294,7 +294,7 @@
  * @pre IsClearGround(t, CLEAR_FIELDS)
  * @return 0 if there is no fence, otherwise the fence type
  */
-static inline uint GetFenceNW(TileIndex t)
+static INLINE uint GetFenceNW(TileIndex t)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	return GB(_m[t].m6, 2, 3);
@@ -307,7 +307,7 @@
  * @param h 0 if there is no fence, otherwise the fence type
  * @pre IsClearGround(t, CLEAR_FIELDS)
  */
-static inline void SetFenceNW(TileIndex t, uint h)
+static INLINE void SetFenceNW(TileIndex t, uint h)
 {
 	assert(IsClearGround(t, CLEAR_FIELDS));
 	SB(_m[t].m6, 2, 3, h);
@@ -320,7 +320,7 @@
  * @param g       the type of ground
  * @param density the density of the grass/snow/desert etc
  */
-static inline void MakeClear(TileIndex t, ClearGround g, uint density)
+static INLINE void MakeClear(TileIndex t, ClearGround g, uint density)
 {
 	/* If this is a non-bridgeable tile, clear the bridge bits while the rest
 	 * of the tile information is still here. */
@@ -344,7 +344,7 @@
  * @param field_type the 'growth' level of the field
  * @param industry   the industry this tile belongs to
  */
-static inline void MakeField(TileIndex t, uint field_type, IndustryID industry)
+static INLINE void MakeField(TileIndex t, uint field_type, IndustryID industry)
 {
 	SetTileType(t, MP_CLEAR);
 	_m[t].m1 = 0;
@@ -363,7 +363,7 @@
  * @param density The density of snowiness.
  * @pre GetClearGround(t) != CLEAR_SNOW
  */
-static inline void MakeSnow(TileIndex t, uint density = 0)
+static INLINE void MakeSnow(TileIndex t, uint density = 0)
 {
 	assert(GetClearGround(t) != CLEAR_SNOW);
 	SetBit(_m[t].m3, 4);
@@ -379,7 +379,7 @@
  * @param t the tile to clear of snow
  * @pre GetClearGround(t) == CLEAR_SNOW
  */
-static inline void ClearSnow(TileIndex t)
+static INLINE void ClearSnow(TileIndex t)
 {
 	assert(GetClearGround(t) == CLEAR_SNOW);
 	ClrBit(_m[t].m3, 4);
diff --git a/src/cmd_helper.h b/src/cmd_helper.h
--- a/src/cmd_helper.h
+++ b/src/cmd_helper.h
@@ -23,7 +23,7 @@
  * @tparam U The type of data passed to us.
  * @param v The data to extract the value from.
  */
-template<typename T, uint S, uint N, typename U> static inline T Extract(U v)
+template<typename T, uint S, uint N, typename U> static INLINE T Extract(U v)
 {
 	/* Check if there are enough bits in v */
 	assert_tcompile(N == EnumPropsT<T>::num_bits);
diff --git a/src/command_func.h b/src/command_func.h
--- a/src/command_func.h
+++ b/src/command_func.h
@@ -59,7 +59,7 @@
  * @param cmd_flags Flags from GetCommandFlags
  * @return flags for DoCommand
  */
-static inline DoCommandFlag CommandFlagsToDCFlags(CommandFlags cmd_flags)
+static INLINE DoCommandFlag CommandFlagsToDCFlags(CommandFlags cmd_flags)
 {
 	DoCommandFlag flags = DC_NONE;
 	if (cmd_flags & CMD_NO_WATER) flags |= DC_NO_WATER;
diff --git a/src/command_type.h b/src/command_type.h
--- a/src/command_type.h
+++ b/src/command_type.h
@@ -58,7 +58,7 @@
 	 * Adds the given cost to the cost of the command.
 	 * @param cost the cost to add
 	 */
-	inline void AddCost(const Money &cost)
+	INLINE void AddCost(const Money &cost)
 	{
 		this->cost += cost;
 	}
@@ -69,7 +69,7 @@
 	 * Multiplies the cost of the command by the given factor.
 	 * @param factor factor to multiply the costs with
 	 */
-	inline void MultiplyCost(int factor)
+	INLINE void MultiplyCost(int factor)
 	{
 		this->cost *= factor;
 	}
@@ -78,7 +78,7 @@
 	 * The costs as made up to this moment
 	 * @return the costs
 	 */
-	inline Money GetCost() const
+	INLINE Money GetCost() const
 	{
 		return this->cost;
 	}
@@ -87,7 +87,7 @@
 	 * The expense type of the cost
 	 * @return the expense type
 	 */
-	inline ExpensesType GetExpensesType() const
+	INLINE ExpensesType GetExpensesType() const
 	{
 		return this->expense_type;
 	}
@@ -137,7 +137,7 @@
 	 * Did this command succeed?
 	 * @return true if and only if it succeeded
 	 */
-	inline bool Succeeded() const
+	INLINE bool Succeeded() const
 	{
 		return this->success;
 	}
@@ -146,7 +146,7 @@
 	 * Did this command fail?
 	 * @return true if and only if it failed
 	 */
-	inline bool Failed() const
+	INLINE bool Failed() const
 	{
 		return !this->success;
 	}
diff --git a/src/company_base.h b/src/company_base.h
--- a/src/company_base.h
+++ b/src/company_base.h
@@ -129,7 +129,7 @@
 	 * @param index Index in the pool.
 	 * @return \c true if it is a valid, computer controlled company, else \c false.
 	 */
-	static inline bool IsValidAiID(size_t index)
+	static INLINE bool IsValidAiID(size_t index)
 	{
 		const Company *c = Company::GetIfValid(index);
 		return c != NULL && c->is_ai;
@@ -141,7 +141,7 @@
 	 * @return \c true if it is a valid, human controlled company, else \c false.
 	 * @note If you know that \a index refers to a valid company, you can use #IsHumanID() instead.
 	 */
-	static inline bool IsValidHumanID(size_t index)
+	static INLINE bool IsValidHumanID(size_t index)
 	{
 		const Company *c = Company::GetIfValid(index);
 		return c != NULL && !c->is_ai;
@@ -154,7 +154,7 @@
 	 * @pre \a index must be a valid CompanyID.
 	 * @note If you don't know whether \a index refers to a valid company, you should use #IsValidHumanID() instead.
 	 */
-	static inline bool IsHumanID(size_t index)
+	static INLINE bool IsHumanID(size_t index)
 	{
 		return !Company::Get(index)->is_ai;
 	}
diff --git a/src/company_func.h b/src/company_func.h
--- a/src/company_func.h
+++ b/src/company_func.h
@@ -41,7 +41,7 @@
  * Is the current company the local company?
  * @return \c true of the current company is the local company, \c false otherwise.
  */
-static inline bool IsLocalCompany()
+static INLINE bool IsLocalCompany()
 {
 	return _local_company == _current_company;
 }
@@ -51,7 +51,7 @@
  * @param company Company where interaction is needed with.
  * @return Gives \c true if the user can answer questions interactively as representative of \a company, else \c false
  */
-static inline bool IsInteractiveCompany(CompanyID company)
+static INLINE bool IsInteractiveCompany(CompanyID company)
 {
 	return company == _local_company;
 }
diff --git a/src/company_manager_face.h b/src/company_manager_face.h
--- a/src/company_manager_face.h
+++ b/src/company_manager_face.h
@@ -95,7 +95,7 @@
  * @pre _cmf_info[cmfv].valid_values[ge] != 0
  * @return the requested bits
  */
-static inline uint GetCompanyManagerFaceBits(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
+static INLINE uint GetCompanyManagerFaceBits(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
 {
 	assert(_cmf_info[cmfv].valid_values[ge] != 0);
 
@@ -110,7 +110,7 @@
  * @param val  the new value
  * @pre val < _cmf_info[cmfv].valid_values[ge]
  */
-static inline void SetCompanyManagerFaceBits(CompanyManagerFace &cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge, uint val)
+static INLINE void SetCompanyManagerFaceBits(CompanyManagerFace &cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge, uint val)
 {
 	assert(val < _cmf_info[cmfv].valid_values[ge]);
 
@@ -129,7 +129,7 @@
  *
  * @pre 0 <= val < _cmf_info[cmfv].valid_values[ge]
  */
-static inline void IncreaseCompanyManagerFaceBits(CompanyManagerFace &cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge, int8 amount)
+static INLINE void IncreaseCompanyManagerFaceBits(CompanyManagerFace &cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge, int8 amount)
 {
 	int8 val = GetCompanyManagerFaceBits(cmf, cmfv, ge) + amount; // the new value for the cmfv
 
@@ -150,7 +150,7 @@
  * @param ge   the gender and ethnicity of the face
  * @return true if and only if the bits are valid
  */
-static inline bool AreCompanyManagerFaceBitsValid(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
+static INLINE bool AreCompanyManagerFaceBitsValid(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
 {
 	return GB(cmf, _cmf_info[cmfv].offset, _cmf_info[cmfv].length) < _cmf_info[cmfv].valid_values[ge];
 }
@@ -163,7 +163,7 @@
  * @pre val < (1U << _cmf_info[cmfv].length), i.e. val has a value of 0..2^(bits used for this variable)-1
  * @return the scaled value
  */
-static inline uint ScaleCompanyManagerFaceValue(CompanyManagerFaceVariable cmfv, GenderEthnicity ge, uint val)
+static INLINE uint ScaleCompanyManagerFaceValue(CompanyManagerFaceVariable cmfv, GenderEthnicity ge, uint val)
 {
 	assert(val < (1U << _cmf_info[cmfv].length));
 
@@ -175,7 +175,7 @@
  *
  * @param cmf the company manager's face to write the bits to
  */
-static inline void ScaleAllCompanyManagerFaceBits(CompanyManagerFace &cmf)
+static INLINE void ScaleAllCompanyManagerFaceBits(CompanyManagerFace &cmf)
 {
 	IncreaseCompanyManagerFaceBits(cmf, CMFV_ETHNICITY, GE_WM, 0); // scales the ethnicity
 
@@ -204,7 +204,7 @@
  *
  * @pre scale 'ge' to a valid gender/ethnicity combination
  */
-static inline void RandomCompanyManagerFaceBits(CompanyManagerFace &cmf, GenderEthnicity ge, bool adv)
+static INLINE void RandomCompanyManagerFaceBits(CompanyManagerFace &cmf, GenderEthnicity ge, bool adv)
 {
 	cmf = InteractiveRandom(); // random all company manager's face bits
 
@@ -230,7 +230,7 @@
  * @pre _cmf_info[cmfv].valid_values[ge] != 0
  * @return sprite to draw
  */
-static inline SpriteID GetCompanyManagerFaceSprite(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
+static INLINE SpriteID GetCompanyManagerFaceSprite(CompanyManagerFace cmf, CompanyManagerFaceVariable cmfv, GenderEthnicity ge)
 {
 	assert(_cmf_info[cmfv].valid_values[ge] != 0);
 
diff --git a/src/console.cpp b/src/console.cpp
--- a/src/console.cpp
+++ b/src/console.cpp
@@ -318,7 +318,7 @@
 }
 
 /** copy in an argument into the aliasstream */
-static inline int IConsoleCopyInParams(char *dst, const char *src, uint bufpos)
+static INLINE int IConsoleCopyInParams(char *dst, const char *src, uint bufpos)
 {
 	/* len is the amount of bytes to add excluding the '\0'-termination */
 	int len = min(ICON_MAX_STREAMSIZE - bufpos - 1, (uint)strlen(src));
diff --git a/src/console_cmds.cpp b/src/console_cmds.cpp
--- a/src/console_cmds.cpp
+++ b/src/console_cmds.cpp
@@ -61,7 +61,7 @@
  * Check network availability and inform in console about failure of detection.
  * @return Network availability.
  */
-static inline bool NetworkAvailable(bool echo)
+static INLINE bool NetworkAvailable(bool echo)
 {
 	if (!_network_available) {
 		if (echo) IConsoleError("You cannot use this command because there is no network available.");
diff --git a/src/console_gui.cpp b/src/console_gui.cpp
--- a/src/console_gui.cpp
+++ b/src/console_gui.cpp
@@ -145,7 +145,7 @@
 	SetWindowDirty(WC_CONSOLE, 0);
 }
 
-static inline void IConsoleResetHistoryPos()
+static INLINE void IConsoleResetHistoryPos()
 {
 	_iconsole_historypos = -1;
 }
diff --git a/src/core/alloc_func.hpp b/src/core/alloc_func.hpp
--- a/src/core/alloc_func.hpp
+++ b/src/core/alloc_func.hpp
@@ -28,7 +28,7 @@
  * @param element_size Size of the structure to allocate.
  * @param num_elements Number of elements to allocate.
  */
-static inline void CheckAllocationConstraints(size_t element_size, size_t num_elements)
+static INLINE void CheckAllocationConstraints(size_t element_size, size_t num_elements)
 {
 	if (num_elements > SIZE_MAX / element_size) MallocError(SIZE_MAX);
 }
@@ -40,7 +40,7 @@
  * @param num_elements Number of elements to allocate.
  */
 template <typename T>
-static inline void CheckAllocationConstraints(size_t num_elements)
+static INLINE void CheckAllocationConstraints(size_t num_elements)
 {
 	CheckAllocationConstraints(sizeof(T), num_elements);
 }
@@ -56,7 +56,7 @@
  * @return NULL when num_elements == 0, non-NULL otherwise.
  */
 template <typename T>
-static inline T *MallocT(size_t num_elements)
+static INLINE T *MallocT(size_t num_elements)
 {
 	/*
 	 * MorphOS cannot handle 0 elements allocations, or rather that always
@@ -84,7 +84,7 @@
  * @return NULL when num_elements == 0, non-NULL otherwise.
  */
 template <typename T>
-static inline T *CallocT(size_t num_elements)
+static INLINE T *CallocT(size_t num_elements)
 {
 	/*
 	 * MorphOS cannot handle 0 elements allocations, or rather that always
@@ -110,7 +110,7 @@
  * @return NULL when num_elements == 0, non-NULL otherwise.
  */
 template <typename T>
-static inline T *ReallocT(T *t_ptr, size_t num_elements)
+static INLINE T *ReallocT(T *t_ptr, size_t num_elements)
 {
 	/*
 	 * MorphOS cannot handle 0 elements allocations, or rather that always
diff --git a/src/core/alloc_type.hpp b/src/core/alloc_type.hpp
--- a/src/core/alloc_type.hpp
+++ b/src/core/alloc_type.hpp
@@ -48,7 +48,7 @@
 	 * Gets a pointer to the data stored in this wrapper.
 	 * @return the pointer.
 	 */
-	inline operator T *()
+	INLINE operator T *()
 	{
 		return data;
 	}
@@ -57,7 +57,7 @@
 	 * Gets a pointer to the data stored in this wrapper.
 	 * @return the pointer.
 	 */
-	inline T *operator -> ()
+	INLINE T *operator -> ()
 	{
 		return data;
 	}
@@ -67,7 +67,7 @@
 	 * @note needed because endof does not work properly for pointers.
 	 * @return the 'endof' pointer.
 	 */
-	inline T *EndOf()
+	INLINE T *EndOf()
 	{
 #if !defined(__NDS__)
 		return endof(data);
@@ -137,7 +137,7 @@
 	 * Get the currently allocated buffer.
 	 * @return the buffer
 	 */
-	inline const T *GetBuffer() const
+	INLINE const T *GetBuffer() const
 	{
 		return this->buffer;
 	}
@@ -158,26 +158,26 @@
 	 * @param size the amount of bytes to allocate.
 	 * @return the given amounts of bytes zeroed.
 	 */
-	inline void *operator new(size_t size) { return CallocT<byte>(size); }
+	INLINE void *operator new(size_t size) { return CallocT<byte>(size); }
 
 	/**
 	 * Memory allocator for an array of class instances.
 	 * @param size the amount of bytes to allocate.
 	 * @return the given amounts of bytes zeroed.
 	 */
-	inline void *operator new[](size_t size) { return CallocT<byte>(size); }
+	INLINE void *operator new[](size_t size) { return CallocT<byte>(size); }
 
 	/**
 	 * Memory release for a single class instance.
 	 * @param ptr  the memory to free.
 	 */
-	inline void operator delete(void *ptr) { free(ptr); }
+	INLINE void operator delete(void *ptr) { free(ptr); }
 
 	/**
 	 * Memory release for an array of class instances.
 	 * @param ptr  the memory to free.
 	 */
-	inline void operator delete[](void *ptr) { free(ptr); }
+	INLINE void operator delete[](void *ptr) { free(ptr); }
 };
 
 /**
@@ -197,21 +197,21 @@
 	 * Take ownership of a new pointer and free the old one if needed.
 	 * @param ptr NEw pointer.
 	 */
-	inline void Assign(T *ptr)
+	INLINE void Assign(T *ptr)
 	{
 		free(this->ptr);
 		this->ptr = ptr;
 	}
 
 	/** Dereference pointer. */
-	inline T *operator ->() { return this->ptr; }
+	INLINE T *operator ->() { return this->ptr; }
 	/** Dereference pointer. */
-	inline const T *operator ->() const { return this->ptr; }
+	INLINE const T *operator ->() const { return this->ptr; }
 
 	/** Cast to underlaying regular pointer. */
-	inline operator T *() { return this->ptr; }
+	INLINE operator T *() { return this->ptr; }
 	/** Cast to underlaying regular pointer. */
-	inline operator const T *() const { return this->ptr; }
+	INLINE operator const T *() const { return this->ptr; }
 };
 
 #endif /* ALLOC_TYPE_HPP */
diff --git a/src/core/bitmath_func.hpp b/src/core/bitmath_func.hpp
--- a/src/core/bitmath_func.hpp
+++ b/src/core/bitmath_func.hpp
@@ -29,7 +29,7 @@
  * @return The selected bits, aligned to a LSB.
  */
 template <typename T>
-static inline uint GB(const T x, const uint8 s, const uint8 n)
+static INLINE uint GB(const T x, const uint8 s, const uint8 n)
 {
 	return (x >> s) & (((T)1U << n) - 1);
 }
@@ -53,7 +53,7 @@
  * @return The new value of \a x
  */
 template <typename T, typename U>
-static inline T SB(T &x, const uint8 s, const uint8 n, const U d)
+static INLINE T SB(T &x, const uint8 s, const uint8 n, const U d)
 {
 	x &= (T)(~((((T)1U << n) - 1) << s));
 	x |= (T)(d << s);
@@ -76,7 +76,7 @@
  * @return The new value of x
  */
 template <typename T, typename U>
-static inline T AB(T &x, const uint8 s, const uint8 n, const U i)
+static INLINE T AB(T &x, const uint8 s, const uint8 n, const U i)
 {
 	const T mask = ((((T)1U << n) - 1) << s);
 	x = (T)((x & ~mask) | ((x + (i << s)) & mask));
@@ -95,7 +95,7 @@
  * @return True if the bit is set, false else.
  */
 template <typename T>
-static inline bool HasBit(const T x, const uint8 y)
+static INLINE bool HasBit(const T x, const uint8 y)
 {
 	return (x & ((T)1U << y)) != 0;
 }
@@ -112,7 +112,7 @@
  * @return The new value of the old value with the bit set
  */
 template <typename T>
-static inline T SetBit(T &x, const uint8 y)
+static INLINE T SetBit(T &x, const uint8 y)
 {
 	return x = (T)(x | ((T)1U << y));
 }
@@ -141,7 +141,7 @@
  * @return The new value of the old value with the bit cleared
  */
 template <typename T>
-static inline T ClrBit(T &x, const uint8 y)
+static INLINE T ClrBit(T &x, const uint8 y)
 {
 	return x = (T)(x & ~((T)1U << y));
 }
@@ -170,7 +170,7 @@
  * @return The new value of the old value with the bit toggled
  */
 template <typename T>
-static inline T ToggleBit(T &x, const uint8 y)
+static INLINE T ToggleBit(T &x, const uint8 y)
 {
 	return x = (T)(x ^ ((T)1U << y));
 }
@@ -205,7 +205,7 @@
  * @return The position of the first bit which is set
  * @see FIND_FIRST_BIT
  */
-static inline uint8 FindFirstBit2x64(const int value)
+static INLINE uint8 FindFirstBit2x64(const int value)
 {
 	if ((value & 0xFF) == 0) {
 		return FIND_FIRST_BIT((value >> 8) & 0x3F) + 8;
@@ -228,7 +228,7 @@
  * @return The new value with the first bit cleared
  */
 template <typename T>
-static inline T KillFirstBit(T value)
+static INLINE T KillFirstBit(T value)
 {
 	return value &= (T)(value - 1);
 }
@@ -240,7 +240,7 @@
  * @return the number of bits.
  */
 template <typename T>
-static inline uint CountBits(T value)
+static INLINE uint CountBits(T value)
 {
 	uint num;
 
@@ -263,7 +263,7 @@
  * @return does \a value have exactly 1 bit set?
  */
 template <typename T>
-static inline bool HasExactlyOneBit(T value)
+static INLINE bool HasExactlyOneBit(T value)
 {
 	return value != 0 && (value & (value - 1)) == 0;
 }
@@ -275,7 +275,7 @@
  * @return does \a value have at most 1 bit set?
  */
 template <typename T>
-static inline bool HasAtMostOneBit(T value)
+static INLINE bool HasAtMostOneBit(T value)
 {
 	return (value & (value - 1)) == 0;
 }
@@ -289,7 +289,7 @@
  * @return A bit rotated number
  */
 template <typename T>
-static inline T ROL(const T x, const uint8 n)
+static INLINE T ROL(const T x, const uint8 n)
 {
 	return (T)(x << n | x >> (sizeof(x) * 8 - n));
 }
@@ -303,7 +303,7 @@
  * @return A bit rotated number
  */
 template <typename T>
-static inline T ROR(const T x, const uint8 n)
+static INLINE T ROR(const T x, const uint8 n)
 {
 	return (T)(x >> n | x << (sizeof(x) * 8 - n));
 }
@@ -365,7 +365,7 @@
 	 * @param x the variable to bitswap
 	 * @return the bitswapped value.
 	 */
-	static inline uint32 BSWAP32(uint32 x)
+	static INLINE uint32 BSWAP32(uint32 x)
 	{
 #if !defined(__ICC) && defined(__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4)  && __GNUC_MINOR__ >= 3))
 		/* GCC >= 4.3 provides a builtin, resulting in faster code */
@@ -380,7 +380,7 @@
 	 * @param x the variable to bitswap
 	 * @return the bitswapped value.
 	 */
-	static inline uint16 BSWAP16(uint16 x)
+	static INLINE uint16 BSWAP16(uint16 x)
 	{
 		return (x >> 8) | (x << 8);
 	}
diff --git a/src/core/endian_func.hpp b/src/core/endian_func.hpp
--- a/src/core/endian_func.hpp
+++ b/src/core/endian_func.hpp
@@ -40,12 +40,12 @@
 	#define TO_LE32X(x)  (x)
 #endif /* TTD_ENDIAN == TTD_BIG_ENDIAN */
 
-static inline uint16 ReadLE16Aligned(const void *x)
+static INLINE uint16 ReadLE16Aligned(const void *x)
 {
 	return FROM_LE16(*(const uint16*)x);
 }
 
-static inline uint16 ReadLE16Unaligned(const void *x)
+static INLINE uint16 ReadLE16Unaligned(const void *x)
 {
 #if OTTD_ALIGNMENT == 1
 	return ((const byte*)x)[0] | ((const byte*)x)[1] << 8;
diff --git a/src/core/enum_type.hpp b/src/core/enum_type.hpp
--- a/src/core/enum_type.hpp
+++ b/src/core/enum_type.hpp
@@ -14,13 +14,13 @@
 
 /** Some enums need to have allowed incrementing (i.e. StationClassID) */
 #define DECLARE_POSTFIX_INCREMENT(type) \
-	inline type operator ++(type& e, int) \
+	INLINE type operator ++(type& e, int) \
 	{ \
 		type e_org = e; \
 		e = (type)((int)e + 1); \
 		return e_org; \
 	} \
-	inline type operator --(type& e, int) \
+	INLINE type operator --(type& e, int) \
 	{ \
 		type e_org = e; \
 		e = (type)((int)e - 1); \
@@ -31,13 +31,13 @@
 
 /** Operators to allow to work with enum as with type safe bit set in C++ */
 # define DECLARE_ENUM_AS_BIT_SET(mask_t) \
-	inline mask_t operator | (mask_t m1, mask_t m2) {return (mask_t)((int)m1 | m2);} \
-	inline mask_t operator & (mask_t m1, mask_t m2) {return (mask_t)((int)m1 & m2);} \
-	inline mask_t operator ^ (mask_t m1, mask_t m2) {return (mask_t)((int)m1 ^ m2);} \
-	inline mask_t& operator |= (mask_t& m1, mask_t m2) {m1 = m1 | m2; return m1;} \
-	inline mask_t& operator &= (mask_t& m1, mask_t m2) {m1 = m1 & m2; return m1;} \
-	inline mask_t& operator ^= (mask_t& m1, mask_t m2) {m1 = m1 ^ m2; return m1;} \
-	inline mask_t operator ~(mask_t m) {return (mask_t)(~(int)m);}
+	INLINE mask_t operator | (mask_t m1, mask_t m2) {return (mask_t)((int)m1 | m2);} \
+	INLINE mask_t operator & (mask_t m1, mask_t m2) {return (mask_t)((int)m1 & m2);} \
+	INLINE mask_t operator ^ (mask_t m1, mask_t m2) {return (mask_t)((int)m1 ^ m2);} \
+	INLINE mask_t& operator |= (mask_t& m1, mask_t m2) {m1 = m1 | m2; return m1;} \
+	INLINE mask_t& operator &= (mask_t& m1, mask_t m2) {m1 = m1 & m2; return m1;} \
+	INLINE mask_t& operator ^= (mask_t& m1, mask_t m2) {m1 = m1 ^ m2; return m1;} \
+	INLINE mask_t operator ~(mask_t m) {return (mask_t)(~(int)m);}
 
 
 /**
@@ -98,27 +98,27 @@
 	storage_type m_val;  ///< here we hold the actual value in small (i.e. byte) form
 
 	/** Cast operator - invoked then the value is assigned to the Tenum_t type */
-	inline operator enum_type () const
+	INLINE operator enum_type () const
 	{
 		return (enum_type)m_val;
 	}
 
 	/** Assignment operator (from Tenum_t type) */
-	inline TinyEnumT& operator = (enum_type e)
+	INLINE TinyEnumT& operator = (enum_type e)
 	{
 		m_val = (storage_type)e;
 		return *this;
 	}
 
 	/** Assignment operator (from Tenum_t type) */
-	inline TinyEnumT& operator = (uint u)
+	INLINE TinyEnumT& operator = (uint u)
 	{
 		m_val = (storage_type)u;
 		return *this;
 	}
 
 	/** postfix ++ operator on tiny type */
-	inline TinyEnumT operator ++ (int)
+	INLINE TinyEnumT operator ++ (int)
 	{
 		TinyEnumT org = *this;
 		if (++m_val >= end) m_val -= (storage_type)(end - begin);
@@ -126,7 +126,7 @@
 	}
 
 	/** prefix ++ operator on tiny type */
-	inline TinyEnumT& operator ++ ()
+	INLINE TinyEnumT& operator ++ ()
 	{
 		if (++m_val >= end) m_val -= (storage_type)(end - begin);
 		return *this;
@@ -140,34 +140,34 @@
 	storage_type m_val;  ///< here we hold the actual value in small (i.e. byte) form
 
 	/** Cast operator - invoked then the value is assigned to the storage_type */
-	inline operator enum_type () const
+	INLINE operator enum_type () const
 	{
 		return (enum_type)this->m_val;
 	}
 
 	/** Assignment operator (from enum_type) */
-	inline SimpleTinyEnumT &operator = (enum_type e)
+	INLINE SimpleTinyEnumT &operator = (enum_type e)
 	{
 		this->m_val = (storage_type)e;
 		return *this;
 	}
 
 	/** Assignment operator (from general uint) */
-	inline SimpleTinyEnumT &operator = (uint u)
+	INLINE SimpleTinyEnumT &operator = (uint u)
 	{
 		this->m_val = (storage_type)u;
 		return *this;
 	}
 
 	/** Bit math (or) assignment operator (from enum_type) */
-	inline SimpleTinyEnumT &operator |= (enum_type e)
+	INLINE SimpleTinyEnumT &operator |= (enum_type e)
 	{
 		this->m_val = (storage_type)((enum_type)this->m_val | e);
 		return *this;
 	}
 
 	/** Bit math (and) assignment operator (from enum_type) */
-	inline SimpleTinyEnumT &operator &= (enum_type e)
+	INLINE SimpleTinyEnumT &operator &= (enum_type e)
 	{
 		this->m_val = (storage_type)((enum_type)this->m_val & e);
 		return *this;
diff --git a/src/core/math_func.hpp b/src/core/math_func.hpp
--- a/src/core/math_func.hpp
+++ b/src/core/math_func.hpp
@@ -35,7 +35,7 @@
  * @return The greater value or a if equals
  */
 template <typename T>
-static inline T max(const T a, const T b)
+static INLINE T max(const T a, const T b)
 {
 	return (a >= b) ? a : b;
 }
@@ -51,7 +51,7 @@
  * @return The smaller value or b if equals
  */
 template <typename T>
-static inline T min(const T a, const T b)
+static INLINE T min(const T a, const T b)
 {
 	return (a < b) ? a : b;
 }
@@ -65,7 +65,7 @@
  * @param b The second integer
  * @return The smaller value
  */
-static inline int min(const int a, const int b)
+static INLINE int min(const int a, const int b)
 {
 	return min<int>(a, b);
 }
@@ -79,7 +79,7 @@
  * @param b The second unsigned integer
  * @return The smaller value
  */
-static inline uint minu(const uint a, const uint b)
+static INLINE uint minu(const uint a, const uint b)
 {
 	return min<uint>(a, b);
 }
@@ -92,7 +92,7 @@
  * @return The unsigned value
  */
 template <typename T>
-static inline T abs(const T a)
+static INLINE T abs(const T a)
 {
 	return (a < (T)0) ? -a : a;
 }
@@ -106,7 +106,7 @@
  * @return The smallest multiple of n equal or greater than x
  */
 template <typename T>
-static inline T Align(const T x, uint n)
+static INLINE T Align(const T x, uint n)
 {
 	assert((n & (n - 1)) == 0 && n != 0);
 	n--;
@@ -124,7 +124,7 @@
  * @see Align()
  */
 template <typename T>
-static inline T *AlignPtr(T *x, uint n)
+static INLINE T *AlignPtr(T *x, uint n)
 {
 	assert_compile(sizeof(size_t) == sizeof(void *));
 	return (T *)Align((size_t)x, n);
@@ -148,7 +148,7 @@
  * @see Clamp(int, int, int)
  */
 template <typename T>
-static inline T Clamp(const T a, const T min, const T max)
+static INLINE T Clamp(const T a, const T min, const T max)
 {
 	assert(min <= max);
 	if (a <= min) return min;
@@ -172,7 +172,7 @@
  * @returns A value between min and max which is closest to a.
  * @see ClampU(uint, uint, uint)
  */
-static inline int Clamp(const int a, const int min, const int max)
+static INLINE int Clamp(const int a, const int min, const int max)
 {
 	return Clamp<int>(a, min, max);
 }
@@ -193,7 +193,7 @@
  * @returns A value between min and max which is closest to a.
  * @see Clamp(int, int, int)
  */
-static inline uint ClampU(const uint a, const uint min, const uint max)
+static INLINE uint ClampU(const uint a, const uint min, const uint max)
 {
 	return Clamp<uint>(a, min, max);
 }
@@ -212,7 +212,7 @@
  * @return The 64-bit value reduced to a 32-bit value
  * @see Clamp(int, int, int)
  */
-static inline int32 ClampToI32(const int64 a)
+static INLINE int32 ClampToI32(const int64 a)
 {
 	return (int32)Clamp<int64>(a, INT32_MIN, INT32_MAX);
 }
@@ -224,7 +224,7 @@
  * @return The 64-bit value reduced to a 16-bit value
  * @see ClampU(uint, uint, uint)
  */
-static inline uint16 ClampToU16(const uint64 a)
+static INLINE uint16 ClampToU16(const uint64 a)
 {
 	/* MSVC thinks, in its infinite wisdom, that int min(int, int) is a better
 	 * match for min(uint64, uint) than uint64 min(uint64, uint64). As such we
@@ -241,7 +241,7 @@
  * @return The absolute difference between the given scalars
  */
 template <typename T>
-static inline T Delta(const T a, const T b)
+static INLINE T Delta(const T a, const T b)
 {
 	return (a < b) ? b - a : a - b;
 }
@@ -259,7 +259,7 @@
  * @return True if the value is in the interval, false else.
  */
 template <typename T>
-static inline bool IsInsideBS(const T x, const uint base, const uint size)
+static INLINE bool IsInsideBS(const T x, const uint base, const uint size)
 {
 	return (uint)(x - base) < size;
 }
@@ -275,7 +275,7 @@
  * @see IsInsideBS()
  */
 template <typename T>
-static inline bool IsInsideMM(const T x, const uint min, const uint max)
+static INLINE bool IsInsideMM(const T x, const uint min, const uint max)
 {
 	return (uint)(x - min) < (max - min);
 }
@@ -286,7 +286,7 @@
  * @param b variable to swap with a
  */
 template <typename T>
-static inline void Swap(T &a, T &b)
+static INLINE void Swap(T &a, T &b)
 {
 	T t = a;
 	a = b;
@@ -298,7 +298,7 @@
  * @param i value to convert, range 0..255
  * @return value in range 0..100
  */
-static inline uint ToPercent8(uint i)
+static INLINE uint ToPercent8(uint i)
 {
 	assert(i < 256);
 	return i * 101 >> 8;
@@ -309,7 +309,7 @@
  * @param i value to convert, range 0..65535
  * @return value in range 0..100
  */
-static inline uint ToPercent16(uint i)
+static INLINE uint ToPercent16(uint i)
 {
 	assert(i < 65536);
 	return i * 101 >> 16;
@@ -324,7 +324,7 @@
  * @param b Denominator
  * @return Quotient, rounded up
  */
-static inline uint CeilDiv(uint a, uint b)
+static INLINE uint CeilDiv(uint a, uint b)
 {
 	return (a + b - 1) / b;
 }
@@ -335,7 +335,7 @@
  * @param b Denominator
  * @return a rounded up to the nearest multiple of b.
  */
-static inline uint Ceil(uint a, uint b)
+static INLINE uint Ceil(uint a, uint b)
 {
 	return CeilDiv(a, b) * b;
 }
@@ -346,7 +346,7 @@
  * @param b Denominator
  * @return Quotient, rounded to nearest
  */
-static inline int RoundDivSU(int a, uint b)
+static INLINE int RoundDivSU(int a, uint b)
 {
 	if (a > 0) {
 		/* 0.5 is rounded to 1 */
diff --git a/src/core/mem_func.hpp b/src/core/mem_func.hpp
--- a/src/core/mem_func.hpp
+++ b/src/core/mem_func.hpp
@@ -22,7 +22,7 @@
  * @param num number of items to be copied. (!not number of bytes!)
  */
 template <typename T>
-static inline void MemCpyT(T *destination, const T *source, size_t num = 1)
+static INLINE void MemCpyT(T *destination, const T *source, size_t num = 1)
 {
 	memcpy(destination, source, num * sizeof(T));
 }
@@ -35,7 +35,7 @@
  * @param num number of items to be copied. (!not number of bytes!)
  */
 template <typename T>
-static inline void MemMoveT(T *destination, const T *source, size_t num = 1)
+static INLINE void MemMoveT(T *destination, const T *source, size_t num = 1)
 {
 	memmove(destination, source, num * sizeof(T));
 }
@@ -48,7 +48,7 @@
  * @param num number of items to be set (!not number of bytes!)
  */
 template <typename T>
-static inline void MemSetT(T *ptr, byte value, size_t num = 1)
+static INLINE void MemSetT(T *ptr, byte value, size_t num = 1)
 {
 	memset(ptr, value, num * sizeof(T));
 }
@@ -62,7 +62,7 @@
  * @return an int value indicating the relationship between the content of the two buffers
  */
 template <typename T>
-static inline int MemCmpT(const T *ptr1, const T *ptr2, size_t num = 1)
+static INLINE int MemCmpT(const T *ptr1, const T *ptr2, size_t num = 1)
 {
 	return memcmp(ptr1, ptr2, num * sizeof(T));
 }
@@ -76,7 +76,7 @@
  * @param ptr2 End-pointer to the block of memory.
  */
 template <typename T>
-static inline void MemReverseT(T *ptr1, T *ptr2)
+static INLINE void MemReverseT(T *ptr1, T *ptr2)
 {
 	assert(ptr1 != NULL && ptr2 != NULL);
 	assert(ptr1 < ptr2);
@@ -93,7 +93,7 @@
  * @param num The number of items we want to reverse.
  */
 template <typename T>
-static inline void MemReverseT(T *ptr, size_t num)
+static INLINE void MemReverseT(T *ptr, size_t num)
 {
 	assert(ptr != NULL);
 
diff --git a/src/core/overflowsafe_type.hpp b/src/core/overflowsafe_type.hpp
--- a/src/core/overflowsafe_type.hpp
+++ b/src/core/overflowsafe_type.hpp
@@ -33,9 +33,9 @@
 	OverflowSafeInt(const OverflowSafeInt& other) { this->m_value = other.m_value; }
 	OverflowSafeInt(const int64 int_)             { this->m_value = int_; }
 
-	inline OverflowSafeInt& operator = (const OverflowSafeInt& other) { this->m_value = other.m_value; return *this; }
+	INLINE OverflowSafeInt& operator = (const OverflowSafeInt& other) { this->m_value = other.m_value; return *this; }
 
-	inline OverflowSafeInt operator - () const { return OverflowSafeInt(-this->m_value); }
+	INLINE OverflowSafeInt operator - () const { return OverflowSafeInt(-this->m_value); }
 
 	/**
 	 * Safe implementation of addition.
@@ -43,7 +43,7 @@
 	 * @note when the addition would yield more than T_MAX (or less than T_MIN),
 	 *       it will be T_MAX (respectively T_MIN).
 	 */
-	inline OverflowSafeInt& operator += (const OverflowSafeInt& other)
+	INLINE OverflowSafeInt& operator += (const OverflowSafeInt& other)
 	{
 		if ((T_MAX - abs(other.m_value)) < abs(this->m_value) &&
 				(this->m_value < 0) == (other.m_value < 0)) {
@@ -55,18 +55,18 @@
 	}
 
 	/* Operators for addition and substraction */
-	inline OverflowSafeInt  operator +  (const OverflowSafeInt& other) const { OverflowSafeInt result = *this; result += other; return result; }
-	inline OverflowSafeInt  operator +  (const int              other) const { OverflowSafeInt result = *this; result += (int64)other; return result; }
-	inline OverflowSafeInt  operator +  (const uint             other) const { OverflowSafeInt result = *this; result += (int64)other; return result; }
-	inline OverflowSafeInt& operator -= (const OverflowSafeInt& other)       { return *this += (-other); }
-	inline OverflowSafeInt  operator -  (const OverflowSafeInt& other) const { OverflowSafeInt result = *this; result -= other; return result; }
-	inline OverflowSafeInt  operator -  (const int              other) const { OverflowSafeInt result = *this; result -= (int64)other; return result; }
-	inline OverflowSafeInt  operator -  (const uint             other) const { OverflowSafeInt result = *this; result -= (int64)other; return result; }
+	INLINE OverflowSafeInt  operator +  (const OverflowSafeInt& other) const { OverflowSafeInt result = *this; result += other; return result; }
+	INLINE OverflowSafeInt  operator +  (const int              other) const { OverflowSafeInt result = *this; result += (int64)other; return result; }
+	INLINE OverflowSafeInt  operator +  (const uint             other) const { OverflowSafeInt result = *this; result += (int64)other; return result; }
+	INLINE OverflowSafeInt& operator -= (const OverflowSafeInt& other)       { return *this += (-other); }
+	INLINE OverflowSafeInt  operator -  (const OverflowSafeInt& other) const { OverflowSafeInt result = *this; result -= other; return result; }
+	INLINE OverflowSafeInt  operator -  (const int              other) const { OverflowSafeInt result = *this; result -= (int64)other; return result; }
+	INLINE OverflowSafeInt  operator -  (const uint             other) const { OverflowSafeInt result = *this; result -= (int64)other; return result; }
 
-	inline OverflowSafeInt& operator ++ () { return *this += 1; }
-	inline OverflowSafeInt& operator -- () { return *this += -1; }
-	inline OverflowSafeInt operator ++ (int) { OverflowSafeInt org = *this; *this += 1; return org; }
-	inline OverflowSafeInt operator -- (int) { OverflowSafeInt org = *this; *this += -1; return org; }
+	INLINE OverflowSafeInt& operator ++ () { return *this += 1; }
+	INLINE OverflowSafeInt& operator -- () { return *this += -1; }
+	INLINE OverflowSafeInt operator ++ (int) { OverflowSafeInt org = *this; *this += 1; return org; }
+	INLINE OverflowSafeInt operator -- (int) { OverflowSafeInt org = *this; *this += -1; return org; }
 
 	/**
 	 * Safe implementation of multiplication.
@@ -74,7 +74,7 @@
 	 * @note when the multiplication would yield more than T_MAX (or less than T_MIN),
 	 *       it will be T_MAX (respectively T_MIN).
 	 */
-	inline OverflowSafeInt& operator *= (const int factor)
+	INLINE OverflowSafeInt& operator *= (const int factor)
 	{
 		if (factor != 0 && (T_MAX / abs(factor)) < abs(this->m_value)) {
 			 this->m_value = ((this->m_value < 0) == (factor < 0)) ? T_MAX : T_MIN ;
@@ -85,70 +85,70 @@
 	}
 
 	/* Operators for multiplication */
-	inline OverflowSafeInt operator * (const int64  factor) const { OverflowSafeInt result = *this; result *= factor; return result; }
-	inline OverflowSafeInt operator * (const int    factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
-	inline OverflowSafeInt operator * (const uint   factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
-	inline OverflowSafeInt operator * (const uint16 factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
-	inline OverflowSafeInt operator * (const byte   factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
+	INLINE OverflowSafeInt operator * (const int64  factor) const { OverflowSafeInt result = *this; result *= factor; return result; }
+	INLINE OverflowSafeInt operator * (const int    factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
+	INLINE OverflowSafeInt operator * (const uint   factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
+	INLINE OverflowSafeInt operator * (const uint16 factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
+	INLINE OverflowSafeInt operator * (const byte   factor) const { OverflowSafeInt result = *this; result *= (int64)factor; return result; }
 
 	/* Operators for division */
-	inline OverflowSafeInt& operator /= (const int64            divisor)       { this->m_value /= divisor; return *this; }
-	inline OverflowSafeInt  operator /  (const OverflowSafeInt& divisor) const { OverflowSafeInt result = *this; result /= divisor.m_value; return result; }
-	inline OverflowSafeInt  operator /  (const int              divisor) const { OverflowSafeInt result = *this; result /= divisor; return result; }
-	inline OverflowSafeInt  operator /  (const uint             divisor) const { OverflowSafeInt result = *this; result /= (int)divisor; return result; }
+	INLINE OverflowSafeInt& operator /= (const int64            divisor)       { this->m_value /= divisor; return *this; }
+	INLINE OverflowSafeInt  operator /  (const OverflowSafeInt& divisor) const { OverflowSafeInt result = *this; result /= divisor.m_value; return result; }
+	INLINE OverflowSafeInt  operator /  (const int              divisor) const { OverflowSafeInt result = *this; result /= divisor; return result; }
+	INLINE OverflowSafeInt  operator /  (const uint             divisor) const { OverflowSafeInt result = *this; result /= (int)divisor; return result; }
 
 	/* Operators for modulo */
-	inline OverflowSafeInt& operator %= (const int  divisor)       { this->m_value %= divisor; return *this; }
-	inline OverflowSafeInt  operator %  (const int  divisor) const { OverflowSafeInt result = *this; result %= divisor; return result; }
+	INLINE OverflowSafeInt& operator %= (const int  divisor)       { this->m_value %= divisor; return *this; }
+	INLINE OverflowSafeInt  operator %  (const int  divisor) const { OverflowSafeInt result = *this; result %= divisor; return result; }
 
 	/* Operators for shifting */
-	inline OverflowSafeInt& operator <<= (const int shift)       { this->m_value <<= shift; return *this; }
-	inline OverflowSafeInt  operator <<  (const int shift) const { OverflowSafeInt result = *this; result <<= shift; return result; }
-	inline OverflowSafeInt& operator >>= (const int shift)       { this->m_value >>= shift; return *this; }
-	inline OverflowSafeInt  operator >>  (const int shift) const { OverflowSafeInt result = *this; result >>= shift; return result; }
+	INLINE OverflowSafeInt& operator <<= (const int shift)       { this->m_value <<= shift; return *this; }
+	INLINE OverflowSafeInt  operator <<  (const int shift) const { OverflowSafeInt result = *this; result <<= shift; return result; }
+	INLINE OverflowSafeInt& operator >>= (const int shift)       { this->m_value >>= shift; return *this; }
+	INLINE OverflowSafeInt  operator >>  (const int shift) const { OverflowSafeInt result = *this; result >>= shift; return result; }
 
 	/* Operators for (in)equality when comparing overflow safe ints */
-	inline bool operator == (const OverflowSafeInt& other) const { return this->m_value == other.m_value; }
-	inline bool operator != (const OverflowSafeInt& other) const { return !(*this == other); }
-	inline bool operator >  (const OverflowSafeInt& other) const { return this->m_value > other.m_value; }
-	inline bool operator >= (const OverflowSafeInt& other) const { return this->m_value >= other.m_value; }
-	inline bool operator <  (const OverflowSafeInt& other) const { return !(*this >= other); }
-	inline bool operator <= (const OverflowSafeInt& other) const { return !(*this > other); }
+	INLINE bool operator == (const OverflowSafeInt& other) const { return this->m_value == other.m_value; }
+	INLINE bool operator != (const OverflowSafeInt& other) const { return !(*this == other); }
+	INLINE bool operator >  (const OverflowSafeInt& other) const { return this->m_value > other.m_value; }
+	INLINE bool operator >= (const OverflowSafeInt& other) const { return this->m_value >= other.m_value; }
+	INLINE bool operator <  (const OverflowSafeInt& other) const { return !(*this >= other); }
+	INLINE bool operator <= (const OverflowSafeInt& other) const { return !(*this > other); }
 
 	/* Operators for (in)equality when comparing non-overflow safe ints */
-	inline bool operator == (const int other) const { return this->m_value == other; }
-	inline bool operator != (const int other) const { return !(*this == other); }
-	inline bool operator >  (const int other) const { return this->m_value > other; }
-	inline bool operator >= (const int other) const { return this->m_value >= other; }
-	inline bool operator <  (const int other) const { return !(*this >= other); }
-	inline bool operator <= (const int other) const { return !(*this > other); }
+	INLINE bool operator == (const int other) const { return this->m_value == other; }
+	INLINE bool operator != (const int other) const { return !(*this == other); }
+	INLINE bool operator >  (const int other) const { return this->m_value > other; }
+	INLINE bool operator >= (const int other) const { return this->m_value >= other; }
+	INLINE bool operator <  (const int other) const { return !(*this >= other); }
+	INLINE bool operator <= (const int other) const { return !(*this > other); }
 
-	inline operator int64 () const { return this->m_value; }
+	INLINE operator int64 () const { return this->m_value; }
 };
 
 /* Sometimes we got int64 operator OverflowSafeInt instead of vice versa. Handle that properly */
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator + (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator - (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator * (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator / (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator + (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator - (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator * (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator / (int64 a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
 
 /* Sometimes we got int operator OverflowSafeInt instead of vice versa. Handle that properly */
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator + (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator - (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator * (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator / (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator + (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator - (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator * (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator / (int   a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
 
 /* Sometimes we got uint operator OverflowSafeInt instead of vice versa. Handle that properly */
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator + (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator - (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator * (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator / (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator + (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator - (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator * (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator / (uint  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
 
 /* Sometimes we got byte operator OverflowSafeInt instead of vice versa. Handle that properly */
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator + (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + (uint)a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator - (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + (uint)a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator * (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * (uint)a; }
-template <class T, int64 T_MAX, int64 T_MIN> inline OverflowSafeInt<T, T_MAX, T_MIN> operator / (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator + (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b + (uint)a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator - (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return -b + (uint)a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator * (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return b * (uint)a; }
+template <class T, int64 T_MAX, int64 T_MIN> INLINE OverflowSafeInt<T, T_MAX, T_MIN> operator / (byte  a, OverflowSafeInt<T, T_MAX, T_MIN> b) { return (OverflowSafeInt<T, T_MAX, T_MIN>)a / (int)b; }
 
 typedef OverflowSafeInt<int64, INT64_MAX, INT64_MIN> OverflowSafeInt64;
 
diff --git a/src/core/pool_func.hpp b/src/core/pool_func.hpp
--- a/src/core/pool_func.hpp
+++ b/src/core/pool_func.hpp
@@ -46,7 +46,7 @@
  * @pre index >= this->size
  * @pre index < Tmax_size
  */
-DEFINE_POOL_METHOD(inline void)::ResizeFor(size_t index)
+DEFINE_POOL_METHOD(INLINE void)::ResizeFor(size_t index)
 {
 	assert(index >= this->size);
 	assert(index < Tmax_size);
@@ -63,7 +63,7 @@
  * Searches for first free index
  * @return first free index, NO_FREE_ITEM on failure
  */
-DEFINE_POOL_METHOD(inline size_t)::FindFirstFree()
+DEFINE_POOL_METHOD(INLINE size_t)::FindFirstFree()
 {
 	size_t index = this->first_free;
 
@@ -95,7 +95,7 @@
  * @pre index < this->size
  * @pre this->Get(index) == NULL
  */
-DEFINE_POOL_METHOD(inline void *)::AllocateItem(size_t size, size_t index)
+DEFINE_POOL_METHOD(INLINE void *)::AllocateItem(size_t size, size_t index)
 {
 	assert(this->data[index] == NULL);
 
diff --git a/src/core/pool_type.hpp b/src/core/pool_type.hpp
--- a/src/core/pool_type.hpp
+++ b/src/core/pool_type.hpp
@@ -98,7 +98,7 @@
 	 * @return pointer to Titem
 	 * @pre index < this->first_unused
 	 */
-	inline Titem *Get(size_t index)
+	INLINE Titem *Get(size_t index)
 	{
 		assert(index < this->first_unused);
 		return this->data[index];
@@ -109,7 +109,7 @@
 	 * @param index index to examine
 	 * @return true if PoolItem::Get(index) will return non-NULL pointer
 	 */
-	inline bool IsValidID(size_t index)
+	INLINE bool IsValidID(size_t index)
 	{
 		return index < this->first_unused && this->Get(index) != NULL;
 	}
@@ -119,7 +119,7 @@
 	 * @param n number of items we want to allocate
 	 * @return true if 'n' items can be allocated
 	 */
-	inline bool CanAllocate(size_t n = 1)
+	INLINE bool CanAllocate(size_t n = 1)
 	{
 		bool ret = this->items <= Tmax_size - n;
 #ifdef OTTD_ASSERT
@@ -142,7 +142,7 @@
 		 * @return pointer to allocated memory
 		 * @note can never fail (return NULL), use CanAllocate() to check first!
 		 */
-		inline void *operator new(size_t size)
+		INLINE void *operator new(size_t size)
 		{
 			return Tpool->GetNew(size);
 		}
@@ -152,7 +152,7 @@
 		 * @param p memory to free
 		 * @note the item has to be allocated in the pool!
 		 */
-		inline void operator delete(void *p)
+		INLINE void operator delete(void *p)
 		{
 			Titem *pn = (Titem *)p;
 			assert(pn == Tpool->Get(pn->index));
@@ -167,7 +167,7 @@
 		 * @note can never fail (return NULL), use CanAllocate() to check first!
 		 * @pre index has to be unused! Else it will crash
 		 */
-		inline void *operator new(size_t size, size_t index)
+		INLINE void *operator new(size_t size, size_t index)
 		{
 			return Tpool->GetNew(size, index);
 		}
@@ -180,7 +180,7 @@
 		 * @note use of this is strongly discouraged
 		 * @pre the memory must not be allocated in the Pool!
 		 */
-		inline void *operator new(size_t size, void *ptr)
+		INLINE void *operator new(size_t size, void *ptr)
 		{
 			for (size_t i = 0; i < Tpool->first_unused; i++) {
 				/* Don't allow creating new objects over existing.
@@ -202,7 +202,7 @@
 		 * @param n number of items we want to allocate
 		 * @return true if 'n' items can be allocated
 		 */
-		static inline bool CanAllocateItem(size_t n = 1)
+		static INLINE bool CanAllocateItem(size_t n = 1)
 		{
 			return Tpool->CanAllocate(n);
 		}
@@ -211,7 +211,7 @@
 		 * Returns current state of pool cleaning - yes or no
 		 * @return true iff we are cleaning the pool now
 		 */
-		static inline bool CleaningPool()
+		static INLINE bool CleaningPool()
 		{
 			return Tpool->cleaning;
 		}
@@ -221,7 +221,7 @@
 		 * @param index index to examine
 		 * @return true if PoolItem::Get(index) will return non-NULL pointer
 		 */
-		static inline bool IsValidID(size_t index)
+		static INLINE bool IsValidID(size_t index)
 		{
 			return Tpool->IsValidID(index);
 		}
@@ -232,7 +232,7 @@
 		 * @return pointer to Titem
 		 * @pre index < this->first_unused
 		 */
-		static inline Titem *Get(size_t index)
+		static INLINE Titem *Get(size_t index)
 		{
 			return Tpool->Get(index);
 		}
@@ -243,7 +243,7 @@
 		 * @return pointer to Titem
 		 * @note returns NULL for invalid index
 		 */
-		static inline Titem *GetIfValid(size_t index)
+		static INLINE Titem *GetIfValid(size_t index)
 		{
 			return index < Tpool->first_unused ? Tpool->Get(index) : NULL;
 		}
@@ -253,7 +253,7 @@
 		 * all pool items.
 		 * @return first unused index
 		 */
-		static inline size_t GetPoolSize()
+		static INLINE size_t GetPoolSize()
 		{
 			return Tpool->first_unused;
 		}
@@ -262,7 +262,7 @@
 		 * Returns number of valid items in the pool
 		 * @return number of valid items in the pool
 		 */
-		static inline size_t GetNumItems()
+		static INLINE size_t GetNumItems()
 		{
 			return Tpool->items;
 		}
@@ -274,7 +274,7 @@
 		 * @note when this function is called, PoolItem::Get(index) == NULL.
 		 * @note it's called only when !CleaningPool()
 		 */
-		static inline void PostDestructor(size_t index) { }
+		static INLINE void PostDestructor(size_t index) { }
 	};
 
 private:
diff --git a/src/core/random_func.hpp b/src/core/random_func.hpp
--- a/src/core/random_func.hpp
+++ b/src/core/random_func.hpp
@@ -41,7 +41,7 @@
  * Saves the current seeds
  * @param storage Storage for saving
  */
-static inline void SaveRandomSeeds(SavedRandomSeeds *storage)
+static INLINE void SaveRandomSeeds(SavedRandomSeeds *storage)
 {
 	storage->random = _random;
 	storage->interactive_random = _interactive_random;
@@ -51,7 +51,7 @@
  * Restores previously saved seeds
  * @param storage Storage where SaveRandomSeeds() stored th seeds
  */
-static inline void RestoreRandomSeeds(const SavedRandomSeeds &storage)
+static INLINE void RestoreRandomSeeds(const SavedRandomSeeds &storage)
 {
 	_random = storage.random;
 	_interactive_random = storage.interactive_random;
@@ -68,23 +68,23 @@
 	#define RandomRange(max) DoRandomRange(max, __LINE__, __FILE__)
 	uint32 DoRandomRange(uint32 max, int line, const char *file);
 #else
-	static inline uint32 Random()
+	static INLINE uint32 Random()
 	{
 		return _random.Next();
 	}
 
-	static inline uint32 RandomRange(uint32 max)
+	static INLINE uint32 RandomRange(uint32 max)
 	{
 		return _random.Next(max);
 	}
 #endif
 
-static inline uint32 InteractiveRandom()
+static INLINE uint32 InteractiveRandom()
 {
 	return _interactive_random.Next();
 }
 
-static inline uint32 InteractiveRandomRange(uint32 max)
+static INLINE uint32 InteractiveRandomRange(uint32 max)
 {
 	return _interactive_random.Next(max);
 }
@@ -104,7 +104,7 @@
  * @param r The given randomize-number
  * @return True if the probability given by r is less or equal to (a/b)
  */
-static inline bool Chance16I(const uint a, const uint b, const uint32 r)
+static INLINE bool Chance16I(const uint a, const uint b, const uint32 r)
 {
 	assert(b != 0);
 	return (((uint16)r * b + b / 2) >> 16) < a;
@@ -123,7 +123,7 @@
 #ifdef RANDOM_DEBUG
 	#define Chance16(a, b) Chance16I(a, b, DoRandom(__LINE__, __FILE__))
 #else
-static inline bool Chance16(const uint a, const uint b)
+static INLINE bool Chance16(const uint a, const uint b)
 {
 	return Chance16I(a, b, Random());
 }
@@ -147,7 +147,7 @@
 #ifdef RANDOM_DEBUG
 	#define Chance16R(a, b, r) (r = DoRandom(__LINE__, __FILE__), Chance16I(a, b, r))
 #else
-static inline bool Chance16R(const uint a, const uint b, uint32 &r)
+static INLINE bool Chance16R(const uint a, const uint b, uint32 &r)
 {
 	r = Random();
 	return Chance16I(a, b, r);
diff --git a/src/core/smallmap_type.hpp b/src/core/smallmap_type.hpp
--- a/src/core/smallmap_type.hpp
+++ b/src/core/smallmap_type.hpp
@@ -26,7 +26,7 @@
 	U second;
 
 	/** Initializes this Pair with data */
-	inline SmallPair(const T &first, const U &second) : first(first), second(second) { }
+	INLINE SmallPair(const T &first, const U &second) : first(first), second(second) { }
 };
 
 /**
@@ -45,16 +45,16 @@
 	typedef const Pair *const_iterator;
 
 	/** Creates new SmallMap. Data are initialized in SmallVector constructor */
-	inline SmallMap() { }
+	INLINE SmallMap() { }
 	/** Data are freed in SmallVector destructor */
-	inline ~SmallMap() { }
+	INLINE ~SmallMap() { }
 
 	/**
 	 * Finds given key in this map
 	 * @param key key to find
 	 * @return &Pair(key, data) if found, this->End() if not
 	 */
-	inline const Pair *Find(const T &key) const
+	INLINE const Pair *Find(const T &key) const
 	{
 		for (uint i = 0; i < this->items; i++) {
 			if (key == this->data[i].first) return &this->data[i];
@@ -67,7 +67,7 @@
 	 * @param key key to find
 	 * @return &Pair(key, data) if found, this->End() if not
 	 */
-	inline Pair *Find(const T &key)
+	INLINE Pair *Find(const T &key)
 	{
 		for (uint i = 0; i < this->items; i++) {
 			if (key == this->data[i].first) return &this->data[i];
@@ -80,7 +80,7 @@
 	 * @param key key to test
 	 * @return true iff the item is present
 	 */
-	inline bool Contains(const T &key) const
+	INLINE bool Contains(const T &key) const
 	{
 		return this->Find(key) != this->End();
 	}
@@ -90,7 +90,7 @@
 	 * @param pair pair to remove
 	 * @note it has to be pointer to pair in this map. It is overwritten by the last item.
 	 */
-	inline void Erase(Pair *pair)
+	INLINE void Erase(Pair *pair)
 	{
 		assert(pair >= this->Begin() && pair < this->End());
 		*pair = this->data[--this->items];
@@ -102,7 +102,7 @@
 	 * @return true iff the key was found
 	 * @note last item is moved to its place, so don't increase your iterator if true is returned!
 	 */
-	inline bool Erase(const T &key)
+	INLINE bool Erase(const T &key)
 	{
 		for (uint i = 0; i < this->items; i++) {
 			if (key == this->data[i].first) {
@@ -119,7 +119,7 @@
 	 * @param data data
 	 * @return true iff the key wasn't already present
 	 */
-	inline bool Insert(const T &key, const U &data)
+	INLINE bool Insert(const T &key, const U &data)
 	{
 		if (this->Contains(key)) return false;
 		Pair *n = this->Append();
@@ -134,7 +134,7 @@
 	 * @return data belonging to this key
 	 * @note if this key wasn't present, new entry is created
 	 */
-	inline U &operator[](const T &key)
+	INLINE U &operator[](const T &key)
 	{
 		for (uint i = 0; i < this->items; i++) {
 			if (key == this->data[i].first) return this->data[i].second;
@@ -144,7 +144,7 @@
 		return n->second;
 	}
 
-	inline void SortByKey()
+	INLINE void SortByKey()
 	{
 		QSortT(this->Begin(), this->items, KeySorter);
 	}
diff --git a/src/core/smallvec_type.hpp b/src/core/smallvec_type.hpp
--- a/src/core/smallvec_type.hpp
+++ b/src/core/smallvec_type.hpp
@@ -84,7 +84,7 @@
 	 * Assign items from other vector.
 	 */
 	template <uint X>
-	inline void Assign(const SmallVector<T, X> &other)
+	INLINE void Assign(const SmallVector<T, X> &other)
 	{
 		if ((const void *)&other == (void *)this) return;
 
@@ -95,7 +95,7 @@
 	/**
 	 * Remove all items from the list.
 	 */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		/* In fact we just reset the item counter avoiding the need to
 		 * probably reallocate the same amount of memory the list was
@@ -106,7 +106,7 @@
 	/**
 	 * Remove all items from the list and free allocated memory.
 	 */
-	inline void Reset()
+	INLINE void Reset()
 	{
 		this->items = 0;
 		this->capacity = 0;
@@ -117,7 +117,7 @@
 	/**
 	 * Compact the list down to the smallest block size boundary.
 	 */
-	inline void Compact()
+	INLINE void Compact()
 	{
 		uint capacity = Align(this->items, S);
 		if (capacity >= this->capacity) return;
@@ -131,7 +131,7 @@
 	 * @param to_add the number of items to append
 	 * @return pointer to newly allocated item
 	 */
-	inline T *Append(uint to_add = 1)
+	INLINE T *Append(uint to_add = 1)
 	{
 		uint begin = this->items;
 		this->items += to_add;
@@ -150,7 +150,7 @@
 	 * @param item Item to search for
 	 * @return The position of the item, or End() when not present
 	 */
-	inline const T *Find(const T &item) const
+	INLINE const T *Find(const T &item) const
 	{
 		const T *pos = this->Begin();
 		const T *end = this->End();
@@ -164,7 +164,7 @@
 	 * @param item Item to search for
 	 * @return The position of the item, or End() when not present
 	 */
-	inline T *Find(const T &item)
+	INLINE T *Find(const T &item)
 	{
 		T *pos = this->Begin();
 		const T *end = this->End();
@@ -178,7 +178,7 @@
 	 * @param item Item to search for
 	 * @return The position of the item, or -1 when not present
 	 */
-	inline int FindIndex(const T &item) const
+	INLINE int FindIndex(const T &item) const
 	{
 		int index = 0;
 		const T *pos = this->Begin();
@@ -196,7 +196,7 @@
 	 * @param item Item to test for
 	 * @return true iff the item is present
 	 */
-	inline bool Contains(const T &item) const
+	INLINE bool Contains(const T &item) const
 	{
 		return this->Find(item) != this->End();
 	}
@@ -206,7 +206,7 @@
 	 * @param item item to remove
 	 * @note it has to be pointer to item in this map. It is overwritten by the last item.
 	 */
-	inline void Erase(T *item)
+	INLINE void Erase(T *item)
 	{
 		assert(item >= this->Begin() && item < this->End());
 		*item = this->data[--this->items];
@@ -218,7 +218,7 @@
 	 * @param item Item to test for
 	 * @return true iff the item is was already present
 	 */
-	inline bool Include(const T &item)
+	INLINE bool Include(const T &item)
 	{
 		bool is_member = this->Contains(item);
 		if (!is_member) *this->Append() = item;
@@ -228,7 +228,7 @@
 	/**
 	 * Get the number of items in the list.
 	 */
-	inline uint Length() const
+	INLINE uint Length() const
 	{
 		return this->items;
 	}
@@ -238,7 +238,7 @@
 	 *
 	 * @return the pointer to the first item
 	 */
-	inline const T *Begin() const
+	INLINE const T *Begin() const
 	{
 		return this->data;
 	}
@@ -248,7 +248,7 @@
 	 *
 	 * @return the pointer to the first item
 	 */
-	inline T *Begin()
+	INLINE T *Begin()
 	{
 		return this->data;
 	}
@@ -258,7 +258,7 @@
 	 *
 	 * @return the pointer behind the last valid item
 	 */
-	inline const T *End() const
+	INLINE const T *End() const
 	{
 		return &this->data[this->items];
 	}
@@ -268,7 +268,7 @@
 	 *
 	 * @return the pointer behind the last valid item
 	 */
-	inline T *End()
+	INLINE T *End()
 	{
 		return &this->data[this->items];
 	}
@@ -279,7 +279,7 @@
 	 * @param index the position of the item
 	 * @return the pointer to the item
 	 */
-	inline const T *Get(uint index) const
+	INLINE const T *Get(uint index) const
 	{
 		/* Allow access to the 'first invalid' item */
 		assert(index <= this->items);
@@ -292,7 +292,7 @@
 	 * @param index the position of the item
 	 * @return the pointer to the item
 	 */
-	inline T *Get(uint index)
+	INLINE T *Get(uint index)
 	{
 		/* Allow access to the 'first invalid' item */
 		assert(index <= this->items);
@@ -305,7 +305,7 @@
 	 * @param index the position of the item
 	 * @return the item
 	 */
-	inline const T &operator[](uint index) const
+	INLINE const T &operator[](uint index) const
 	{
 		assert(index < this->items);
 		return this->data[index];
@@ -317,7 +317,7 @@
 	 * @param index the position of the item
 	 * @return the item
 	 */
-	inline T &operator[](uint index)
+	INLINE T &operator[](uint index)
 	{
 		assert(index < this->items);
 		return this->data[index];
@@ -346,7 +346,7 @@
 	/**
 	 * Remove all items from the list.
 	 */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		for (uint i = 0; i < this->items; i++) {
 			free(this->data[i]);
@@ -377,7 +377,7 @@
 	/**
 	 * Remove all items from the list.
 	 */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		for (uint i = 0; i < this->items; i++) {
 			delete this->data[i];
diff --git a/src/core/sort_func.hpp b/src/core/sort_func.hpp
--- a/src/core/sort_func.hpp
+++ b/src/core/sort_func.hpp
@@ -25,7 +25,7 @@
  * @param desc Sort descending.
  */
 template <typename T>
-static inline void QSortT(T *base, uint num, int (CDECL *comparator)(const T*, const T*), bool desc = false)
+static INLINE void QSortT(T *base, uint num, int (CDECL *comparator)(const T*, const T*), bool desc = false)
 {
 	if (num < 2) return;
 
@@ -49,7 +49,7 @@
  * @param desc Sort descending.
  */
 template <typename T>
-static inline void GSortT(T *base, uint num, int (CDECL *comparator)(const T*, const T*), bool desc = false)
+static INLINE void GSortT(T *base, uint num, int (CDECL *comparator)(const T*, const T*), bool desc = false)
 {
 	if (num < 2) return;
 
diff --git a/src/date_func.h b/src/date_func.h
--- a/src/date_func.h
+++ b/src/date_func.h
@@ -29,7 +29,7 @@
  * @param yr The year to check.
  * @return True if \c yr is a leap year, otherwise false.
  */
-static inline bool IsLeapYear(Year yr)
+static INLINE bool IsLeapYear(Year yr)
 {
 	return yr % 4 == 0 && (yr % 100 != 0 || yr % 400 == 0);
 }
diff --git a/src/depot_base.h b/src/depot_base.h
--- a/src/depot_base.h
+++ b/src/depot_base.h
@@ -29,7 +29,7 @@
 	Depot(TileIndex xy = INVALID_TILE) : xy(xy) {}
 	~Depot();
 
-	static inline Depot *GetByTile(TileIndex tile)
+	static INLINE Depot *GetByTile(TileIndex tile)
 	{
 		return Depot::Get(GetDepotIndex(tile));
 	}
@@ -40,7 +40,7 @@
 	 * @param d The depot to compare to.
 	 * @return true iff their types are equal.
 	 */
-	inline bool IsOfType(const Depot *d) const
+	INLINE bool IsOfType(const Depot *d) const
 	{
 		return GetTileType(d->xy) == GetTileType(this->xy);
 	}
diff --git a/src/depot_func.h b/src/depot_func.h
--- a/src/depot_func.h
+++ b/src/depot_func.h
@@ -25,7 +25,7 @@
  * @param tileh The slope of the tile in question
  * @return true if the construction is possible
  */
-static inline bool CanBuildDepotByTileh(DiagDirection direction, Slope tileh)
+static INLINE bool CanBuildDepotByTileh(DiagDirection direction, Slope tileh)
 {
 	assert(tileh != SLOPE_FLAT);
 	Slope entrance_corners = InclinedSlope(direction);
diff --git a/src/depot_map.h b/src/depot_map.h
--- a/src/depot_map.h
+++ b/src/depot_map.h
@@ -17,7 +17,7 @@
 /**
  * Check if a tile is a depot and it is a depot of the given type.
  */
-static inline bool IsDepotTypeTile(TileIndex tile, TransportType type)
+static INLINE bool IsDepotTypeTile(TileIndex tile, TransportType type)
 {
 	switch (type) {
 		default: NOT_REACHED();
@@ -37,7 +37,7 @@
  * @param tile the tile to check
  * @return true if and only if there is a depot on the tile.
  */
-static inline bool IsDepotTile(TileIndex tile)
+static INLINE bool IsDepotTile(TileIndex tile)
 {
 	return IsRailDepotTile(tile) || IsRoadDepotTile(tile) || IsShipDepotTile(tile) || IsHangarTile(tile);
 }
@@ -48,7 +48,7 @@
  * @pre IsRailDepotTile(t) || IsRoadDepotTile(t) || IsShipDepotTile(t)
  * @return DepotID
  */
-static inline DepotID GetDepotIndex(TileIndex t)
+static INLINE DepotID GetDepotIndex(TileIndex t)
 {
 	/* Hangars don't have a Depot class, thus store no DepotID. */
 	assert(IsRailDepotTile(t) || IsRoadDepotTile(t) || IsShipDepotTile(t));
diff --git a/src/direction_func.h b/src/direction_func.h
--- a/src/direction_func.h
+++ b/src/direction_func.h
@@ -20,7 +20,7 @@
  * @param d The direction to get the reverse from
  * @return The reverse Direction
  */
-static inline Direction ReverseDir(Direction d)
+static INLINE Direction ReverseDir(Direction d)
 {
 	return (Direction)(4 ^ d);
 }
@@ -33,7 +33,7 @@
  * @param d1 The second direction as the offset from the base
  * @return The difference how the second directions drifts of the first one.
  */
-static inline DirDiff DirDifference(Direction d0, Direction d1)
+static INLINE DirDiff DirDifference(Direction d0, Direction d1)
 {
 	/* Cast to uint so compiler can use bitmask. If the difference is negative
 	 * and we used int instead of uint, further "+ 8" would have to be added. */
@@ -51,7 +51,7 @@
  * @param delta The second difference to add on
  * @return The resulting difference
  */
-static inline DirDiff ChangeDirDiff(DirDiff d, DirDiff delta)
+static INLINE DirDiff ChangeDirDiff(DirDiff d, DirDiff delta)
 {
 	/* Cast to uint so compiler can use bitmask. Result can never be negative. */
 	return (DirDiff)((uint)(d + delta) % 8);
@@ -67,7 +67,7 @@
  * @param delta The offset/drift applied to the direction
  * @return The new direction
  */
-static inline Direction ChangeDir(Direction d, DirDiff delta)
+static INLINE Direction ChangeDir(Direction d, DirDiff delta)
 {
 	/* Cast to uint so compiler can use bitmask. Result can never be negative. */
 	return (Direction)((uint)(d + delta) % 8);
@@ -80,7 +80,7 @@
  * @param d The DiagDirection to get the reverse from
  * @return The reverse direction
  */
-static inline DiagDirection ReverseDiagDir(DiagDirection d)
+static INLINE DiagDirection ReverseDiagDir(DiagDirection d)
 {
 	return (DiagDirection)(2 ^ d);
 }
@@ -96,7 +96,7 @@
  * @param delta The difference to applie on
  * @return The new direction which was calculated
  */
-static inline DiagDirection ChangeDiagDir(DiagDirection d, DiagDirDiff delta)
+static INLINE DiagDirection ChangeDiagDir(DiagDirection d, DiagDirDiff delta)
 {
 	/* Cast to uint so compiler can use bitmask. Result can never be negative. */
 	return (DiagDirection)((uint)(d + delta) % 4);
@@ -112,7 +112,7 @@
  * @param dir The direction to convert
  * @return The resulting DiagDirection, maybe "rounded clockwise".
  */
-static inline DiagDirection DirToDiagDir(Direction dir)
+static INLINE DiagDirection DirToDiagDir(Direction dir)
 {
 	return (DiagDirection)(dir >> 1);
 }
@@ -127,7 +127,7 @@
  * @param dir The direction to convert
  * @return The resulting Direction
  */
-static inline Direction DiagDirToDir(DiagDirection dir)
+static INLINE Direction DiagDirToDir(DiagDirection dir)
 {
 	return (Direction)(dir * 2 + 1);
 }
@@ -141,7 +141,7 @@
  * @param a The given axis
  * @return The other axis
  */
-static inline Axis OtherAxis(Axis a)
+static INLINE Axis OtherAxis(Axis a)
 {
 	return (Axis)(a ^ 1);
 }
@@ -157,7 +157,7 @@
  * @param d The DiagDirection
  * @return The axis which belongs to the direction
  */
-static inline Axis DiagDirToAxis(DiagDirection d)
+static INLINE Axis DiagDirToAxis(DiagDirection d)
 {
 	return (Axis)(d & 1);
 }
@@ -174,7 +174,7 @@
  * @param a The axis
  * @return The direction pointed to south
  */
-static inline DiagDirection AxisToDiagDir(Axis a)
+static INLINE DiagDirection AxisToDiagDir(Axis a)
 {
 	return (DiagDirection)(2 - a);
 }
@@ -190,7 +190,7 @@
  * @param a The axis
  * @return The direction pointed to south
  */
-static inline Direction AxisToDirection(Axis a)
+static INLINE Direction AxisToDirection(Axis a)
 {
 	return (Direction)(5 - 2 * a);
 }
@@ -201,7 +201,7 @@
  * @param ns north -> 0, south -> 1
  * @return the desired DiagDirection
  */
-static inline DiagDirection XYNSToDiagDir(Axis xy, uint ns)
+static INLINE DiagDirection XYNSToDiagDir(Axis xy, uint ns)
 {
 	return (DiagDirection)(xy * 3 ^ ns * 2);
 }
@@ -212,7 +212,7 @@
  * @param d The value to check
  * @return True if the value belongs to a DiagDirection, else false
  */
-static inline bool IsValidDiagDirection(DiagDirection d)
+static INLINE bool IsValidDiagDirection(DiagDirection d)
 {
 	return d < DIAGDIR_END;
 }
@@ -223,7 +223,7 @@
  * @param d The value to check
  * @return True if the value belongs to a Direction, else false
  */
-static inline bool IsValidDirection(Direction d)
+static INLINE bool IsValidDirection(Direction d)
 {
 	return d < DIR_END;
 }
@@ -234,7 +234,7 @@
  * @param d The value to check
  * @return True if the value belongs to an Axis, else false
  */
-static inline bool IsValidAxis(Axis d)
+static INLINE bool IsValidAxis(Axis d)
 {
 	return d < AXIS_END;
 }
@@ -245,7 +245,7 @@
  * @param dir The given direction.
  * @return True if the direction is diagonal.
  */
-static inline bool IsDiagonalDirection(Direction dir)
+static INLINE bool IsDiagonalDirection(Direction dir)
 {
 	return (dir & 1) != 0;
 }
diff --git a/src/economy.cpp b/src/economy.cpp
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -65,7 +65,7 @@
  * @param shift The amount to shift the value to right.
  * @return The shifted result
  */
-static inline int32 BigMulS(const int32 a, const int32 b, const uint8 shift)
+static INLINE int32 BigMulS(const int32 a, const int32 b, const uint8 shift)
 {
 	return (int32)((int64)a * (int64)b >> shift);
 }
diff --git a/src/economy_func.h b/src/economy_func.h
--- a/src/economy_func.h
+++ b/src/economy_func.h
@@ -46,7 +46,7 @@
  * Is the economy in recession?
  * @return \c True if economy is in recession, \c false otherwise.
  */
-static inline bool EconomyIsInRecession()
+static INLINE bool EconomyIsInRecession()
 {
 	return _economy.fluct <= 0;
 }
diff --git a/src/elrail.cpp b/src/elrail.cpp
--- a/src/elrail.cpp
+++ b/src/elrail.cpp
@@ -72,7 +72,7 @@
  * @param t The tile to get the tile location group of.
  * @return The tile location group.
  */
-static inline TLG GetTLG(TileIndex t)
+static INLINE TLG GetTLG(TileIndex t)
 {
 	return (TLG)((HasBit(TileX(t), 0) << 1) + HasBit(TileY(t), 0));
 }
@@ -166,7 +166,7 @@
 /**
  * Get the base wire sprite to use.
  */
-static inline SpriteID GetWireBase(TileIndex tile, TileContext context = TCX_NORMAL)
+static INLINE SpriteID GetWireBase(TileIndex tile, TileContext context = TCX_NORMAL)
 {
 	const RailtypeInfo *rti = GetRailTypeInfo(GetRailType(tile));
 	SpriteID wires = GetCustomRailSprite(rti, tile, RTSG_WIRES, context);
@@ -176,7 +176,7 @@
 /**
  * Get the base pylon sprite to use.
  */
-static inline SpriteID GetPylonBase(TileIndex tile, TileContext context = TCX_NORMAL)
+static INLINE SpriteID GetPylonBase(TileIndex tile, TileContext context = TCX_NORMAL)
 {
 	const RailtypeInfo *rti = GetRailTypeInfo(GetRailType(tile));
 	SpriteID pylons = GetCustomRailSprite(rti, tile, RTSG_PYLONS, context);
diff --git a/src/elrail_func.h b/src/elrail_func.h
--- a/src/elrail_func.h
+++ b/src/elrail_func.h
@@ -20,7 +20,7 @@
  * Test if a rail type has catenary
  * @param rt Rail type to test
  */
-static inline bool HasCatenary(RailType rt)
+static INLINE bool HasCatenary(RailType rt)
 {
 	return HasBit(GetRailTypeInfo(rt)->flags, RTF_CATENARY);
 }
@@ -29,7 +29,7 @@
  * Test if we should draw rail catenary
  * @param rt Rail type to test
  */
-static inline bool HasCatenaryDrawn(RailType rt)
+static INLINE bool HasCatenaryDrawn(RailType rt)
 {
 	return HasCatenary(rt) && !IsInvisibilitySet(TO_CATENARY) && !_settings_game.vehicle.disable_elrails;
 }
diff --git a/src/engine_base.h b/src/engine_base.h
--- a/src/engine_base.h
+++ b/src/engine_base.h
@@ -114,7 +114,7 @@
 	 * Check if the engine is a ground vehicle.
 	 * @return True iff the engine is a train or a road vehicle.
 	 */
-	inline bool IsGroundVehicle() const
+	INLINE bool IsGroundVehicle() const
 	{
 		return this->type == VEH_TRAIN || this->type == VEH_ROAD;
 	}
@@ -159,27 +159,27 @@
 
 #define FOR_ALL_ENGINES_OF_TYPE(e, engine_type) FOR_ALL_ENGINES(e) if (e->type == engine_type)
 
-static inline const EngineInfo *EngInfo(EngineID e)
+static INLINE const EngineInfo *EngInfo(EngineID e)
 {
 	return &Engine::Get(e)->info;
 }
 
-static inline const RailVehicleInfo *RailVehInfo(EngineID e)
+static INLINE const RailVehicleInfo *RailVehInfo(EngineID e)
 {
 	return &Engine::Get(e)->u.rail;
 }
 
-static inline const RoadVehicleInfo *RoadVehInfo(EngineID e)
+static INLINE const RoadVehicleInfo *RoadVehInfo(EngineID e)
 {
 	return &Engine::Get(e)->u.road;
 }
 
-static inline const ShipVehicleInfo *ShipVehInfo(EngineID e)
+static INLINE const ShipVehicleInfo *ShipVehInfo(EngineID e)
 {
 	return &Engine::Get(e)->u.ship;
 }
 
-static inline const AircraftVehicleInfo *AircraftVehInfo(EngineID e)
+static INLINE const AircraftVehicleInfo *AircraftVehInfo(EngineID e)
 {
 	return &Engine::Get(e)->u.air;
 }
diff --git a/src/fileio.cpp b/src/fileio.cpp
--- a/src/fileio.cpp
+++ b/src/fileio.cpp
@@ -186,7 +186,7 @@
  * Close the file at the given slot number.
  * @param slot File index to close.
  */
-static inline void FioCloseFile(int slot)
+static INLINE void FioCloseFile(int slot)
 {
 	if (_fio.handles[slot] != NULL) {
 		fclose(_fio.handles[slot]);
diff --git a/src/fileio_func.h b/src/fileio_func.h
--- a/src/fileio_func.h
+++ b/src/fileio_func.h
@@ -40,7 +40,7 @@
  * @param sp the search path to check
  * @return true if the search path is valid
  */
-static inline bool IsValidSearchPath(Searchpath sp)
+static INLINE bool IsValidSearchPath(Searchpath sp)
 {
 	return sp < NUM_SEARCHPATHS && _searchpaths[sp] != NULL;
 }
@@ -142,7 +142,7 @@
  * @param path string to open directory of
  * @return DIR pointer
  */
-static inline DIR *ttd_opendir(const char *path)
+static INLINE DIR *ttd_opendir(const char *path)
 {
 	return opendir(OTTD2FS(path));
 }
diff --git a/src/fontcache.h b/src/fontcache.h
--- a/src/fontcache.h
+++ b/src/fontcache.h
@@ -64,12 +64,12 @@
 #else
 
 /* Stub for initializiation */
-static inline void InitFreeType(bool monospace) { extern void ResetFontSizes(bool monospace); ResetFontSizes(monospace); }
-static inline void UninitFreeType() {}
-static inline void ClearFontCache() {}
+static INLINE void InitFreeType(bool monospace) { extern void ResetFontSizes(bool monospace); ResetFontSizes(monospace); }
+static INLINE void UninitFreeType() {}
+static INLINE void ClearFontCache() {}
 
 /** Get the Sprite for a glyph */
-static inline const Sprite *GetGlyph(FontSize size, uint32 key)
+static INLINE const Sprite *GetGlyph(FontSize size, uint32 key)
 {
 	SpriteID sprite = GetUnicodeGlyph(size, key);
 	if (sprite == 0) sprite = GetUnicodeGlyph(size, '?');
@@ -78,14 +78,14 @@
 
 
 /** Get the width of a glyph */
-static inline uint GetGlyphWidth(FontSize size, uint32 key)
+static INLINE uint GetGlyphWidth(FontSize size, uint32 key)
 {
 	SpriteID sprite = GetUnicodeGlyph(size, key);
 	if (sprite == 0) sprite = GetUnicodeGlyph(size, '?');
 	return SpriteExists(sprite) ? GetSprite(sprite, ST_FONT)->width + (size != FS_NORMAL) : 0;
 }
 
-static inline bool GetDrawGlyphShadow()
+static INLINE bool GetDrawGlyphShadow()
 {
 	return false;
 }
diff --git a/src/gamelog.cpp b/src/gamelog.cpp
--- a/src/gamelog.cpp
+++ b/src/gamelog.cpp
@@ -579,7 +579,7 @@
  * @param g grf to determine
  * @return true iff GRF is not static and is loaded
  */
-static inline bool IsLoggableGrfConfig(const GRFConfig *g)
+static INLINE bool IsLoggableGrfConfig(const GRFConfig *g)
 {
 	return !HasBit(g->flags, GCF_STATIC) && g->status != GCS_NOT_FOUND;
 }
diff --git a/src/gfx.cpp b/src/gfx.cpp
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -69,7 +69,7 @@
 	 * Switch to new colour \a c.
 	 * @param c New colour to use.
 	 */
-	inline void SetColour(TextColour c)
+	INLINE void SetColour(TextColour c)
 	{
 		assert(c >=  TC_BLUE && c <= TC_BLACK);
 		this->prev_colour = this->cur_colour;
@@ -77,7 +77,7 @@
 	}
 
 	/** Switch to previous colour. */
-	inline void SetPreviousColour()
+	INLINE void SetPreviousColour()
 	{
 		Swap(this->cur_colour, this->prev_colour);
 	}
@@ -86,7 +86,7 @@
 	 * Switch to using a new font \a f.
 	 * @param f New font to use.
 	 */
-	inline void SetFontSize(FontSize f)
+	INLINE void SetFontSize(FontSize f)
 	{
 		this->fontsize = f;
 	}
diff --git a/src/gfx_func.h b/src/gfx_func.h
--- a/src/gfx_func.h
+++ b/src/gfx_func.h
@@ -156,7 +156,7 @@
  * @param size Font size to get height of
  * @return     Height of characters in the given font (pixels)
  */
-static inline byte GetCharacterHeight(FontSize size)
+static INLINE byte GetCharacterHeight(FontSize size)
 {
 	assert(size < FS_END);
 	extern int _font_height[FS_END];
diff --git a/src/goal_base.h b/src/goal_base.h
--- a/src/goal_base.h
+++ b/src/goal_base.h
@@ -29,12 +29,12 @@
 	/**
 	 * We need an (empty) constructor so struct isn't zeroed (as C++ standard states)
 	 */
-	inline Goal() { }
+	INLINE Goal() { }
 
 	/**
 	 * (Empty) destructor has to be defined else operator delete might be called with NULL parameter
 	 */
-	inline ~Goal() { free(this->text); }
+	INLINE ~Goal() { free(this->text); }
 };
 
 #define FOR_ALL_GOALS_FROM(var, start) FOR_ALL_ITEMS_FROM(Goal, goal_index, var, start)
diff --git a/src/graph_gui.cpp b/src/graph_gui.cpp
--- a/src/graph_gui.cpp
+++ b/src/graph_gui.cpp
@@ -1109,7 +1109,7 @@
 	STR_COMPANY_LEAGUE_PERFORMANCE_TITLE_TYCOON,
 };
 
-static inline StringID GetPerformanceTitleFromValue(uint value)
+static INLINE StringID GetPerformanceTitleFromValue(uint value)
 {
 	return _performance_titles[minu(value, 1000) >> 6];
 }
diff --git a/src/ground_vehicle.hpp b/src/ground_vehicle.hpp
--- a/src/ground_vehicle.hpp
+++ b/src/ground_vehicle.hpp
@@ -113,7 +113,7 @@
 	 * Calculates the total slope resistance for this vehicle.
 	 * @return Slope resistance.
 	 */
-	inline int32 GetSlopeResistance() const
+	INLINE int32 GetSlopeResistance() const
 	{
 		int32 incl = 0;
 
@@ -134,7 +134,7 @@
 	 * @pre The vehicle has to be at (or near to) a border of the tile,
 	 *      directed towards tile centre
 	 */
-	inline void UpdateZPositionAndInclination()
+	INLINE void UpdateZPositionAndInclination()
 	{
 		this->z_pos = GetSlopePixelZ(this->x_pos, this->y_pos);
 		ClrBit(this->gv_flags, GVF_GOINGUP_BIT);
@@ -159,7 +159,7 @@
 	 * The faster code is used for trains and road vehicles unless they are
 	 * reversing on a sloped tile.
 	 */
-	inline void UpdateZPosition()
+	INLINE void UpdateZPosition()
 	{
 #if 0
 		/* The following code does this: */
@@ -231,7 +231,7 @@
 	 * @param update_delta Indicates to also update the delta.
 	 * @return Old height of the vehicle.
 	 */
-	inline byte UpdateInclination(bool new_tile, bool update_delta)
+	INLINE byte UpdateInclination(bool new_tile, bool update_delta)
 	{
 		byte old_z = this->z_pos;
 
@@ -248,99 +248,99 @@
 	/**
 	 * Set front engine state.
 	 */
-	inline void SetFrontEngine() { SetBit(this->subtype, GVSF_FRONT); }
+	INLINE void SetFrontEngine() { SetBit(this->subtype, GVSF_FRONT); }
 
 	/**
 	 * Remove the front engine state.
 	 */
-	inline void ClearFrontEngine() { ClrBit(this->subtype, GVSF_FRONT); }
+	INLINE void ClearFrontEngine() { ClrBit(this->subtype, GVSF_FRONT); }
 
 	/**
 	 * Set a vehicle to be an articulated part.
 	 */
-	inline void SetArticulatedPart() { SetBit(this->subtype, GVSF_ARTICULATED_PART); }
+	INLINE void SetArticulatedPart() { SetBit(this->subtype, GVSF_ARTICULATED_PART); }
 
 	/**
 	 * Clear a vehicle from being an articulated part.
 	 */
-	inline void ClearArticulatedPart() { ClrBit(this->subtype, GVSF_ARTICULATED_PART); }
+	INLINE void ClearArticulatedPart() { ClrBit(this->subtype, GVSF_ARTICULATED_PART); }
 
 	/**
 	 * Set a vehicle to be a wagon.
 	 */
-	inline void SetWagon() { SetBit(this->subtype, GVSF_WAGON); }
+	INLINE void SetWagon() { SetBit(this->subtype, GVSF_WAGON); }
 
 	/**
 	 * Clear wagon property.
 	 */
-	inline void ClearWagon() { ClrBit(this->subtype, GVSF_WAGON); }
+	INLINE void ClearWagon() { ClrBit(this->subtype, GVSF_WAGON); }
 
 	/**
 	 * Set engine status.
 	 */
-	inline void SetEngine() { SetBit(this->subtype, GVSF_ENGINE); }
+	INLINE void SetEngine() { SetBit(this->subtype, GVSF_ENGINE); }
 
 	/**
 	 * Clear engine status.
 	 */
-	inline void ClearEngine() { ClrBit(this->subtype, GVSF_ENGINE); }
+	INLINE void ClearEngine() { ClrBit(this->subtype, GVSF_ENGINE); }
 
 	/**
 	 * Set a vehicle as a free wagon.
 	 */
-	inline void SetFreeWagon() { SetBit(this->subtype, GVSF_FREE_WAGON); }
+	INLINE void SetFreeWagon() { SetBit(this->subtype, GVSF_FREE_WAGON); }
 
 	/**
 	 * Clear a vehicle from being a free wagon.
 	 */
-	inline void ClearFreeWagon() { ClrBit(this->subtype, GVSF_FREE_WAGON); }
+	INLINE void ClearFreeWagon() { ClrBit(this->subtype, GVSF_FREE_WAGON); }
 
 	/**
 	 * Set a vehicle as a multiheaded engine.
 	 */
-	inline void SetMultiheaded() { SetBit(this->subtype, GVSF_MULTIHEADED); }
+	INLINE void SetMultiheaded() { SetBit(this->subtype, GVSF_MULTIHEADED); }
 
 	/**
 	 * Clear multiheaded engine property.
 	 */
-	inline void ClearMultiheaded() { ClrBit(this->subtype, GVSF_MULTIHEADED); }
+	INLINE void ClearMultiheaded() { ClrBit(this->subtype, GVSF_MULTIHEADED); }
 
 	/**
 	 * Check if the vehicle is a free wagon (got no engine in front of it).
 	 * @return Returns true if the vehicle is a free wagon.
 	 */
-	inline bool IsFreeWagon() const { return HasBit(this->subtype, GVSF_FREE_WAGON); }
+	INLINE bool IsFreeWagon() const { return HasBit(this->subtype, GVSF_FREE_WAGON); }
 
 	/**
 	 * Check if a vehicle is an engine (can be first in a consist).
 	 * @return Returns true if vehicle is an engine.
 	 */
-	inline bool IsEngine() const { return HasBit(this->subtype, GVSF_ENGINE); }
+	INLINE bool IsEngine() const { return HasBit(this->subtype, GVSF_ENGINE); }
 
 	/**
 	 * Check if a vehicle is a wagon.
 	 * @return Returns true if vehicle is a wagon.
 	 */
-	inline bool IsWagon() const { return HasBit(this->subtype, GVSF_WAGON); }
+	INLINE bool IsWagon() const { return HasBit(this->subtype, GVSF_WAGON); }
 
 	/**
 	 * Check if the vehicle is a multiheaded engine.
 	 * @return Returns true if the vehicle is a multiheaded engine.
 	 */
-	inline bool IsMultiheaded() const { return HasBit(this->subtype, GVSF_MULTIHEADED); }
+	INLINE bool IsMultiheaded() const { return HasBit(this->subtype, GVSF_MULTIHEADED); }
 
 	/**
 	 * Tell if we are dealing with the rear end of a multiheaded engine.
 	 * @return True if the engine is the rear part of a dualheaded engine.
 	 */
-	inline bool IsRearDualheaded() const { return this->IsMultiheaded() && !this->IsEngine(); }
+	INLINE bool IsRearDualheaded() const { return this->IsMultiheaded() && !this->IsEngine(); }
 
 	/**
 	 * Update the GUI variant of the current speed of the vehicle.
 	 * Also mark the widget dirty when that is needed, i.e. when
 	 * the speed of this vehicle has changed.
 	 */
-	inline void SetLastSpeed()
+	INLINE void SetLastSpeed()
 	{
 		if (this->cur_speed != this->gcache.last_speed) {
 			SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
@@ -362,7 +362,7 @@
 	 * @param max_speed The maximum speed here, in vehicle specific units.
 	 * @return Distance to drive.
 	 */
-	inline uint DoUpdateSpeed(uint accel, int min_speed, int max_speed)
+	INLINE uint DoUpdateSpeed(uint accel, int min_speed, int max_speed)
 	{
 		uint spd = this->subspeed + accel;
 		this->subspeed = (byte)spd;
diff --git a/src/group.h b/src/group.h
--- a/src/group.h
+++ b/src/group.h
@@ -76,7 +76,7 @@
 };
 
 
-static inline bool IsDefaultGroupID(GroupID index)
+static INLINE bool IsDefaultGroupID(GroupID index)
 {
 	return index == DEFAULT_GROUP;
 }
@@ -86,7 +86,7 @@
  * @param id_g The GroupID to check
  * @return true is id_g is identical to ALL_GROUP
  */
-static inline bool IsAllGroupID(GroupID id_g)
+static INLINE bool IsAllGroupID(GroupID id_g)
 {
 	return id_g == ALL_GROUP;
 }
diff --git a/src/group_cmd.cpp b/src/group_cmd.cpp
--- a/src/group_cmd.cpp
+++ b/src/group_cmd.cpp
@@ -241,7 +241,7 @@
  * @param old_g index of the old group
  * @param new_g index of the new group
  */
-static inline void UpdateNumEngineGroup(const Vehicle *v, GroupID old_g, GroupID new_g)
+static INLINE void UpdateNumEngineGroup(const Vehicle *v, GroupID old_g, GroupID new_g)
 {
 	if (old_g != new_g) {
 		/* Decrease the num engines in the old group */
diff --git a/src/group_gui.cpp b/src/group_gui.cpp
--- a/src/group_gui.cpp
+++ b/src/group_gui.cpp
@@ -836,7 +836,7 @@
  * @param owner owner of groups
  * @return pointer to VehicleGroupWindow, NULL if not found
  */
-static inline VehicleGroupWindow *FindVehicleGroupWindow(VehicleType vt, Owner owner)
+static INLINE VehicleGroupWindow *FindVehicleGroupWindow(VehicleType vt, Owner owner)
 {
 	return (VehicleGroupWindow *)FindWindowById(GetWindowClassForVehicleType(vt), VehicleListIdentifier(VL_GROUP_LIST, vt, owner).Pack());
 }
diff --git a/src/heightmap.cpp b/src/heightmap.cpp
--- a/src/heightmap.cpp
+++ b/src/heightmap.cpp
@@ -26,7 +26,7 @@
  * Convert RGB colours to Grayscale using 29.9% Red, 58.7% Green, 11.4% Blue
  *  (average luminosity formula, NTSC Colour Space)
  */
-static inline byte RGBToGrayscale(byte red, byte green, byte blue)
+static INLINE byte RGBToGrayscale(byte red, byte green, byte blue)
 {
 	/* To avoid doubles and stuff, multiply it with a total of 65536 (16bits), then
 	 *  divide by it to normalize the value to a byte again. */
diff --git a/src/house.h b/src/house.h
--- a/src/house.h
+++ b/src/house.h
@@ -122,7 +122,7 @@
 
 	Money GetRemovalCost() const;
 
-	static inline HouseSpec *Get(size_t house_id)
+	static INLINE HouseSpec *Get(size_t house_id)
 	{
 		assert(house_id < HOUSE_MAX);
 		extern HouseSpec _house_specs[];
@@ -135,7 +135,7 @@
  * @param hid the HouseID to get the override for.
  * @return the HouseID to actually work with.
  */
-static inline HouseID GetTranslatedHouseID(HouseID hid)
+static INLINE HouseID GetTranslatedHouseID(HouseID hid)
 {
 	const HouseSpec *hs = HouseSpec::Get(hid);
 	return hs->grf_prop.override == INVALID_HOUSE_ID ? hid : hs->grf_prop.override;
diff --git a/src/industry.h b/src/industry.h
--- a/src/industry.h
+++ b/src/industry.h
@@ -81,7 +81,7 @@
 	 * @param tile The tile to check.
 	 * @return True if the tils is part of this industry.
 	 */
-	inline bool TileBelongsToIndustry(TileIndex tile) const
+	INLINE bool TileBelongsToIndustry(TileIndex tile) const
 	{
 		return IsTileType(tile, MP_INDUSTRY) && GetIndustryIndex(tile) == this->index;
 	}
@@ -92,7 +92,7 @@
 	 * @pre IsTileType(t, MP_INDUSTRY)
 	 * @return the industry
 	 */
-	static inline Industry *GetByTile(TileIndex tile)
+	static INLINE Industry *GetByTile(TileIndex tile)
 	{
 		return Industry::Get(GetIndustryIndex(tile));
 	}
@@ -105,7 +105,7 @@
 	 * @param type IndustryType to increment
 	 * @pre type < NUM_INDUSTRYTYPES
 	 */
-	static inline void IncIndustryTypeCount(IndustryType type)
+	static INLINE void IncIndustryTypeCount(IndustryType type)
 	{
 		assert(type < NUM_INDUSTRYTYPES);
 		counts[type]++;
@@ -116,7 +116,7 @@
 	 * @param type IndustryType to decrement
 	 * @pre type < NUM_INDUSTRYTYPES
 	 */
-	static inline void DecIndustryTypeCount(IndustryType type)
+	static INLINE void DecIndustryTypeCount(IndustryType type)
 	{
 		assert(type < NUM_INDUSTRYTYPES);
 		counts[type]--;
@@ -127,14 +127,14 @@
 	 * @param type IndustryType to query
 	 * @pre type < NUM_INDUSTRYTYPES
 	 */
-	static inline uint16 GetIndustryTypeCount(IndustryType type)
+	static INLINE uint16 GetIndustryTypeCount(IndustryType type)
 	{
 		assert(type < NUM_INDUSTRYTYPES);
 		return counts[type];
 	}
 
 	/** Resets industry counts. */
-	static inline void ResetIndustryCounts()
+	static INLINE void ResetIndustryCounts()
 	{
 		memset(&counts, 0, sizeof(counts));
 	}
diff --git a/src/industry_gui.cpp b/src/industry_gui.cpp
--- a/src/industry_gui.cpp
+++ b/src/industry_gui.cpp
@@ -97,7 +97,7 @@
  * @param suffixes is filled with the suffixes
  */
 template <typename TC, typename TS>
-static inline void GetAllCargoSuffixes(uint cb_offset, CargoSuffixType cst, const Industry *ind, IndustryType ind_type, const IndustrySpec *indspec, const TC &cargoes, TS &suffixes)
+static INLINE void GetAllCargoSuffixes(uint cb_offset, CargoSuffixType cst, const Industry *ind, IndustryType ind_type, const IndustrySpec *indspec, const TC &cargoes, TS &suffixes)
 {
 	assert_compile(lengthof(cargoes) <= lengthof(suffixes));
 	for (uint j = 0; j < lengthof(cargoes); j++) {
@@ -622,7 +622,7 @@
 
 static void UpdateIndustryProduction(Industry *i);
 
-static inline bool IsProductionAlterable(const Industry *i)
+static INLINE bool IsProductionAlterable(const Industry *i)
 {
 	const IndustrySpec *is = GetIndustrySpec(i->type);
 	return ((_game_mode == GM_EDITOR || _cheats.setup_prod.value) &&
@@ -1095,7 +1095,7 @@
 	 * @param id cargo slot
 	 * @return percents of cargo transported, or -1 if industry doesn't use this cargo slot
 	 */
-	static inline int GetCargoTransportedPercentsIfValid(const Industry *i, uint id)
+	static INLINE int GetCargoTransportedPercentsIfValid(const Industry *i, uint id)
 	{
 		assert(id < lengthof(i->produced_cargo));
 
diff --git a/src/industry_map.h b/src/industry_map.h
--- a/src/industry_map.h
+++ b/src/industry_map.h
@@ -62,7 +62,7 @@
  * @pre IsTileType(t, MP_INDUSTRY)
  * @return the industry ID
  */
-static inline IndustryID GetIndustryIndex(TileIndex t)
+static INLINE IndustryID GetIndustryIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
 	return _m[t].m2;
@@ -74,7 +74,7 @@
  * @pre IsTileType(t, MP_INDUSTRY)
  * @return true if and only if the industry tile is fully built
  */
-static inline bool IsIndustryCompleted(TileIndex t)
+static INLINE bool IsIndustryCompleted(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
 	return HasBit(_m[t].m1, 7);
@@ -88,7 +88,7 @@
  * @param isCompleted whether it is completed or not
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryCompleted(TileIndex tile, bool isCompleted)
+static INLINE void SetIndustryCompleted(TileIndex tile, bool isCompleted)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	SB(_m[tile].m1, 7, 1, isCompleted ? 1 :0);
@@ -100,7 +100,7 @@
  * @pre IsTileType(tile, MP_INDUSTRY)
  * @return the construction stage
  */
-static inline byte GetIndustryConstructionStage(TileIndex tile)
+static INLINE byte GetIndustryConstructionStage(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	return IsIndustryCompleted(tile) ? (byte)INDUSTRY_COMPLETED : GB(_m[tile].m1, 0, 2);
@@ -112,7 +112,7 @@
  * @param value the new construction stage
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryConstructionStage(TileIndex tile, byte value)
+static INLINE void SetIndustryConstructionStage(TileIndex tile, byte value)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	SB(_m[tile].m1, 0, 2, value);
@@ -125,7 +125,7 @@
  * @pre IsTileType(t, MP_INDUSTRY)
  * @return the gfx ID
  */
-static inline IndustryGfx GetCleanIndustryGfx(TileIndex t)
+static INLINE IndustryGfx GetCleanIndustryGfx(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
 	return _m[t].m5 | (GB(_m[t].m6, 2, 1) << 8);
@@ -137,7 +137,7 @@
  * @pre IsTileType(t, MP_INDUSTRY)
  * @return the gfx ID
  */
-static inline IndustryGfx GetIndustryGfx(TileIndex t)
+static INLINE IndustryGfx GetIndustryGfx(TileIndex t)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
 	return GetTranslatedIndustryTileID(GetCleanIndustryGfx(t));
@@ -149,7 +149,7 @@
  * @pre IsTileType(t, MP_INDUSTRY)
  * @param gfx the graphics ID
  */
-static inline void SetIndustryGfx(TileIndex t, IndustryGfx gfx)
+static INLINE void SetIndustryGfx(TileIndex t, IndustryGfx gfx)
 {
 	assert(IsTileType(t, MP_INDUSTRY));
 	_m[t].m5 = GB(gfx, 0, 8);
@@ -162,7 +162,7 @@
  * @pre IsTileType(tile, MP_INDUSTRY)
  * @return the construction counter
  */
-static inline byte GetIndustryConstructionCounter(TileIndex tile)
+static INLINE byte GetIndustryConstructionCounter(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	return GB(_m[tile].m1, 2, 2);
@@ -174,7 +174,7 @@
  * @param value the new value for the construction counter
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryConstructionCounter(TileIndex tile, byte value)
+static INLINE void SetIndustryConstructionCounter(TileIndex tile, byte value)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	SB(_m[tile].m1, 2, 2, value);
@@ -187,7 +187,7 @@
  * @param tile the tile to query
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void ResetIndustryConstructionStage(TileIndex tile)
+static INLINE void ResetIndustryConstructionStage(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	SB(_m[tile].m1, 0, 4, 0);
@@ -199,7 +199,7 @@
  * @param tile the tile to get the animation loop number of
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline byte GetIndustryAnimationLoop(TileIndex tile)
+static INLINE byte GetIndustryAnimationLoop(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	return _m[tile].m4;
@@ -211,7 +211,7 @@
  * @param count the new animation frame number
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryAnimationLoop(TileIndex tile, byte count)
+static INLINE void SetIndustryAnimationLoop(TileIndex tile, byte count)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	_m[tile].m4 = count;
@@ -224,7 +224,7 @@
  * @pre IsTileType(tile, MP_INDUSTRY)
  * @return requested bits
  */
-static inline byte GetIndustryRandomBits(TileIndex tile)
+static INLINE byte GetIndustryRandomBits(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	return _m[tile].m3;
@@ -237,7 +237,7 @@
  * @param bits the random bits
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryRandomBits(TileIndex tile, byte bits)
+static INLINE void SetIndustryRandomBits(TileIndex tile, byte bits)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	_m[tile].m3 = bits;
@@ -250,7 +250,7 @@
  * @pre IsTileType(tile, MP_INDUSTRY)
  * @return requested triggers
  */
-static inline byte GetIndustryTriggers(TileIndex tile)
+static INLINE byte GetIndustryTriggers(TileIndex tile)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	return GB(_m[tile].m6, 3, 3);
@@ -264,7 +264,7 @@
  * @param triggers the triggers to set
  * @pre IsTileType(tile, MP_INDUSTRY)
  */
-static inline void SetIndustryTriggers(TileIndex tile, byte triggers)
+static INLINE void SetIndustryTriggers(TileIndex tile, byte triggers)
 {
 	assert(IsTileType(tile, MP_INDUSTRY));
 	SB(_m[tile].m6, 3, 3, triggers);
@@ -278,7 +278,7 @@
  * @param random the random value
  * @param wc     the water class for this industry; only useful when build on water
  */
-static inline void MakeIndustry(TileIndex t, IndustryID index, IndustryGfx gfx, uint8 random, WaterClass wc)
+static INLINE void MakeIndustry(TileIndex t, IndustryID index, IndustryGfx gfx, uint8 random, WaterClass wc)
 {
 	SetTileType(t, MP_INDUSTRY);
 	_m[t].m1 = 0;
diff --git a/src/industrytype.h b/src/industrytype.h
--- a/src/industrytype.h
+++ b/src/industrytype.h
@@ -183,7 +183,7 @@
  * @param gfx the type to get the override for.
  * @return the gfx to actually work with.
  */
-static inline IndustryGfx GetTranslatedIndustryTileID(IndustryGfx gfx)
+static INLINE IndustryGfx GetTranslatedIndustryTileID(IndustryGfx gfx)
 {
 	/* the 0xFF should be GFX_WATERTILE_SPECIALCHECK but for reasons of include mess,
 	 * we'll simplify the writing.
diff --git a/src/landscape.h b/src/landscape.h
--- a/src/landscape.h
+++ b/src/landscape.h
@@ -51,7 +51,7 @@
  * @param corner The corner.
  * @return Z position of corner relative to TileZ.
  */
-static inline int GetSlopePixelZInCorner(Slope tileh, Corner corner)
+static INLINE int GetSlopePixelZInCorner(Slope tileh, Corner corner)
 {
 	return GetSlopeZInCorner(tileh, corner) * TILE_HEIGHT;
 }
@@ -64,7 +64,7 @@
  * @param z returns the z of the foundation slope. (Can be NULL, if not needed)
  * @return The slope on top of the foundation.
  */
-static inline Slope GetFoundationPixelSlope(TileIndex tile, int *z)
+static INLINE Slope GetFoundationPixelSlope(TileIndex tile, int *z)
 {
 	assert(z != NULL);
 	Slope s = GetFoundationSlope(tile, z);
@@ -80,7 +80,7 @@
  * @return Equivalent coordinate in the 2D view.
  * @see RemapCoords2
  */
-static inline Point RemapCoords(int x, int y, int z)
+static INLINE Point RemapCoords(int x, int y, int z)
 {
 	Point pt;
 	pt.x = (y - x) * 2 * ZOOM_LVL_BASE;
@@ -96,7 +96,7 @@
  * @return Equivalent coordinate in the 2D view.
  * @see RemapCoords
  */
-static inline Point RemapCoords2(int x, int y)
+static INLINE Point RemapCoords2(int x, int y)
 {
 	return RemapCoords(x, y, GetSlopePixelZ(x, y));
 }
@@ -109,7 +109,7 @@
  * @return X and Y components of equivalent world or tile coordinate.
  * @note Inverse of #RemapCoords function. Smaller values may get rounded.
  */
-static inline Point InverseRemapCoords(int x, int y)
+static INLINE Point InverseRemapCoords(int x, int y)
 {
 	Point pt = {(y * 2 - x) >> (2 + ZOOM_LVL_SHIFT), (y * 2 + x) >> (2 + ZOOM_LVL_SHIFT)};
 	return pt;
@@ -124,7 +124,7 @@
  * @param s  The #Slope to modify.
  * @return   Increment to the tile Z coordinate.
  */
-static inline uint ApplyPixelFoundationToSlope(Foundation f, Slope *s)
+static INLINE uint ApplyPixelFoundationToSlope(Foundation f, Slope *s)
 {
 	return ApplyFoundationToSlope(f, s) * TILE_HEIGHT;
 }
diff --git a/src/map_func.h b/src/map_func.h
--- a/src/map_func.h
+++ b/src/map_func.h
@@ -50,7 +50,7 @@
  * @note try to avoid using this one
  * @return 2^"return value" == MapSizeX()
  */
-static inline uint MapLogX()
+static INLINE uint MapLogX()
 {
 	extern uint _map_log_x;
 	return _map_log_x;
@@ -61,7 +61,7 @@
  * @note try to avoid using this one
  * @return 2^"return value" == MapSizeY()
  */
-static inline uint MapLogY()
+static INLINE uint MapLogY()
 {
 	extern uint _map_log_y;
 	return _map_log_y;
@@ -71,7 +71,7 @@
  * Get the size of the map along the X
  * @return the number of tiles along the X of the map
  */
-static inline uint MapSizeX()
+static INLINE uint MapSizeX()
 {
 	extern uint _map_size_x;
 	return _map_size_x;
@@ -81,7 +81,7 @@
  * Get the size of the map along the Y
  * @return the number of tiles along the Y of the map
  */
-static inline uint MapSizeY()
+static INLINE uint MapSizeY()
 {
 	extern uint _map_size_y;
 	return _map_size_y;
@@ -91,7 +91,7 @@
  * Get the size of the map
  * @return the number of tiles of the map
  */
-static inline uint MapSize()
+static INLINE uint MapSize()
 {
 	extern uint _map_size;
 	return _map_size;
@@ -101,7 +101,7 @@
  * Gets the maximum X coordinate within the map, including MP_VOID
  * @return the maximum X coordinate
  */
-static inline uint MapMaxX()
+static INLINE uint MapMaxX()
 {
 	return MapSizeX() - 1;
 }
@@ -110,7 +110,7 @@
  * Gets the maximum Y coordinate within the map, including MP_VOID
  * @return the maximum Y coordinate
  */
-static inline uint MapMaxY()
+static INLINE uint MapMaxY()
 {
 	return MapSizeY() - 1;
 }
@@ -121,7 +121,7 @@
  * @param n the value to scale
  * @return the scaled size
  */
-static inline uint ScaleByMapSize(uint n)
+static INLINE uint ScaleByMapSize(uint n)
 {
 	/* Subtract 12 from shift in order to prevent integer overflow
 	 * for large values of n. It's safe since the min mapsize is 64x64. */
@@ -135,7 +135,7 @@
  * @param n the value to scale
  * @return the scaled size
  */
-static inline uint ScaleByMapSize1D(uint n)
+static INLINE uint ScaleByMapSize1D(uint n)
 {
 	/* Normal circumference for the X+Y is 256+256 = 1<<9
 	 * Note, not actually taking the full circumference into account,
@@ -162,7 +162,7 @@
  * @param y The y coordinate of the tile
  * @return The TileIndex calculated by the coordinate
  */
-static inline TileIndex TileXY(uint x, uint y)
+static INLINE TileIndex TileXY(uint x, uint y)
 {
 	return (y << MapLogX()) + x;
 }
@@ -178,7 +178,7 @@
  * @return The resulting offset value of the given coordinate
  * @see ToTileIndexDiff(TileIndexDiffC)
  */
-static inline TileIndexDiff TileDiffXY(int x, int y)
+static INLINE TileIndexDiff TileDiffXY(int x, int y)
 {
 	/* Multiplication gives much better optimization on MSVC than shifting.
 	 * 0 << shift isn't optimized to 0 properly.
@@ -193,7 +193,7 @@
  * @param y The virtual y coordinate of the tile.
  * @return The TileIndex calculated by the coordinate.
  */
-static inline TileIndex TileVirtXY(uint x, uint y)
+static INLINE TileIndex TileVirtXY(uint x, uint y)
 {
 	return (y >> 4 << MapLogX()) + (x >> 4);
 }
@@ -204,7 +204,7 @@
  * @param tile the tile to get the X component of
  * @return the X component
  */
-static inline uint TileX(TileIndex tile)
+static INLINE uint TileX(TileIndex tile)
 {
 	return tile & MapMaxX();
 }
@@ -214,7 +214,7 @@
  * @param tile the tile to get the Y component of
  * @return the Y component
  */
-static inline uint TileY(TileIndex tile)
+static INLINE uint TileY(TileIndex tile)
 {
 	return tile >> MapLogX();
 }
@@ -229,7 +229,7 @@
  * @return The difference between two tiles.
  * @see TileDiffXY(int, int)
  */
-static inline TileIndexDiff ToTileIndexDiff(TileIndexDiffC tidc)
+static INLINE TileIndexDiff ToTileIndexDiff(TileIndexDiffC tidc)
 {
 	return (tidc.y << MapLogX()) + tidc.x;
 }
@@ -267,7 +267,7 @@
  * @param dir The given direction
  * @return The offset as TileIndexDiffC value
  */
-static inline TileIndexDiffC TileIndexDiffCByDiagDir(DiagDirection dir)
+static INLINE TileIndexDiffC TileIndexDiffCByDiagDir(DiagDirection dir)
 {
 	extern const TileIndexDiffC _tileoffs_by_diagdir[DIAGDIR_END];
 
@@ -281,7 +281,7 @@
  * @param dir The given direction
  * @return The offset as TileIndexDiffC value
  */
-static inline TileIndexDiffC TileIndexDiffCByDir(Direction dir)
+static INLINE TileIndexDiffC TileIndexDiffCByDir(Direction dir)
 {
 	extern const TileIndexDiffC _tileoffs_by_dir[DIR_END];
 
@@ -299,7 +299,7 @@
  * @param diff The offset to add on the tile
  * @return The resulting TileIndex
  */
-static inline TileIndex AddTileIndexDiffCWrap(TileIndex tile, TileIndexDiffC diff)
+static INLINE TileIndex AddTileIndexDiffCWrap(TileIndex tile, TileIndexDiffC diff)
 {
 	int x = TileX(tile) + diff.x;
 	int y = TileY(tile) + diff.y;
@@ -315,7 +315,7 @@
  * @param tile_b to tile
  * @return the difference between tila_a and tile_b
  */
-static inline TileIndexDiffC TileIndexToTileIndexDiffC(TileIndex tile_a, TileIndex tile_b)
+static INLINE TileIndexDiffC TileIndexToTileIndexDiffC(TileIndex tile_a, TileIndex tile_b)
 {
 	TileIndexDiffC difference;
 
@@ -340,7 +340,7 @@
  * @return The resulting TileIndexDiff
  * @see TileIndexDiffCByDiagDir
  */
-static inline TileIndexDiff TileOffsByDiagDir(DiagDirection dir)
+static INLINE TileIndexDiff TileOffsByDiagDir(DiagDirection dir)
 {
 	extern const TileIndexDiffC _tileoffs_by_diagdir[DIAGDIR_END];
 
@@ -354,7 +354,7 @@
  * @param dir The direction to convert from
  * @return The resulting TileIndexDiff
  */
-static inline TileIndexDiff TileOffsByDir(Direction dir)
+static INLINE TileIndexDiff TileOffsByDir(Direction dir)
 {
 	extern const TileIndexDiffC _tileoffs_by_dir[DIR_END];
 
@@ -369,7 +369,7 @@
  * @param dir The direction in which we want to step
  * @return the moved tile
  */
-static inline TileIndex TileAddByDiagDir(TileIndex tile, DiagDirection dir)
+static INLINE TileIndex TileAddByDiagDir(TileIndex tile, DiagDirection dir)
 {
 	return TILE_ADD(tile, TileOffsByDiagDir(dir));
 }
@@ -381,7 +381,7 @@
  * @param tile_to Destination tile
  * @return DiagDirection from tile_from towards tile_to, or INVALID_DIAGDIR if the tiles are not on an axis
  */
-static inline DiagDirection DiagdirBetweenTiles(TileIndex tile_from, TileIndex tile_to)
+static INLINE DiagDirection DiagdirBetweenTiles(TileIndex tile_from, TileIndex tile_to)
 {
 	int dx = (int)TileX(tile_to) - (int)TileX(tile_from);
 	int dy = (int)TileY(tile_to) - (int)TileY(tile_from);
@@ -411,7 +411,7 @@
  * @param r the random 'seed'
  * @return a valid tile
  */
-static inline TileIndex RandomTileSeed(uint32 r)
+static INLINE TileIndex RandomTileSeed(uint32 r)
 {
 	return TILE_MASK(r);
 }
diff --git a/src/misc/array.hpp b/src/misc/array.hpp
--- a/src/misc/array.hpp
+++ b/src/misc/array.hpp
@@ -30,7 +30,7 @@
 	SuperArray data; ///< array of arrays of items
 
 	/** return first sub-array with free space for new item */
-	inline SubArray& FirstFreeSubArray()
+	INLINE SubArray& FirstFreeSubArray()
 	{
 		uint super_size = data.Length();
 		if (super_size > 0) {
@@ -42,11 +42,11 @@
 
 public:
 	/** implicit constructor */
-	inline SmallArray() { }
+	INLINE SmallArray() { }
 	/** Clear (destroy) all items */
-	inline void Clear() {data.Clear();}
+	INLINE void Clear() {data.Clear();}
 	/** Return actual number of items */
-	inline uint Length() const
+	INLINE uint Length() const
 	{
 		uint super_size = data.Length();
 		if (super_size == 0) return 0;
@@ -54,22 +54,22 @@
 		return (super_size - 1) * B + sub_size;
 	}
 	/** return true if array is empty */
-	inline bool IsEmpty() { return data.IsEmpty(); }
+	INLINE bool IsEmpty() { return data.IsEmpty(); }
 	/** return true if array is full */
-	inline bool IsFull() { return data.IsFull() && data[N - 1].IsFull(); }
+	INLINE bool IsFull() { return data.IsFull() && data[N - 1].IsFull(); }
 	/** allocate but not construct new item */
-	inline T *Append() { return FirstFreeSubArray().Append(); }
+	INLINE T *Append() { return FirstFreeSubArray().Append(); }
 	/** allocate and construct new item */
-	inline T *AppendC() { return FirstFreeSubArray().AppendC(); }
+	INLINE T *AppendC() { return FirstFreeSubArray().AppendC(); }
 	/** indexed access (non-const) */
-	inline T& operator [] (uint index)
+	INLINE T& operator [] (uint index)
 	{
 		const SubArray& s = data[index / B];
 		T& item = s[index % B];
 		return item;
 	}
 	/** indexed access (const) */
-	inline const T& operator [] (uint index) const
+	INLINE const T& operator [] (uint index) const
 	{
 		const SubArray& s = data[index / B];
 		const T& item = s[index % B];
diff --git a/src/misc/binaryheap.hpp b/src/misc/binaryheap.hpp
--- a/src/misc/binaryheap.hpp
+++ b/src/misc/binaryheap.hpp
@@ -85,7 +85,7 @@
 	 * @param item The proposed item for filling the gap
 	 * @return The (gap)position where the item fits
 	 */
-	inline uint HeapifyDown(uint gap, T *item)
+	INLINE uint HeapifyDown(uint gap, T *item)
 	{
 		assert(gap != 0);
 
@@ -121,7 +121,7 @@
 	 * @param item The proposed item for filling the gap
 	 * @return The (gap)position where the item fits
 	 */
-	inline uint HeapifyUp(uint gap, T *item)
+	INLINE uint HeapifyUp(uint gap, T *item)
 	{
 		assert(gap != 0);
 
@@ -142,7 +142,7 @@
 
 #if BINARYHEAP_CHECK
 	/** Verify the heap consistency */
-	inline void CheckConsistency()
+	INLINE void CheckConsistency()
 	{
 		for (uint child = 2; child <= this->items; child++) {
 			uint parent = child / 2;
@@ -157,28 +157,28 @@
 	 *
 	 *  @return The number of items in the queue
 	 */
-	inline uint Length() const { return this->items; }
+	INLINE uint Length() const { return this->items; }
 
 	/**
 	 * Test if the priority queue is empty.
 	 *
 	 * @return True if empty
 	 */
-	inline bool IsEmpty() const { return this->items == 0; }
+	INLINE bool IsEmpty() const { return this->items == 0; }
 
 	/**
 	 * Test if the priority queue is full.
 	 *
 	 * @return True if full.
 	 */
-	inline bool IsFull() const { return this->items >= this->capacity; }
+	INLINE bool IsFull() const { return this->items >= this->capacity; }
 
 	/**
 	 * Get the smallest item in the binary tree.
 	 *
 	 * @return The smallest item, or throw assert if empty.
 	 */
-	inline T *Begin()
+	INLINE T *Begin()
 	{
 		assert(!this->IsEmpty());
 		return this->data[1];
@@ -191,7 +191,7 @@
 	 *
 	 * @return The last item
 	 */
-	inline T *End()
+	INLINE T *End()
 	{
 		return this->data[1 + this->items];
 	}
@@ -201,7 +201,7 @@
 	 *
 	 * @param new_item The pointer to the new item
 	 */
-	inline void Include(T *new_item)
+	INLINE void Include(T *new_item)
 	{
 		if (this->IsFull()) {
 			assert(this->capacity < UINT_MAX / 2);
@@ -222,7 +222,7 @@
 	 *
 	 * @return The pointer to the removed item
 	 */
-	inline T *Shift()
+	INLINE T *Shift()
 	{
 		assert(!this->IsEmpty());
 
@@ -244,7 +244,7 @@
 	 *
 	 * @param index The position of the item in the heap
 	 */
-	inline void Remove(uint index)
+	INLINE void Remove(uint index)
 	{
 		if (index < this->items) {
 			assert(index != 0);
@@ -272,7 +272,7 @@
 	 * @param item The reference to the item
 	 * @return The index of the item or zero if not found
 	 */
-	inline uint FindIndex(const T &item) const
+	INLINE uint FindIndex(const T &item) const
 	{
 		if (this->IsEmpty()) return 0;
 		for (T **ppI = this->data + 1, **ppLast = ppI + this->items; ppI <= ppLast; ppI++) {
@@ -287,7 +287,7 @@
 	 * Make the priority queue empty.
 	 * All remaining items will remain untouched.
 	 */
-	inline void Clear() { this->items = 0; }
+	INLINE void Clear() { this->items = 0; }
 };
 
 #endif /* BINARYHEAP_HPP */
diff --git a/src/misc/blob.hpp b/src/misc/blob.hpp
--- a/src/misc/blob.hpp
+++ b/src/misc/blob.hpp
@@ -71,17 +71,17 @@
 	static const size_t header_size = sizeof(BlobHeader);
 
 	/** default constructor - initializes empty blob */
-	inline ByteBlob() { InitEmpty(); }
+	INLINE ByteBlob() { InitEmpty(); }
 
 	/** copy constructor */
-	inline ByteBlob(const ByteBlob &src)
+	INLINE ByteBlob(const ByteBlob &src)
 	{
 		InitEmpty();
 		AppendRaw(src);
 	}
 
 	/** move constructor - take ownership of blob data */
-	inline ByteBlob(BlobHeader * const & src)
+	INLINE ByteBlob(BlobHeader * const & src)
 	{
 		assert(src != NULL);
 		header = src;
@@ -89,14 +89,14 @@
 	}
 
 	/** destructor */
-	inline ~ByteBlob()
+	INLINE ~ByteBlob()
 	{
 		Free();
 	}
 
 protected:
 	/** all allocation should happen here */
-	static inline BlobHeader *RawAlloc(size_t num_bytes)
+	static INLINE BlobHeader *RawAlloc(size_t num_bytes)
 	{
 		return (BlobHeader*)MallocT<byte>(num_bytes);
 	}
@@ -105,13 +105,13 @@
 	 * Return header pointer to the static BlobHeader with
 	 * both items and capacity containing zero
 	 */
-	static inline BlobHeader *Zero()
+	static INLINE BlobHeader *Zero()
 	{
 		return const_cast<BlobHeader *>(&ByteBlob::hdrEmpty[1]);
 	}
 
 	/** simple allocation policy - can be optimized later */
-	static inline size_t AllocPolicy(size_t min_alloc)
+	static INLINE size_t AllocPolicy(size_t min_alloc)
 	{
 		if (min_alloc < (1 << 9)) {
 			if (min_alloc < (1 << 5)) return (1 << 5);
@@ -130,7 +130,7 @@
 	}
 
 	/** all deallocations should happen here */
-	static inline void RawFree(BlobHeader *p)
+	static INLINE void RawFree(BlobHeader *p)
 	{
 		/* Just to silence an unsilencable GCC 4.4+ warning. */
 		assert(p != ByteBlob::hdrEmpty);
@@ -140,74 +140,74 @@
 	}
 
 	/** initialize the empty blob */
-	inline void InitEmpty()
+	INLINE void InitEmpty()
 	{
 		header = Zero();
 	}
 
 	/** initialize blob by attaching it to the given header followed by data */
-	inline void Init(BlobHeader *src)
+	INLINE void Init(BlobHeader *src)
 	{
 		header = &src[1];
 	}
 
 	/** blob header accessor - use it rather than using the pointer arithmetics directly - non-const version */
-	inline BlobHeader& Hdr()
+	INLINE BlobHeader& Hdr()
 	{
 		return *(header - 1);
 	}
 
 	/** blob header accessor - use it rather than using the pointer arithmetics directly - const version */
-	inline const BlobHeader& Hdr() const
+	INLINE const BlobHeader& Hdr() const
 	{
 		return *(header - 1);
 	}
 
 	/** return reference to the actual blob size - used when the size needs to be modified */
-	inline size_t& LengthRef()
+	INLINE size_t& LengthRef()
 	{
 		return Hdr().items;
 	}
 
 public:
 	/** return true if blob doesn't contain valid data */
-	inline bool IsEmpty() const
+	INLINE bool IsEmpty() const
 	{
 		return Length() == 0;
 	}
 
 	/** return the number of valid data bytes in the blob */
-	inline size_t Length() const
+	INLINE size_t Length() const
 	{
 		return Hdr().items;
 	}
 
 	/** return the current blob capacity in bytes */
-	inline size_t Capacity() const
+	INLINE size_t Capacity() const
 	{
 		return Hdr().capacity;
 	}
 
 	/** return pointer to the first byte of data - non-const version */
-	inline byte *Begin()
+	INLINE byte *Begin()
 	{
 		return data;
 	}
 
 	/** return pointer to the first byte of data - const version */
-	inline const byte *Begin() const
+	INLINE const byte *Begin() const
 	{
 		return data;
 	}
 
 	/** invalidate blob's data - doesn't free buffer */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		LengthRef() = 0;
 	}
 
 	/** free the blob's memory */
-	inline void Free()
+	INLINE void Free()
 	{
 		if (Capacity() > 0) {
 			RawFree(&Hdr());
@@ -216,7 +216,7 @@
 	}
 
 	/** append new bytes at the end of existing data bytes - reallocates if necessary */
-	inline void AppendRaw(const void *p, size_t num_bytes)
+	INLINE void AppendRaw(const void *p, size_t num_bytes)
 	{
 		assert(p != NULL);
 		if (num_bytes > 0) {
@@ -225,7 +225,7 @@
 	}
 
 	/** append bytes from given source blob to the end of existing data bytes - reallocates if necessary */
-	inline void AppendRaw(const ByteBlob& src)
+	INLINE void AppendRaw(const ByteBlob& src)
 	{
 		if (!src.IsEmpty()) {
 			memcpy(Append(src.Length()), src.Begin(), src.Length());
@@ -236,7 +236,7 @@
 	 * Reallocate if there is no free space for num_bytes bytes.
 	 *  @return pointer to the new data to be added
 	 */
-	inline byte *Prepare(size_t num_bytes)
+	INLINE byte *Prepare(size_t num_bytes)
 	{
 		size_t new_size = Length() + num_bytes;
 		if (new_size > Capacity()) SmartAlloc(new_size);
@@ -247,7 +247,7 @@
 	 * Increase Length() by num_bytes.
 	 *  @return pointer to the new data added
 	 */
-	inline byte *Append(size_t num_bytes)
+	INLINE byte *Append(size_t num_bytes)
 	{
 		byte *pNewData = Prepare(num_bytes);
 		LengthRef() += num_bytes;
@@ -281,7 +281,7 @@
 	}
 
 	/** fixing the four bytes at the end of blob data - useful when blob is used to hold string */
-	inline void FixTail() const
+	INLINE void FixTail() const
 	{
 		if (Capacity() > 0) {
 			byte *p = &data[Length()];
@@ -317,73 +317,73 @@
 	};
 
 	/** Default constructor - makes new Blob ready to accept any data */
-	inline CBlobT()
+	INLINE CBlobT()
 		: base()
 	{}
 
 	/** Take ownership constructor */
-	inline CBlobT(const OnTransfer& ot)
+	INLINE CBlobT(const OnTransfer& ot)
 		: base(ot.header)
 	{}
 
 	/** Destructor - ensures that allocated memory (if any) is freed */
-	inline ~CBlobT()
+	INLINE ~CBlobT()
 	{
 		Free();
 	}
 
 	/** Check the validity of item index (only in debug mode) */
-	inline void CheckIdx(size_t index) const
+	INLINE void CheckIdx(size_t index) const
 	{
 		assert(index < Size());
 	}
 
 	/** Return pointer to the first data item - non-const version */
-	inline T *Data()
+	INLINE T *Data()
 	{
 		return (T*)base::Begin();
 	}
 
 	/** Return pointer to the first data item - const version */
-	inline const T *Data() const
+	INLINE const T *Data() const
 	{
 		return (const T*)base::Begin();
 	}
 
 	/** Return pointer to the index-th data item - non-const version */
-	inline T *Data(size_t index)
+	INLINE T *Data(size_t index)
 	{
 		CheckIdx(index);
 		return (Data() + index);
 	}
 
 	/** Return pointer to the index-th data item - const version */
-	inline const T *Data(size_t index) const
+	INLINE const T *Data(size_t index) const
 	{
 		CheckIdx(index);
 		return (Data() + index);
 	}
 
 	/** Return number of items in the Blob */
-	inline size_t Size() const
+	INLINE size_t Size() const
 	{
 		return (base::Length() / type_size);
 	}
 
 	/** Return total number of items that can fit in the Blob without buffer reallocation */
-	inline size_t MaxSize() const
+	INLINE size_t MaxSize() const
 	{
 		return (base::Capacity() / type_size);
 	}
 
 	/** Return number of additional items that can fit in the Blob without buffer reallocation */
-	inline size_t GetReserve() const
+	INLINE size_t GetReserve() const
 	{
 		return ((base::Capacity() - base::Length()) / type_size);
 	}
 
 	/** Grow number of data items in Blob by given number - doesn't construct items */
-	inline T *GrowSizeNC(size_t num_items)
+	INLINE T *GrowSizeNC(size_t num_items)
 	{
 		return (T*)base::Append(num_items * type_size);
 	}
@@ -392,12 +392,12 @@
 	 * Ensures that given number of items can be added to the end of Blob. Returns pointer to the
 	 *  first free (unused) item
 	 */
-	inline T *MakeFreeSpace(size_t num_items)
+	INLINE T *MakeFreeSpace(size_t num_items)
 	{
 		return (T*)base::Prepare(num_items * type_size);
 	}
 
-	inline OnTransfer Transfer()
+	INLINE OnTransfer Transfer()
 	{
 		return OnTransfer(*this);
 	}
diff --git a/src/misc/countedptr.hpp b/src/misc/countedptr.hpp
--- a/src/misc/countedptr.hpp
+++ b/src/misc/countedptr.hpp
@@ -35,64 +35,64 @@
 
 public:
 	/** default (NULL) construct or construct from a raw pointer */
-	inline CCountedPtr(Tcls *pObj = NULL) : m_pT(pObj) {AddRef();}
+	INLINE CCountedPtr(Tcls *pObj = NULL) : m_pT(pObj) {AddRef();}
 
 	/** copy constructor (invoked also when initializing from another smart ptr) */
-	inline CCountedPtr(const CCountedPtr& src) : m_pT(src.m_pT) {AddRef();}
+	INLINE CCountedPtr(const CCountedPtr& src) : m_pT(src.m_pT) {AddRef();}
 
 	/** destructor releasing the reference */
-	inline ~CCountedPtr() {Release();}
+	INLINE ~CCountedPtr() {Release();}
 
 protected:
 	/** add one ref to the underlaying object */
-	inline void AddRef() {if (m_pT != NULL) m_pT->AddRef();}
+	INLINE void AddRef() {if (m_pT != NULL) m_pT->AddRef();}
 
 public:
 	/** release smart pointer (and decrement ref count) if not null */
-	inline void Release() {if (m_pT != NULL) {Tcls *pT = m_pT; m_pT = NULL; pT->Release();}}
+	INLINE void Release() {if (m_pT != NULL) {Tcls *pT = m_pT; m_pT = NULL; pT->Release();}}
 
 	/** dereference of smart pointer - const way */
-	inline const Tcls *operator -> () const {assert(m_pT != NULL); return m_pT;}
+	INLINE const Tcls *operator -> () const {assert(m_pT != NULL); return m_pT;}
 
 	/** dereference of smart pointer - non const way */
-	inline Tcls *operator -> () {assert(m_pT != NULL); return m_pT;}
+	INLINE Tcls *operator -> () {assert(m_pT != NULL); return m_pT;}
 
 	/** raw pointer casting operator - const way */
-	inline operator const Tcls*() const {assert(m_pT == NULL); return m_pT;}
+	INLINE operator const Tcls*() const {assert(m_pT == NULL); return m_pT;}
 
 	/** raw pointer casting operator - non-const way */
-	inline operator Tcls*() {return m_pT;}
+	INLINE operator Tcls*() {return m_pT;}
 
 	/** operator & to support output arguments */
-	inline Tcls** operator &() {assert(m_pT == NULL); return &m_pT;}
+	INLINE Tcls** operator &() {assert(m_pT == NULL); return &m_pT;}
 
 	/** assignment operator from raw ptr */
-	inline CCountedPtr& operator = (Tcls *pT) {Assign(pT); return *this;}
+	INLINE CCountedPtr& operator = (Tcls *pT) {Assign(pT); return *this;}
 
 	/** assignment operator from another smart ptr */
-	inline CCountedPtr& operator = (const CCountedPtr& src) {Assign(src.m_pT); return *this;}
+	INLINE CCountedPtr& operator = (const CCountedPtr& src) {Assign(src.m_pT); return *this;}
 
 	/** assignment operator helper */
-	inline void Assign(Tcls *pT);
+	INLINE void Assign(Tcls *pT);
 
 	/** one way how to test for NULL value */
-	inline bool IsNull() const {return m_pT == NULL;}
+	INLINE bool IsNull() const {return m_pT == NULL;}
 
 	/** another way how to test for NULL value */
-	//inline bool operator == (const CCountedPtr& sp) const {return m_pT == sp.m_pT;}
+	//INLINE bool operator == (const CCountedPtr& sp) const {return m_pT == sp.m_pT;}
 
 	/** yet another way how to test for NULL value */
-	//inline bool operator != (const CCountedPtr& sp) const {return m_pT != sp.m_pT;}
+	//INLINE bool operator != (const CCountedPtr& sp) const {return m_pT != sp.m_pT;}
 
 	/** assign pointer w/o incrementing ref count */
-	inline void Attach(Tcls *pT) {Release(); m_pT = pT;}
+	INLINE void Attach(Tcls *pT) {Release(); m_pT = pT;}
 
 	/** detach pointer w/o decrementing ref count */
-	inline Tcls *Detach() {Tcls *pT = m_pT; m_pT = NULL; return pT;}
+	INLINE Tcls *Detach() {Tcls *pT = m_pT; m_pT = NULL; return pT;}
 };
 
 template <class Tcls_>
-inline void CCountedPtr<Tcls_>::Assign(Tcls *pT)
+INLINE void CCountedPtr<Tcls_>::Assign(Tcls *pT)
 {
 	/* if they are the same, we do nothing */
 	if (pT != m_pT) {
diff --git a/src/misc/dbg_helpers.h b/src/misc/dbg_helpers.h
--- a/src/misc/dbg_helpers.h
+++ b/src/misc/dbg_helpers.h
@@ -37,7 +37,7 @@
  * or t_unk when index is out of bounds.
  */
 template <typename E, typename T>
-inline typename ArrayT<T>::item_t ItemAtT(E idx, const T &t, typename ArrayT<T>::item_t t_unk)
+INLINE typename ArrayT<T>::item_t ItemAtT(E idx, const T &t, typename ArrayT<T>::item_t t_unk)
 {
 	if ((size_t)idx >= ArrayT<T>::length) {
 		return t_unk;
@@ -51,7 +51,7 @@
  * or t_unk when index is out of bounds.
  */
 template <typename E, typename T>
-inline typename ArrayT<T>::item_t ItemAtT(E idx, const T &t, typename ArrayT<T>::item_t t_unk, E idx_inv, typename ArrayT<T>::item_t t_inv)
+INLINE typename ArrayT<T>::item_t ItemAtT(E idx, const T &t, typename ArrayT<T>::item_t t_unk, E idx_inv, typename ArrayT<T>::item_t t_inv)
 {
 	if ((size_t)idx < ArrayT<T>::length) {
 		return t[idx];
@@ -69,7 +69,7 @@
  * or t_unk when index is out of bounds.
  */
 template <typename E, typename T>
-inline CStrA ComposeNameT(E value, T &t, const char *t_unk, E val_inv, const char *name_inv)
+INLINE CStrA ComposeNameT(E value, T &t, const char *t_unk, E val_inv, const char *name_inv)
 {
 	CStrA out;
 	if (value == val_inv) {
diff --git a/src/misc/fixedsizearray.hpp b/src/misc/fixedsizearray.hpp
--- a/src/misc/fixedsizearray.hpp
+++ b/src/misc/fixedsizearray.hpp
@@ -41,13 +41,13 @@
 	T *data;
 
 	/** return reference to the array header (non-const) */
-	inline ArrayHeader& Hdr() { return *(ArrayHeader*)(((byte*)data) - HeaderSize); }
+	INLINE ArrayHeader& Hdr() { return *(ArrayHeader*)(((byte*)data) - HeaderSize); }
 	/** return reference to the array header (const) */
-	inline const ArrayHeader& Hdr() const { return *(ArrayHeader*)(((byte*)data) - HeaderSize); }
+	INLINE const ArrayHeader& Hdr() const { return *(ArrayHeader*)(((byte*)data) - HeaderSize); }
 	/** return reference to the block reference counter */
-	inline uint& RefCnt() { return Hdr().reference_count; }
+	INLINE uint& RefCnt() { return Hdr().reference_count; }
 	/** return reference to number of used items */
-	inline uint& SizeRef() { return Hdr().items; }
+	INLINE uint& SizeRef() { return Hdr().items; }
 
 public:
 	/** Default constructor. Preallocate space for items and header, then initialize header. */
@@ -83,7 +83,7 @@
 	}
 
 	/** Clear (destroy) all items */
-	inline void Clear()
+	INLINE void Clear()
 	{
 		/* Walk through all allocated items backward and destroy them
 		 * Note: this->Length() can be zero. In that case data[this->Length() - 1] is evaluated unsigned
@@ -96,19 +96,19 @@
 	}
 
 	/** return number of used items */
-	inline uint Length() const { return Hdr().items; }
+	INLINE uint Length() const { return Hdr().items; }
 	/** return true if array is full */
-	inline bool IsFull() const { return Length() >= C; }
+	INLINE bool IsFull() const { return Length() >= C; }
 	/** return true if array is empty */
-	inline bool IsEmpty() const { return Length() <= 0; }
+	INLINE bool IsEmpty() const { return Length() <= 0; }
 	/** add (allocate), but don't construct item */
-	inline T *Append() { assert(!IsFull()); return &data[SizeRef()++]; }
+	INLINE T *Append() { assert(!IsFull()); return &data[SizeRef()++]; }
 	/** add and construct item using default constructor */
-	inline T *AppendC() { T *item = Append(); new(item)T; return item; }
+	INLINE T *AppendC() { T *item = Append(); new(item)T; return item; }
 	/** return item by index (non-const version) */
-	inline T& operator [] (uint index) { assert(index < Length()); return data[index]; }
+	INLINE T& operator [] (uint index) { assert(index < Length()); return data[index]; }
 	/** return item by index (const version) */
-	inline const T& operator [] (uint index) const { assert(index < Length()); return data[index]; }
+	INLINE const T& operator [] (uint index) const { assert(index < Length()); return data[index]; }
 };
 
 #endif /* FIXEDSIZEARRAY_HPP */
diff --git a/src/misc/hashtable.hpp b/src/misc/hashtable.hpp
--- a/src/misc/hashtable.hpp
+++ b/src/misc/hashtable.hpp
@@ -21,13 +21,13 @@
 
 	Titem_ *m_pFirst;
 
-	inline CHashTableSlotT() : m_pFirst(NULL) {}
+	INLINE CHashTableSlotT() : m_pFirst(NULL) {}
 
 	/** hash table slot helper - clears the slot by simple forgetting its items */
-	inline void Clear() {m_pFirst = NULL;}
+	INLINE void Clear() {m_pFirst = NULL;}
 
 	/** hash table slot helper - linear search for item with given key through the given blob - const version */
-	inline const Titem_ *Find(const Key& key) const
+	INLINE const Titem_ *Find(const Key& key) const
 	{
 		for (const Titem_ *pItem = m_pFirst; pItem != NULL; pItem = pItem->GetHashNext()) {
 			if (pItem->GetKey() == key) {
@@ -39,7 +39,7 @@
 	}
 
 	/** hash table slot helper - linear search for item with given key through the given blob - non-const version */
-	inline Titem_ *Find(const Key& key)
+	INLINE Titem_ *Find(const Key& key)
 	{
 		for (Titem_ *pItem = m_pFirst; pItem != NULL; pItem = pItem->GetHashNext()) {
 			if (pItem->GetKey() == key) {
@@ -51,7 +51,7 @@
 	}
 
 	/** hash table slot helper - add new item to the slot */
-	inline void Attach(Titem_& new_item)
+	INLINE void Attach(Titem_& new_item)
 	{
 		assert(new_item.GetHashNext() == NULL);
 		new_item.SetHashNext(m_pFirst);
@@ -59,7 +59,7 @@
 	}
 
 	/** hash table slot helper - remove item from a slot */
-	inline bool Detach(Titem_& item_to_remove)
+	INLINE bool Detach(Titem_& item_to_remove)
 	{
 		if (m_pFirst == &item_to_remove) {
 			m_pFirst = item_to_remove.GetHashNext();
@@ -81,7 +81,7 @@
 	}
 
 	/** hash table slot helper - remove and return item from a slot */
-	inline Titem_ *Detach(const Key& key)
+	INLINE Titem_ *Detach(const Key& key)
 	{
 		/* do we have any items? */
 		if (m_pFirst == NULL) {
@@ -150,13 +150,13 @@
 
 public:
 	/* default constructor */
-	inline CHashTableT() : m_num_items(0)
+	INLINE CHashTableT() : m_num_items(0)
 	{
 	}
 
 protected:
 	/** static helper - return hash for the given key modulo number of slots */
-	inline static int CalcHash(const Tkey& key)
+	INLINE static int CalcHash(const Tkey& key)
 	{
 		int32 hash = key.CalcHash();
 		if ((8 * Thash_bits) < 32) hash ^= hash >> (min(8 * Thash_bits, 31));
@@ -168,14 +168,14 @@
 	}
 
 	/** static helper - return hash for the given item modulo number of slots */
-	inline static int CalcHash(const Titem_& item) {return CalcHash(item.GetKey());}
+	INLINE static int CalcHash(const Titem_& item) {return CalcHash(item.GetKey());}
 
 public:
 	/** item count */
-	inline int Count() const {return m_num_items;}
+	INLINE int Count() const {return m_num_items;}
 
 	/** simple clear - forget all items - used by CSegmentCostCacheT.Flush() */
-	inline void Clear() {for (int i = 0; i < Tcapacity; i++) m_slots[i].Clear();}
+	INLINE void Clear() {for (int i = 0; i < Tcapacity; i++) m_slots[i].Clear();}
 
 	/** const item search */
 	const Titem_ *Find(const Tkey& key) const
diff --git a/src/misc/str.hpp b/src/misc/str.hpp
--- a/src/misc/str.hpp
+++ b/src/misc/str.hpp
@@ -24,24 +24,24 @@
 	typedef CBlobT<char> base;                    ///< base class
 
 	/** Create an empty CStrT */
-	inline CStrA()
+	INLINE CStrA()
 	{
 	}
 
 	/** Copy constructor */
-	inline CStrA(const CStrA &src) : base(src)
+	INLINE CStrA(const CStrA &src) : base(src)
 	{
 		base::FixTail();
 	}
 
 	/** Take over ownership constructor */
-	inline CStrA(const OnTransfer& ot)
+	INLINE CStrA(const OnTransfer& ot)
 		: base(ot)
 	{
 	}
 
 	/** Grow the actual buffer and fix the trailing zero at the end. */
-	inline char *GrowSizeNC(uint count)
+	INLINE char *GrowSizeNC(uint count)
 	{
 		char *ret = base::GrowSizeNC(count);
 		base::FixTail();
@@ -49,7 +49,7 @@
 	}
 
 	/** Append zero-ended C string. */
-	inline void AppendStr(const char *str)
+	INLINE void AppendStr(const char *str)
 	{
 		if (!StrEmpty(str)) {
 			base::AppendRaw(str, strlen(str));
@@ -58,7 +58,7 @@
 	}
 
 	/** Append another CStrA. */
-	inline void Append(const CStrA &src)
+	INLINE void Append(const CStrA &src)
 	{
 		if (src.Length() > 0) {
 			base::AppendRaw(src);
@@ -67,7 +67,7 @@
 	}
 
 	/** Assignment from C string. */
-	inline CStrA &operator = (const char *src)
+	INLINE CStrA &operator = (const char *src)
 	{
 		base::Clear();
 		AppendStr(src);
@@ -75,7 +75,7 @@
 	}
 
 	/** Assignment from another CStrA. */
-	inline CStrA &operator = (const CStrA &src)
+	INLINE CStrA &operator = (const CStrA &src)
 	{
 		if (&src != this) {
 			base::Clear();
@@ -86,7 +86,7 @@
 	}
 
 	/** Lower-than operator (to support stl collections) */
-	inline bool operator < (const CStrA &other) const
+	INLINE bool operator < (const CStrA &other) const
 	{
 		return strcmp(base::Data(), other.Data()) < 0;
 	}
diff --git a/src/network/core/os_abstraction.h b/src/network/core/os_abstraction.h
--- a/src/network/core/os_abstraction.h
+++ b/src/network/core/os_abstraction.h
@@ -45,7 +45,7 @@
 #define AI_ADDRCONFIG   0x00000400  /* Resolution only if global address configured */
 #define IPV6_V6ONLY 27
 
-static inline int OTTDgetnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, DWORD hostlen, char *serv, DWORD servlen, int flags)
+static INLINE int OTTDgetnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, DWORD hostlen, char *serv, DWORD servlen, int flags)
 {
 	static int (WINAPI *getnameinfo)(const struct sockaddr *, socklen_t, char *, DWORD, char *, DWORD, int) = NULL;
 	static bool first_time = true;
@@ -62,7 +62,7 @@
 }
 #define getnameinfo OTTDgetnameinfo
 
-static inline int OTTDgetaddrinfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res)
+static INLINE int OTTDgetaddrinfo(const char *nodename, const char *servname, const struct addrinfo *hints, struct addrinfo **res)
 {
 	static int (WINAPI *getaddrinfo)(const char *, const char *, const struct addrinfo *, struct addrinfo **) = NULL;
 	static bool first_time = true;
@@ -99,7 +99,7 @@
 }
 #define getaddrinfo OTTDgetaddrinfo
 
-static inline void OTTDfreeaddrinfo(struct addrinfo *ai)
+static INLINE void OTTDfreeaddrinfo(struct addrinfo *ai)
 {
 	static int (WINAPI *freeaddrinfo)(struct addrinfo *) = NULL;
 	static bool first_time = true;
@@ -284,7 +284,7 @@
  * @param d The socket to set the non-blocking more for.
  * @return True if setting the non-blocking mode succeeded, otherwise false.
  */
-static inline bool SetNonBlocking(SOCKET d)
+static INLINE bool SetNonBlocking(SOCKET d)
 {
 #ifdef WIN32
 	u_long nonblocking = 1;
@@ -303,7 +303,7 @@
  * @param d The socket to disable the delaying for.
  * @return True if disabling the delaying succeeded, otherwise false.
  */
-static inline bool SetNoDelay(SOCKET d)
+static INLINE bool SetNoDelay(SOCKET d)
 {
 	/* XXX should this be done at all? */
 #if !defined(BEOS_NET_SERVER) /* not implemented on BeOS net_server */
diff --git a/src/network/core/tcp_game.h b/src/network/core/tcp_game.h
--- a/src/network/core/tcp_game.h
+++ b/src/network/core/tcp_game.h
@@ -537,7 +537,7 @@
 	 * Sets the client info for this socket handler.
 	 * @param info The new client info.
 	 */
-	inline void SetInfo(NetworkClientInfo *info)
+	INLINE void SetInfo(NetworkClientInfo *info)
 	{
 		assert(info != NULL && this->info == NULL);
 		this->info = info;
@@ -547,7 +547,7 @@
 	 * Gets the client info of this socket handler.
 	 * @return The client info.
 	 */
-	inline NetworkClientInfo *GetInfo() const
+	INLINE NetworkClientInfo *GetInfo() const
 	{
 		return this->info;
 	}
diff --git a/src/network/network.h b/src/network/network.h
--- a/src/network/network.h
+++ b/src/network/network.h
@@ -28,9 +28,9 @@
 #else /* ENABLE_NETWORK */
 /* Network function stubs when networking is disabled */
 
-static inline void NetworkStartUp() {}
-static inline void NetworkShutDown() {}
-static inline void NetworkDrawChatMessage() {}
+static INLINE void NetworkStartUp() {}
+static INLINE void NetworkShutDown() {}
+static INLINE void NetworkDrawChatMessage() {}
 
 #define _networking 0
 #define _network_server 0
diff --git a/src/network/network_chat_gui.cpp b/src/network/network_chat_gui.cpp
--- a/src/network/network_chat_gui.cpp
+++ b/src/network/network_chat_gui.cpp
@@ -62,7 +62,7 @@
  * Count the chat messages.
  * @return The number of chat messages.
  */
-static inline uint GetChatMessageCount()
+static INLINE uint GetChatMessageCount()
 {
 	uint i = 0;
 	for (; i < MAX_CHAT_MESSAGES; i++) {
diff --git a/src/network/network_content.h b/src/network/network_content.h
--- a/src/network/network_content.h
+++ b/src/network/network_content.h
@@ -154,7 +154,7 @@
 void ShowMissingContentWindow(const struct GRFConfig *list);
 
 #else
-static inline void ShowNetworkContentListWindow() {}
+static INLINE void ShowNetworkContentListWindow() {}
 #endif /* ENABLE_NETWORK */
 
 #endif /* NETWORK_CONTENT_H */
diff --git a/src/network/network_gui.cpp b/src/network/network_gui.cpp
--- a/src/network/network_gui.cpp
+++ b/src/network/network_gui.cpp
@@ -1685,7 +1685,7 @@
 	 * @param name the name of the action
 	 * @param proc the procedure to execute for the action
 	 */
-	inline void AddAction(StringID name, ClientList_Action_Proc *proc)
+	INLINE void AddAction(StringID name, ClientList_Action_Proc *proc)
 	{
 		ClientListAction *action = this->actions.Append();
 		action->name = name;
diff --git a/src/network/network_gui.h b/src/network/network_gui.h
--- a/src/network/network_gui.h
+++ b/src/network/network_gui.h
@@ -45,10 +45,10 @@
 #else /* ENABLE_NETWORK */
 /* Network function stubs when networking is disabled */
 
-static inline void ShowNetworkChatQueryWindow(byte desttype, int dest) {}
-static inline void ShowClientList() {}
-static inline void ShowNetworkGameWindow() {}
-static inline void ShowNetworkCompanyPasswordWindow(Window *parent) {}
+static INLINE void ShowNetworkChatQueryWindow(byte desttype, int dest) {}
+static INLINE void ShowClientList() {}
+static INLINE void ShowNetworkGameWindow() {}
+static INLINE void ShowNetworkCompanyPasswordWindow(Window *parent) {}
 
 #endif /* ENABLE_NETWORK */
 
diff --git a/src/network/network_server.h b/src/network/network_server.h
--- a/src/network/network_server.h
+++ b/src/network/network_server.h
@@ -143,8 +143,8 @@
 #else /* ENABLE_NETWORK */
 /* Network function stubs when networking is disabled */
 
-static inline void NetworkServerMonthlyLoop() {}
-static inline void NetworkServerYearlyLoop() {}
+static INLINE void NetworkServerMonthlyLoop() {}
+static INLINE void NetworkServerYearlyLoop() {}
 
 #endif /* ENABLE_NETWORK */
 
diff --git a/src/newgrf.cpp b/src/newgrf.cpp
--- a/src/newgrf.cpp
+++ b/src/newgrf.cpp
@@ -200,7 +200,7 @@
 public:
 	ByteReader(byte *data, byte *end) : data(data), end(end) { }
 
-	inline byte ReadByte()
+	INLINE byte ReadByte()
 	{
 		if (data < end) return *(data)++;
 		throw OTTDByteReaderSignal();
@@ -254,22 +254,22 @@
 		return string;
 	}
 
-	inline size_t Remaining() const
+	INLINE size_t Remaining() const
 	{
 		return end - data;
 	}
 
-	inline bool HasData(size_t count = 1) const
+	INLINE bool HasData(size_t count = 1) const
 	{
 		return data + count <= end;
 	}
 
-	inline byte *Data()
+	INLINE byte *Data()
 	{
 		return data;
 	}
 
-	inline void Skip(size_t len)
+	INLINE void Skip(size_t len)
 	{
 		data += len;
 		/* It is valid to move the buffer to exactly the end of the data,
@@ -7000,7 +7000,7 @@
 				/* Allocate sound only in init stage. */
 				if (_cur.stage == GLS_INIT) {
 					if (_cur.grf_container_ver >= 2) {
-						grfmsg(1, "GRFSound: Inline sounds are not supported for container version >= 2");
+						grfmsg(1, "GRFSound: INLINE sounds are not supported for container version >= 2");
 					} else {
 						LoadGRFSound(offs, sound + i);
 					}
diff --git a/src/newgrf.h b/src/newgrf.h
--- a/src/newgrf.h
+++ b/src/newgrf.h
@@ -171,7 +171,7 @@
  * @param bit The bit to check.
  * @return Whether the bit is set.
  */
-static inline bool HasGrfMiscBit(GrfMiscBit bit)
+static INLINE bool HasGrfMiscBit(GrfMiscBit bit)
 {
 	extern byte _misc_grf_features;
 	return HasBit(_misc_grf_features, bit);
diff --git a/src/newgrf_airport.h b/src/newgrf_airport.h
--- a/src/newgrf_airport.h
+++ b/src/newgrf_airport.h
@@ -43,7 +43,7 @@
 	{
 	}
 
-	inline TileIterator& operator ++()
+	INLINE TileIterator& operator ++()
 	{
 		this->att++;
 		if (this->att->ti.x == -0x80) {
diff --git a/src/newgrf_commons.h b/src/newgrf_commons.h
--- a/src/newgrf_commons.h
+++ b/src/newgrf_commons.h
@@ -74,7 +74,7 @@
  * @param num_sprites Number of available sprites to select stage from.
  * @return Sprite to use
  */
-static inline uint GetConstructionStageOffset(uint construction_stage, uint num_sprites)
+static INLINE uint GetConstructionStageOffset(uint construction_stage, uint num_sprites)
 {
 	assert(num_sprites > 0);
 	if (num_sprites > 4) num_sprites = 4;
@@ -218,8 +218,8 @@
 	uint16 GetSubstituteID(uint16 entity_id) const;
 	virtual uint16 GetID(uint8 grf_local_id, uint32 grfid) const;
 
-	inline uint16 GetMaxMapping() const { return max_new_entities; }
-	inline uint16 GetMaxOffset() const { return max_offset; }
+	INLINE uint16 GetMaxMapping() const { return max_new_entities; }
+	INLINE uint16 GetMaxOffset() const { return max_offset; }
 };
 
 
diff --git a/src/newgrf_config.h b/src/newgrf_config.h
--- a/src/newgrf_config.h
+++ b/src/newgrf_config.h
@@ -90,7 +90,7 @@
 	 * @param md5sum Expected md5sum, may be \c NULL (in which case, do not check it).
 	 * @return the object has the provided grfid and md5sum.
 	 */
-	inline bool HasGrfIdentifier(uint32 grfid, const uint8 *md5sum) const
+	INLINE bool HasGrfIdentifier(uint32 grfid, const uint8 *md5sum) const
 	{
 		if (this->grfid != grfid) return false;
 		if (md5sum == NULL) return true;
diff --git a/src/newgrf_debug_gui.cpp b/src/newgrf_debug_gui.cpp
--- a/src/newgrf_debug_gui.cpp
+++ b/src/newgrf_debug_gui.cpp
@@ -48,7 +48,7 @@
  * @param window_number The window to get the feature index from.
  * @return the feature index
  */
-static inline uint GetFeatureIndex(uint window_number)
+static INLINE uint GetFeatureIndex(uint window_number)
 {
 	return GB(window_number, 0, 24);
 }
@@ -60,7 +60,7 @@
  * @param index   The index/identifier of the feature to inspect.
  * @return the InspectWindow (Window)Number
  */
-static inline uint GetInspectWindowNumber(GrfSpecFeature feature, uint index)
+static INLINE uint GetInspectWindowNumber(GrfSpecFeature feature, uint index)
 {
 	assert((index >> 24) == 0);
 	return (feature << 24) | index;
@@ -238,7 +238,7 @@
  * @param window_number The window to get the feature number for.
  * @return The feature number.
  */
-static inline GrfSpecFeature GetFeatureNum(uint window_number)
+static INLINE GrfSpecFeature GetFeatureNum(uint window_number)
 {
 	return (GrfSpecFeature)GB(window_number, 24, 8);
 }
@@ -248,7 +248,7 @@
  * @param window_number The window to get the NIFeature for.
  * @return the NIFeature, or NULL is there isn't one.
  */
-static inline const NIFeature *GetFeature(uint window_number)
+static INLINE const NIFeature *GetFeature(uint window_number)
 {
 	GrfSpecFeature idx = GetFeatureNum(window_number);
 	return idx < GSF_FAKE_END ? _nifeatures[idx] : NULL;
@@ -260,7 +260,7 @@
  * @pre GetFeature(window_number) != NULL
  * @return the NIHelper
  */
-static inline const NIHelper *GetFeatureHelper(uint window_number)
+static INLINE const NIHelper *GetFeatureHelper(uint window_number)
 {
 	return GetFeature(window_number)->helper;
 }
diff --git a/src/newgrf_generic.h b/src/newgrf_generic.h
--- a/src/newgrf_generic.h
+++ b/src/newgrf_generic.h
@@ -52,7 +52,7 @@
 uint16 GetAiPurchaseCallbackResult(uint8 feature, CargoID cargo_type, uint8 default_selection, IndustryType src_industry, IndustryType dst_industry, uint8 distance, AIConstructionEvent event, uint8 count, uint8 station_size, const GRFFile **file);
 
 /** Play an ambient sound effect for an empty tile. */
-static inline void AmbientSoundEffect(TileIndex tile)
+static INLINE void AmbientSoundEffect(TileIndex tile)
 {
 	/* Only run callback if enabled. */
 	if (!HasGrfMiscBit(GMB_AMBIENT_SOUND_CALLBACK)) return;
diff --git a/src/newgrf_gui.cpp b/src/newgrf_gui.cpp
--- a/src/newgrf_gui.cpp
+++ b/src/newgrf_gui.cpp
@@ -743,7 +743,7 @@
 	 * @param c grf to display.
 	 * @return Palette for the sprite.
 	 */
-	inline PaletteID GetPalette(const GRFConfig *c) const
+	INLINE PaletteID GetPalette(const GRFConfig *c) const
 	{
 		PaletteID pal;
 
diff --git a/src/newgrf_spritegroup.cpp b/src/newgrf_spritegroup.cpp
--- a/src/newgrf_spritegroup.cpp
+++ b/src/newgrf_spritegroup.cpp
@@ -37,7 +37,7 @@
 TemporaryStorageArray<int32, 0x110> _temp_store;
 
 
-static inline uint32 GetVariable(const ResolverObject *object, ScopeResolver *scope, byte variable, uint32 parameter, bool *available)
+static INLINE uint32 GetVariable(const ResolverObject *object, ScopeResolver *scope, byte variable, uint32 parameter, bool *available)
 {
 	/* First handle variables common with Action7/9/D */
 	uint32 value;
diff --git a/src/newgrf_spritegroup.h b/src/newgrf_spritegroup.h
--- a/src/newgrf_spritegroup.h
+++ b/src/newgrf_spritegroup.h
@@ -27,7 +27,7 @@
  * @pre i < 0x110
  * @return the value of the register
  */
-static inline uint32 GetRegister(uint i)
+static INLINE uint32 GetRegister(uint i)
 {
 	extern TemporaryStorageArray<int32, 0x110> _temp_store;
 	return _temp_store.GetValue(i);
@@ -38,7 +38,7 @@
  * @param i index of the register
  * @pre i < 0x110
  */
-static inline void ClearRegister(uint i)
+static INLINE void ClearRegister(uint i)
 {
 	extern TemporaryStorageArray<int32, 0x110> _temp_store;
 	_temp_store.StoreValue(i, 0);
diff --git a/src/news_func.h b/src/news_func.h
--- a/src/news_func.h
+++ b/src/news_func.h
@@ -19,7 +19,7 @@
 
 void AddNewsItem(StringID string, NewsType type, NewsFlag flags, NewsReferenceType reftype1 = NR_NONE, uint32 ref1 = UINT32_MAX, NewsReferenceType reftype2 = NR_NONE, uint32 ref2 = UINT32_MAX, void *free_data = NULL);
 
-static inline void AddCompanyNewsItem(StringID string, CompanyNewsInformation *cni)
+static INLINE void AddCompanyNewsItem(StringID string, CompanyNewsInformation *cni)
 {
 	AddNewsItem(string, NT_COMPANY_INFO, NF_COMPANY, NR_NONE, UINT32_MAX, NR_NONE, UINT32_MAX, cni);
 }
@@ -29,7 +29,7 @@
  *
  * @warning The DParams may not reference the vehicle due to autoreplace stuff. See AddVehicleAdviceNewsItem for how that can be done.
  */
-static inline void AddVehicleNewsItem(StringID string, NewsType type, VehicleID vehicle, StationID station = INVALID_STATION)
+static INLINE void AddVehicleNewsItem(StringID string, NewsType type, VehicleID vehicle, StationID station = INVALID_STATION)
 {
 	AddNewsItem(string, type, NF_NO_TRANSPARENT | NF_SHADE | NF_THIN, NR_VEHICLE, vehicle, station == INVALID_STATION ? NR_NONE : NR_STATION, station);
 }
@@ -39,17 +39,17 @@
  *
  * @warning DParam 0 must reference the vehicle!
  */
-static inline void AddVehicleAdviceNewsItem(StringID string, VehicleID vehicle)
+static INLINE void AddVehicleAdviceNewsItem(StringID string, VehicleID vehicle)
 {
 	AddNewsItem(string, NT_ADVICE, NF_INCOLOUR | NF_SMALL | NF_VEHICLE_PARAM0, NR_VEHICLE, vehicle);
 }
 
-static inline void AddTileNewsItem(StringID string, NewsType type, TileIndex tile, void *free_data = NULL)
+static INLINE void AddTileNewsItem(StringID string, NewsType type, TileIndex tile, void *free_data = NULL)
 {
 	AddNewsItem(string, type, NF_NO_TRANSPARENT | NF_SHADE | NF_THIN, NR_TILE, tile, NR_NONE, UINT32_MAX, free_data);
 }
 
-static inline void AddIndustryNewsItem(StringID string, NewsType type, IndustryID industry)
+static INLINE void AddIndustryNewsItem(StringID string, NewsType type, IndustryID industry)
 {
 	AddNewsItem(string, type, NF_NO_TRANSPARENT | NF_SHADE | NF_THIN, NR_INDUSTRY, industry);
 }
diff --git a/src/object_base.h b/src/object_base.h
--- a/src/object_base.h
+++ b/src/object_base.h
@@ -41,7 +41,7 @@
 	 * @param type ObjectType to increment
 	 * @pre type < NUM_OBJECTS
 	 */
-	static inline void IncTypeCount(ObjectType type)
+	static INLINE void IncTypeCount(ObjectType type)
 	{
 		assert(type < NUM_OBJECTS);
 		counts[type]++;
@@ -52,7 +52,7 @@
 	 * @param type ObjectType to decrement
 	 * @pre type < NUM_OBJECTS
 	 */
-	static inline void DecTypeCount(ObjectType type)
+	static INLINE void DecTypeCount(ObjectType type)
 	{
 		assert(type < NUM_OBJECTS);
 		counts[type]--;
@@ -63,14 +63,14 @@
 	 * @param type ObjectType to query
 	 * @pre type < NUM_OBJECTS
 	 */
-	static inline uint16 GetTypeCount(ObjectType type)
+	static INLINE uint16 GetTypeCount(ObjectType type)
 	{
 		assert(type < NUM_OBJECTS);
 		return counts[type];
 	}
 
 	/** Resets object counts. */
-	static inline void ResetTypeCounts()
+	static INLINE void ResetTypeCounts()
 	{
 		memset(&counts, 0, sizeof(counts));
 	}
diff --git a/src/object_map.h b/src/object_map.h
--- a/src/object_map.h
+++ b/src/object_map.h
@@ -21,7 +21,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return the type.
  */
-static inline ObjectType GetObjectType(TileIndex t)
+static INLINE ObjectType GetObjectType(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return (ObjectType)_m[t].m5;
@@ -33,7 +33,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return The ObjectID of the object.
  */
-static inline ObjectID GetObjectIndex(TileIndex t)
+static INLINE ObjectID GetObjectIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return _m[t].m2;
@@ -44,7 +44,7 @@
  * @param t the tile to inspect.
  * @return true if and only if the tile has a transmitter.
  */
-static inline bool IsTransmitterTile(TileIndex t)
+static INLINE bool IsTransmitterTile(TileIndex t)
 {
 	return IsTileType(t, MP_OBJECT) && GetObjectType(t) == OBJECT_TRANSMITTER;
 }
@@ -55,7 +55,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return true if and only if the tile is an 'owned land' tile.
  */
-static inline bool IsOwnedLand(TileIndex t)
+static INLINE bool IsOwnedLand(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return GetObjectType(t) == OBJECT_OWNED_LAND;
@@ -66,7 +66,7 @@
  * @param t the tile to inspect.
  * @return true if and only if the tile is an 'owned land' tile.
  */
-static inline bool IsOwnedLandTile(TileIndex t)
+static INLINE bool IsOwnedLandTile(TileIndex t)
 {
 	return IsTileType(t, MP_OBJECT) && IsOwnedLand(t);
 }
@@ -77,7 +77,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return true if and only if the tile is a HQ tile.
  */
-static inline bool IsCompanyHQ(TileIndex t)
+static INLINE bool IsCompanyHQ(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return _m[t].m5 == OBJECT_HQ;
@@ -89,7 +89,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return true if and only if the tile is a statue.
  */
-static inline bool IsStatue(TileIndex t)
+static INLINE bool IsStatue(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return GetObjectType(t) == OBJECT_STATUE;
@@ -100,7 +100,7 @@
  * @param t the tile to inspect.
  * @return true if and only if the tile is a statue.
  */
-static inline bool IsStatueTile(TileIndex t)
+static INLINE bool IsStatueTile(TileIndex t)
 {
 	return IsTileType(t, MP_OBJECT) && IsStatue(t);
 }
@@ -111,7 +111,7 @@
  * @pre IsTileType(t, MP_OBJECT)
  * @return The random bits.
  */
-static inline byte GetObjectRandomBits(TileIndex t)
+static INLINE byte GetObjectRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_OBJECT));
 	return _m[t].m3;
@@ -128,7 +128,7 @@
  * @param wc     Water class for this obect.
  * @param random Random data to store on the tile
  */
-static inline void MakeObject(TileIndex t, ObjectType u, Owner o, ObjectID index, WaterClass wc, byte random)
+static INLINE void MakeObject(TileIndex t, ObjectType u, Owner o, ObjectID index, WaterClass wc, byte random)
 {
 	SetTileType(t, MP_OBJECT);
 	SetTileOwner(t, o);
diff --git a/src/order_base.h b/src/order_base.h
--- a/src/order_base.h
+++ b/src/order_base.h
@@ -61,13 +61,13 @@
 	 * @param type the type to check against.
 	 * @return true if the order matches.
 	 */
-	inline bool IsType(OrderType type) const { return this->GetType() == type; }
+	INLINE bool IsType(OrderType type) const { return this->GetType() == type; }
 
 	/**
 	 * Get the type of order of this order.
 	 * @return the order type.
 	 */
-	inline OrderType GetType() const { return (OrderType)GB(this->type, 0, 4); }
+	INLINE OrderType GetType() const { return (OrderType)GB(this->type, 0, 4); }
 
 	void Free();
 
@@ -84,7 +84,7 @@
 	 * Is this a 'goto' order with a real destination?
 	 * @return True if the type is either #OT_GOTO_WAYPOINT, #OT_GOTO_DEPOT or #OT_GOTO_STATION.
 	 */
-	inline bool IsGotoOrder() const
+	INLINE bool IsGotoOrder() const
 	{
 		return IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION);
 	}
@@ -94,92 +94,92 @@
 	 * @pre IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION).
 	 * @return the destination of the order.
 	 */
-	inline DestinationID GetDestination() const { return this->dest; }
+	INLINE DestinationID GetDestination() const { return this->dest; }
 
 	/**
 	 * Sets the destination of this order.
 	 * @param destination the new destination of the order.
 	 * @pre IsType(OT_GOTO_WAYPOINT) || IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION).
 	 */
-	inline void SetDestination(DestinationID destination) { this->dest = destination; }
+	INLINE void SetDestination(DestinationID destination) { this->dest = destination; }
 
 	/**
 	 * Is this order a refit order.
 	 * @pre IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION)
 	 * @return true if a refit should happen.
 	 */
-	inline bool IsRefit() const { return this->refit_cargo < NUM_CARGO || this->refit_cargo == CT_AUTO_REFIT; }
+	INLINE bool IsRefit() const { return this->refit_cargo < NUM_CARGO || this->refit_cargo == CT_AUTO_REFIT; }
 
 	/**
 	 * Is this order a auto-refit order.
 	 * @pre IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION)
 	 * @return true if a auto-refit should happen.
 	 */
-	inline bool IsAutoRefit() const { return this->refit_cargo == CT_AUTO_REFIT; }
+	INLINE bool IsAutoRefit() const { return this->refit_cargo == CT_AUTO_REFIT; }
 
 	/**
 	 * Get the cargo to to refit to.
 	 * @pre IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION)
 	 * @return the cargo type.
 	 */
-	inline CargoID GetRefitCargo() const { return this->refit_cargo; }
+	INLINE CargoID GetRefitCargo() const { return this->refit_cargo; }
 
 	/**
 	 * Get the cargo subtype to to refit to.
 	 * @pre IsType(OT_GOTO_DEPOT) || IsType(OT_GOTO_STATION)
 	 * @return the cargo subtype.
 	 */
-	inline byte GetRefitSubtype() const { return this->refit_subtype; }
+	INLINE byte GetRefitSubtype() const { return this->refit_subtype; }
 
 	void SetRefit(CargoID cargo, byte subtype = 0);
 
 	/** How must the consist be loaded? */
-	inline OrderLoadFlags GetLoadType() const { return (OrderLoadFlags)GB(this->flags, 4, 4); }
+	INLINE OrderLoadFlags GetLoadType() const { return (OrderLoadFlags)GB(this->flags, 4, 4); }
 	/** How must the consist be unloaded? */
-	inline OrderUnloadFlags GetUnloadType() const { return (OrderUnloadFlags)GB(this->flags, 0, 4); }
+	INLINE OrderUnloadFlags GetUnloadType() const { return (OrderUnloadFlags)GB(this->flags, 0, 4); }
 	/** At which stations must we stop? */
-	inline OrderNonStopFlags GetNonStopType() const { return (OrderNonStopFlags)GB(this->type, 6, 2); }
+	INLINE OrderNonStopFlags GetNonStopType() const { return (OrderNonStopFlags)GB(this->type, 6, 2); }
 	/** Where must we stop at the platform? */
-	inline OrderStopLocation GetStopLocation() const { return (OrderStopLocation)GB(this->type, 4, 2); }
+	INLINE OrderStopLocation GetStopLocation() const { return (OrderStopLocation)GB(this->type, 4, 2); }
 	/** What caused us going to the depot? */
-	inline OrderDepotTypeFlags GetDepotOrderType() const { return (OrderDepotTypeFlags)GB(this->flags, 0, 4); }
+	INLINE OrderDepotTypeFlags GetDepotOrderType() const { return (OrderDepotTypeFlags)GB(this->flags, 0, 4); }
 	/** What are we going to do when in the depot. */
-	inline OrderDepotActionFlags GetDepotActionType() const { return (OrderDepotActionFlags)GB(this->flags, 4, 4); }
+	INLINE OrderDepotActionFlags GetDepotActionType() const { return (OrderDepotActionFlags)GB(this->flags, 4, 4); }
 	/** What variable do we have to compare? */
-	inline OrderConditionVariable GetConditionVariable() const { return (OrderConditionVariable)GB(this->dest, 11, 5); }
+	INLINE OrderConditionVariable GetConditionVariable() const { return (OrderConditionVariable)GB(this->dest, 11, 5); }
 	/** What is the comparator to use? */
-	inline OrderConditionComparator GetConditionComparator() const { return (OrderConditionComparator)GB(this->type, 5, 3); }
+	INLINE OrderConditionComparator GetConditionComparator() const { return (OrderConditionComparator)GB(this->type, 5, 3); }
 	/** Get the order to skip to. */
-	inline VehicleOrderID GetConditionSkipToOrder() const { return this->flags; }
+	INLINE VehicleOrderID GetConditionSkipToOrder() const { return this->flags; }
 	/** Get the value to base the skip on. */
-	inline uint16 GetConditionValue() const { return GB(this->dest, 0, 11); }
+	INLINE uint16 GetConditionValue() const { return GB(this->dest, 0, 11); }
 
 	/** Set how the consist must be loaded. */
-	inline void SetLoadType(OrderLoadFlags load_type) { SB(this->flags, 4, 4, load_type); }
+	INLINE void SetLoadType(OrderLoadFlags load_type) { SB(this->flags, 4, 4, load_type); }
 	/** Set how the consist must be unloaded. */
-	inline void SetUnloadType(OrderUnloadFlags unload_type) { SB(this->flags, 0, 4, unload_type); }
+	INLINE void SetUnloadType(OrderUnloadFlags unload_type) { SB(this->flags, 0, 4, unload_type); }
 	/** Set whether we must stop at stations or not. */
-	inline void SetNonStopType(OrderNonStopFlags non_stop_type) { SB(this->type, 6, 2, non_stop_type); }
+	INLINE void SetNonStopType(OrderNonStopFlags non_stop_type) { SB(this->type, 6, 2, non_stop_type); }
 	/** Set where we must stop at the platform. */
-	inline void SetStopLocation(OrderStopLocation stop_location) { SB(this->type, 4, 2, stop_location); }
+	INLINE void SetStopLocation(OrderStopLocation stop_location) { SB(this->type, 4, 2, stop_location); }
 	/** Set the cause to go to the depot. */
-	inline void SetDepotOrderType(OrderDepotTypeFlags depot_order_type) { SB(this->flags, 0, 4, depot_order_type); }
+	INLINE void SetDepotOrderType(OrderDepotTypeFlags depot_order_type) { SB(this->flags, 0, 4, depot_order_type); }
 	/** Set what we are going to do in the depot. */
-	inline void SetDepotActionType(OrderDepotActionFlags depot_service_type) { SB(this->flags, 4, 4, depot_service_type); }
+	INLINE void SetDepotActionType(OrderDepotActionFlags depot_service_type) { SB(this->flags, 4, 4, depot_service_type); }
 	/** Set variable we have to compare. */
-	inline void SetConditionVariable(OrderConditionVariable condition_variable) { SB(this->dest, 11, 5, condition_variable); }
+	INLINE void SetConditionVariable(OrderConditionVariable condition_variable) { SB(this->dest, 11, 5, condition_variable); }
 	/** Set the comparator to use. */
-	inline void SetConditionComparator(OrderConditionComparator condition_comparator) { SB(this->type, 5, 3, condition_comparator); }
+	INLINE void SetConditionComparator(OrderConditionComparator condition_comparator) { SB(this->type, 5, 3, condition_comparator); }
 	/** Get the order to skip to. */
-	inline void SetConditionSkipToOrder(VehicleOrderID order_id) { this->flags = order_id; }
+	INLINE void SetConditionSkipToOrder(VehicleOrderID order_id) { this->flags = order_id; }
 	/** Set the value to base the skip on. */
-	inline void SetConditionValue(uint16 value) { SB(this->dest, 0, 11, value); }
+	INLINE void SetConditionValue(uint16 value) { SB(this->dest, 0, 11, value); }
 
 	bool ShouldStopAtStation(const Vehicle *v, StationID station) const;
 	TileIndex GetLocation(const Vehicle *v, bool airport = false) const;
 
 	/** Checks if this order has travel_time and if needed wait_time set. */
-	inline bool IsCompletelyTimetabled() const
+	INLINE bool IsCompletelyTimetabled() const
 	{
 		if (this->travel_time == 0 && !this->IsType(OT_CONDITIONAL)) return false;
 		if (this->wait_time == 0 && this->IsType(OT_GOTO_STATION) && !(this->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION)) return false;
@@ -236,7 +236,7 @@
 	 * Get the first order of the order chain.
 	 * @return the first order of the chain.
 	 */
-	inline Order *GetFirstOrder() const { return this->first; }
+	INLINE Order *GetFirstOrder() const { return this->first; }
 
 	Order *GetOrderAt(int index) const;
 
@@ -244,19 +244,19 @@
 	 * Get the last order of the order chain.
 	 * @return the last order of the chain.
 	 */
-	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
+	INLINE Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
 	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
 	 */
-	inline VehicleOrderID GetNumOrders() const { return this->num_orders; }
+	INLINE VehicleOrderID GetNumOrders() const { return this->num_orders; }
 
 	/**
 	 * Get number of manually added orders in the order list.
 	 * @return number of manual orders in the chain.
 	 */
-	inline VehicleOrderID GetNumManualOrders() const { return this->num_manual_orders; }
+	INLINE VehicleOrderID GetNumManualOrders() const { return this->num_manual_orders; }
 
 	void InsertOrderAt(Order *new_order, int index);
 	void DeleteOrderAt(int index);
@@ -266,19 +266,19 @@
 	 * Is this a shared order list?
 	 * @return whether this order list is shared among multiple vehicles
 	 */
-	inline bool IsShared() const { return this->num_vehicles > 1; };
+	INLINE bool IsShared() const { return this->num_vehicles > 1; };
 
 	/**
 	 * Get the first vehicle of this vehicle chain.
 	 * @return the first vehicle of the chain.
 	 */
-	inline Vehicle *GetFirstSharedVehicle() const { return this->first_shared; }
+	INLINE Vehicle *GetFirstSharedVehicle() const { return this->first_shared; }
 
 	/**
 	 * Return the number of vehicles that share this orders list
 	 * @return the count of vehicles that use this shared orders list
 	 */
-	inline uint GetNumVehicles() const { return this->num_vehicles; }
+	INLINE uint GetNumVehicles() const { return this->num_vehicles; }
 
 	bool IsVehicleInSharedOrdersList(const Vehicle *v) const;
 	int GetPositionInSharedOrderList(const Vehicle *v) const;
@@ -289,7 +289,7 @@
 	 *       into the shared vehicle chain.
 	 * @param v vehicle to add to the list
 	 */
-	inline void AddVehicle(Vehicle *v) { ++this->num_vehicles; }
+	INLINE void AddVehicle(Vehicle *v) { ++this->num_vehicles; }
 
 	void RemoveVehicle(Vehicle *v);
 
@@ -299,13 +299,13 @@
 	 * Gets the total duration of the vehicles timetable or INVALID_TICKS is the timetable is not complete.
 	 * @return total timetable duration or INVALID_TICKS for incomplete timetables
 	 */
-	inline Ticks GetTimetableTotalDuration() const { return this->IsCompleteTimetable() ? this->timetable_duration : INVALID_TICKS; }
+	INLINE Ticks GetTimetableTotalDuration() const { return this->IsCompleteTimetable() ? this->timetable_duration : INVALID_TICKS; }
 
 	/**
 	 * Gets the known duration of the vehicles timetable even if the timetable is not complete.
 	 * @return known timetable duration
 	 */
-	inline Ticks GetTimetableDurationIncomplete() const { return this->timetable_duration; }
+	INLINE Ticks GetTimetableDurationIncomplete() const { return this->timetable_duration; }
 
 	/**
 	 * Must be called if an order's timetable is changed to update internal book keeping.
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -536,7 +536,7 @@
  * @param o the order to check
  * @return true if the destination is a station
  */
-static inline bool OrderGoesToStation(const Vehicle *v, const Order *o)
+static INLINE bool OrderGoesToStation(const Vehicle *v, const Order *o)
 {
 	return o->IsType(OT_GOTO_STATION) ||
 			(v->type == VEH_AIRCRAFT && o->IsType(OT_GOTO_DEPOT) && !(o->GetDepotActionType() & ODATFB_NEAREST_DEPOT));
diff --git a/src/os/windows/crashlog_win.cpp b/src/os/windows/crashlog_win.cpp
--- a/src/os/windows/crashlog_win.cpp
+++ b/src/os/windows/crashlog_win.cpp
@@ -488,7 +488,7 @@
 
 /**
  * Stack pointer for use when 'starting' the crash handler.
- * Not static as gcc's inline assembly needs it that way.
+ * Not static as gcc's INLINE assembly needs it that way.
  */
 void *_safe_esp = NULL;
 
diff --git a/src/os/windows/win32.cpp b/src/os/windows/win32.cpp
--- a/src/os/windows/win32.cpp
+++ b/src/os/windows/win32.cpp
@@ -110,7 +110,7 @@
 static DIR _global_dir;
 static LONG _global_dir_is_in_use = false;
 
-static inline DIR *dir_calloc()
+static INLINE DIR *dir_calloc()
 {
 	DIR *d;
 
@@ -123,7 +123,7 @@
 	return d;
 }
 
-static inline void dir_free(DIR *d)
+static INLINE void dir_free(DIR *d)
 {
 	if (d == &_global_dir) {
 		_global_dir_is_in_use = (LONG)false;
diff --git a/src/os_timer.cpp b/src/os_timer.cpp
--- a/src/os_timer.cpp
+++ b/src/os_timer.cpp
@@ -13,8 +13,8 @@
 
 #undef RDTSC_AVAILABLE
 
-/* rdtsc for MSC_VER, uses simple inline assembly, or _rdtsc
- * from external win64.asm because VS2005 does not support inline assembly */
+/* rdtsc for MSC_VER, uses simple INLINE assembly, or _rdtsc
+ * from external win64.asm because VS2005 does not support INLINE assembly */
 #if defined(_MSC_VER) && !defined(RDTSC_AVAILABLE) && !defined(WINCE)
 #include <intrin.h>
 uint64 ottd_rdtsc()
diff --git a/src/pathfinder/follow_track.hpp b/src/pathfinder/follow_track.hpp
--- a/src/pathfinder/follow_track.hpp
+++ b/src/pathfinder/follow_track.hpp
@@ -53,25 +53,25 @@
 	CPerformanceTimer  *m_pPerf;
 	RailTypes           m_railtypes;
 
-	inline CFollowTrackT(const VehicleType *v = NULL, RailTypes railtype_override = INVALID_RAILTYPES, CPerformanceTimer *pPerf = NULL)
+	INLINE CFollowTrackT(const VehicleType *v = NULL, RailTypes railtype_override = INVALID_RAILTYPES, CPerformanceTimer *pPerf = NULL)
 	{
 		Init(v, railtype_override, pPerf);
 	}
 
-	inline CFollowTrackT(Owner o, RailTypes railtype_override = INVALID_RAILTYPES, CPerformanceTimer *pPerf = NULL)
+	INLINE CFollowTrackT(Owner o, RailTypes railtype_override = INVALID_RAILTYPES, CPerformanceTimer *pPerf = NULL)
 	{
 		m_veh = NULL;
 		Init(o, railtype_override, pPerf);
 	}
 
-	inline void Init(const VehicleType *v, RailTypes railtype_override, CPerformanceTimer *pPerf)
+	INLINE void Init(const VehicleType *v, RailTypes railtype_override, CPerformanceTimer *pPerf)
 	{
 		assert(!IsRailTT() || (v != NULL && v->type == VEH_TRAIN));
 		m_veh = v;
 		Init(v != NULL ? v->owner : INVALID_OWNER, IsRailTT() && railtype_override == INVALID_RAILTYPES ? Train::From(v)->compatible_railtypes : railtype_override, pPerf);
 	}
 
-	inline void Init(Owner o, RailTypes railtype_override, CPerformanceTimer *pPerf)
+	INLINE void Init(Owner o, RailTypes railtype_override, CPerformanceTimer *pPerf)
 	{
 		assert((!IsRoadTT() || m_veh != NULL) && (!IsRailTT() || railtype_override != INVALID_RAILTYPES));
 		m_veh_owner = o;
@@ -86,16 +86,16 @@
 		m_railtypes = railtype_override;
 	}
 
-	inline static TransportType TT() { return Ttr_type_; }
-	inline static bool IsWaterTT() { return TT() == TRANSPORT_WATER; }
-	inline static bool IsRailTT() { return TT() == TRANSPORT_RAIL; }
-	inline bool IsTram() { return IsRoadTT() && HasBit(RoadVehicle::From(m_veh)->compatible_roadtypes, ROADTYPE_TRAM); }
-	inline static bool IsRoadTT() { return TT() == TRANSPORT_ROAD; }
-	inline static bool Allow90degTurns() { return T90deg_turns_allowed_; }
-	inline static bool DoTrackMasking() { return Tmask_reserved_tracks; }
+	INLINE static TransportType TT() { return Ttr_type_; }
+	INLINE static bool IsWaterTT() { return TT() == TRANSPORT_WATER; }
+	INLINE static bool IsRailTT() { return TT() == TRANSPORT_RAIL; }
+	INLINE bool IsTram() { return IsRoadTT() && HasBit(RoadVehicle::From(m_veh)->compatible_roadtypes, ROADTYPE_TRAM); }
+	INLINE static bool IsRoadTT() { return TT() == TRANSPORT_ROAD; }
+	INLINE static bool Allow90degTurns() { return T90deg_turns_allowed_; }
+	INLINE static bool DoTrackMasking() { return Tmask_reserved_tracks; }
 
 	/** Tests if a tile is a road tile with a single tramtrack (tram can reverse) */
-	inline DiagDirection GetSingleTramBit(TileIndex tile)
+	INLINE DiagDirection GetSingleTramBit(TileIndex tile)
 	{
 		assert(IsTram()); // this function shouldn't be called in other cases
 
@@ -116,7 +116,7 @@
 	 * main follower routine. Fills all members and return true on success.
 	 *  Otherwise returns false if track can't be followed.
 	 */
-	inline bool Follow(TileIndex old_tile, Trackdir old_td)
+	INLINE bool Follow(TileIndex old_tile, Trackdir old_td)
 	{
 		m_old_tile = old_tile;
 		m_old_td = old_td;
@@ -156,7 +156,7 @@
 		return true;
 	}
 
-	inline bool MaskReservedTracks()
+	INLINE bool MaskReservedTracks()
 	{
 		if (!DoTrackMasking()) return true;
 
@@ -189,7 +189,7 @@
 
 protected:
 	/** Follow the m_exitdir from m_old_tile and fill m_new_tile and m_tiles_skipped */
-	inline void FollowTileExit()
+	INLINE void FollowTileExit()
 	{
 		m_is_station = m_is_bridge = m_is_tunnel = false;
 		m_tiles_skipped = 0;
@@ -227,7 +227,7 @@
 	}
 
 	/** stores track status (available trackdirs) for the new tile into m_new_td_bits */
-	inline bool QueryNewTileTrackStatus()
+	INLINE bool QueryNewTileTrackStatus()
 	{
 		CPerfStart perf(*m_pPerf);
 		if (IsRailTT() && IsPlainRailTile(m_new_tile)) {
@@ -257,7 +257,7 @@
 	}
 
 	/** return true if we can leave m_old_tile in m_exitdir */
-	inline bool CanExitOldTile()
+	INLINE bool CanExitOldTile()
 	{
 		/* road stop can be left at one direction only unless it's a drive-through stop */
 		if (IsRoadTT() && IsStandardRoadStopTile(m_old_tile)) {
@@ -289,7 +289,7 @@
 	}
 
 	/** return true if we can enter m_new_tile from m_exitdir */
-	inline bool CanEnterNewTile()
+	INLINE bool CanEnterNewTile()
 	{
 		if (IsRoadTT() && IsStandardRoadStopTile(m_new_tile)) {
 			/* road stop can be entered from one direction only unless it's a drive-through stop */
@@ -386,7 +386,7 @@
 	}
 
 	/** return true if we must reverse (in depots and single tram bits) */
-	inline bool ForcedReverse()
+	INLINE bool ForcedReverse()
 	{
 		/* rail and road depots cause reversing */
 		if (!IsWaterTT() && IsDepotTypeTile(m_old_tile, TT())) {
@@ -417,7 +417,7 @@
 	}
 
 	/** return true if we successfully reversed at end of road/track */
-	inline bool TryReverse()
+	INLINE bool TryReverse()
 	{
 		if (IsRoadTT() && !IsTram()) {
 			/* if we reached the end of road, we can reverse the RV and continue moving */
diff --git a/src/pathfinder/npf/npf.cpp b/src/pathfinder/npf/npf.cpp
--- a/src/pathfinder/npf/npf.cpp
+++ b/src/pathfinder/npf/npf.cpp
@@ -86,7 +86,7 @@
 /**
  * Returns the current value of the given flag on the given AyStarNode.
  */
-static inline bool NPFGetFlag(const AyStarNode *node, NPFNodeFlag flag)
+static INLINE bool NPFGetFlag(const AyStarNode *node, NPFNodeFlag flag)
 {
 	return HasBit(node->user_data[NPF_NODE_FLAGS], flag);
 }
@@ -94,7 +94,7 @@
 /**
  * Sets the given flag on the given AyStarNode to the given value.
  */
-static inline void NPFSetFlag(AyStarNode *node, NPFNodeFlag flag, bool value)
+static INLINE void NPFSetFlag(AyStarNode *node, NPFNodeFlag flag, bool value)
 {
 	SB(node->user_data[NPF_NODE_FLAGS], flag, 1, value);
 }
@@ -215,7 +215,7 @@
 	}
 }
 
-static inline uint NPFBridgeCost(AyStarNode *current)
+static INLINE uint NPFBridgeCost(AyStarNode *current)
 {
 	return NPF_TILE_LENGTH * GetTunnelBridgeLength(current->tile, GetOtherBridgeEnd(current->tile));
 }
@@ -754,7 +754,7 @@
  * @param subtype For TRANSPORT_ROAD the compatible RoadTypes of the vehicle.
  * @return true iff the vehicle must reverse on the tile.
  */
-static inline bool ForceReverse(TileIndex tile, DiagDirection dir, TransportType type, uint subtype)
+static INLINE bool ForceReverse(TileIndex tile, DiagDirection dir, TransportType type, uint subtype)
 {
 	DiagDirection single_entry = GetTileSingleEntry(tile, type, subtype);
 	return single_entry != INVALID_DIAGDIR && single_entry != dir;
diff --git a/src/pathfinder/npf/queue.h b/src/pathfinder/npf/queue.h
--- a/src/pathfinder/npf/queue.h
+++ b/src/pathfinder/npf/queue.h
@@ -43,7 +43,7 @@
 	 * @param i Element to access (starts at offset \c 1).
 	 * @return Value of the element.
 	 */
-	inline BinaryHeapNode &GetElement(uint i)
+	INLINE BinaryHeapNode &GetElement(uint i)
 	{
 		assert(i > 0);
 		return this->elements[(i - 1) >> BINARY_HEAP_BLOCKSIZE_BITS][(i - 1) & BINARY_HEAP_BLOCKSIZE_MASK];
@@ -96,7 +96,7 @@
 	/**
 	 * Gets the current size of the hash.
 	 */
-	inline uint GetSize() const
+	INLINE uint GetSize() const
 	{
 		return this->size;
 	}
diff --git a/src/pathfinder/pathfinder_func.h b/src/pathfinder/pathfinder_func.h
--- a/src/pathfinder/pathfinder_func.h
+++ b/src/pathfinder/pathfinder_func.h
@@ -23,7 +23,7 @@
  * @param station_type the station type to get the closest tile of
  * @return The closest station tile to the given tile.
  */
-static inline TileIndex CalcClosestStationTile(StationID station, TileIndex tile, StationType station_type)
+static INLINE TileIndex CalcClosestStationTile(StationID station, TileIndex tile, StationType station_type)
 {
 	const BaseStation *st = BaseStation::Get(station);
 	TileArea ta;
diff --git a/src/pathfinder/pf_performance_timer.hpp b/src/pathfinder/pf_performance_timer.hpp
--- a/src/pathfinder/pf_performance_timer.hpp
+++ b/src/pathfinder/pf_performance_timer.hpp
@@ -21,27 +21,27 @@
 
 	CPerformanceTimer() : m_start(0), m_acc(0) {}
 
-	inline void Start()
+	INLINE void Start()
 	{
 		m_start = QueryTime();
 	}
 
-	inline void Stop()
+	INLINE void Stop()
 	{
 		m_acc += QueryTime() - m_start;
 	}
 
-	inline int Get(int64 coef)
+	INLINE int Get(int64 coef)
 	{
 		return (int)(m_acc * coef / QueryFrequency());
 	}
 
-	inline int64 QueryTime()
+	INLINE int64 QueryTime()
 	{
 		return ottd_rdtsc();
 	}
 
-	inline int64 QueryFrequency()
+	INLINE int64 QueryFrequency()
 	{
 		return ((int64)2200 * 1000000);
 	}
@@ -51,17 +51,17 @@
 {
 	CPerformanceTimer *m_pperf;
 
-	inline CPerfStartReal(CPerformanceTimer& perf) : m_pperf(&perf)
+	INLINE CPerfStartReal(CPerformanceTimer& perf) : m_pperf(&perf)
 	{
 		if (m_pperf != NULL) m_pperf->Start();
 	}
 
-	inline ~CPerfStartReal()
+	INLINE ~CPerfStartReal()
 	{
 		Stop();
 	}
 
-	inline void Stop()
+	INLINE void Stop()
 	{
 		if (m_pperf != NULL) {
 			m_pperf->Stop();
@@ -72,9 +72,9 @@
 
 struct CPerfStartFake
 {
-	inline CPerfStartFake(CPerformanceTimer& perf) {}
-	inline ~CPerfStartFake() {}
-	inline void Stop() {}
+	INLINE CPerfStartFake(CPerformanceTimer& perf) {}
+	INLINE ~CPerfStartFake() {}
+	INLINE void Stop() {}
 };
 
 typedef CPerfStartFake CPerfStart;
diff --git a/src/pathfinder/yapf/nodelist.hpp b/src/pathfinder/yapf/nodelist.hpp
--- a/src/pathfinder/yapf/nodelist.hpp
+++ b/src/pathfinder/yapf/nodelist.hpp
@@ -62,26 +62,26 @@
 	}
 
 	/** return number of open nodes */
-	inline int OpenCount()
+	INLINE int OpenCount()
 	{
 		return m_open.Count();
 	}
 
 	/** return number of closed nodes */
-	inline int ClosedCount()
+	INLINE int ClosedCount()
 	{
 		return m_closed.Count();
 	}
 
 	/** allocate new data item from m_arr */
-	inline Titem_ *CreateNewNode()
+	INLINE Titem_ *CreateNewNode()
 	{
 		if (m_new_node == NULL) m_new_node = m_arr.AppendC();
 		return m_new_node;
 	}
 
 	/** Notify the nodelist that we don't want to discard the given node. */
-	inline void FoundBestNode(Titem_& item)
+	INLINE void FoundBestNode(Titem_& item)
 	{
 		/* for now it is enough to invalidate m_new_node if it is our given node */
 		if (&item == m_new_node) {
@@ -91,7 +91,7 @@
 	}
 
 	/** insert given item as open node (into m_open and m_open_queue) */
-	inline void InsertOpenNode(Titem_& item)
+	INLINE void InsertOpenNode(Titem_& item)
 	{
 		assert(m_closed.Find(item.GetKey()) == NULL);
 		m_open.Push(item);
@@ -102,7 +102,7 @@
 	}
 
 	/** return the best open node */
-	inline Titem_ *GetBestOpenNode()
+	INLINE Titem_ *GetBestOpenNode()
 	{
 		if (!m_open_queue.IsEmpty()) {
 			return m_open_queue.Begin();
@@ -111,7 +111,7 @@
 	}
 
 	/** remove and return the best open node */
-	inline Titem_ *PopBestOpenNode()
+	INLINE Titem_ *PopBestOpenNode()
 	{
 		if (!m_open_queue.IsEmpty()) {
 			Titem_ *item = m_open_queue.Shift();
@@ -122,14 +122,14 @@
 	}
 
 	/** return the open node specified by a key or NULL if not found */
-	inline Titem_ *FindOpenNode(const Key& key)
+	INLINE Titem_ *FindOpenNode(const Key& key)
 	{
 		Titem_ *item = m_open.Find(key);
 		return item;
 	}
 
 	/** remove and return the open node specified by a key */
-	inline Titem_& PopOpenNode(const Key& key)
+	INLINE Titem_& PopOpenNode(const Key& key)
 	{
 		Titem_& item = m_open.Pop(key);
 		uint idxPop = m_open_queue.FindIndex(item);
@@ -138,23 +138,23 @@
 	}
 
 	/** close node */
-	inline void InsertClosedNode(Titem_& item)
+	INLINE void InsertClosedNode(Titem_& item)
 	{
 		assert(m_open.Find(item.GetKey()) == NULL);
 		m_closed.Push(item);
 	}
 
 	/** return the closed node specified by a key or NULL if not found */
-	inline Titem_ *FindClosedNode(const Key& key)
+	INLINE Titem_ *FindClosedNode(const Key& key)
 	{
 		Titem_ *item = m_closed.Find(key);
 		return item;
 	}
 
 	/** The number of items. */
-	inline int TotalCount() {return m_arr.Length();}
+	INLINE int TotalCount() {return m_arr.Length();}
 	/** Get a particular item. */
-	inline Titem_& ItemAt(int idx) {return m_arr[idx];}
+	INLINE Titem_& ItemAt(int idx) {return m_arr[idx];}
 
 	/** Helper for creating output of this array. */
 	template <class D> void Dump(D &dmp) const
diff --git a/src/pathfinder/yapf/yapf.hpp b/src/pathfinder/yapf/yapf.hpp
--- a/src/pathfinder/yapf/yapf.hpp
+++ b/src/pathfinder/yapf/yapf.hpp
@@ -18,7 +18,7 @@
 #include "yapf.h"
 
 //#undef FORCEINLINE
-//#define inline inline
+//#define INLINE inline
 
 #include "../../misc/blob.hpp"
 #include "../../misc/str.hpp"
diff --git a/src/pathfinder/yapf/yapf_base.hpp b/src/pathfinder/yapf/yapf_base.hpp
--- a/src/pathfinder/yapf/yapf_base.hpp
+++ b/src/pathfinder/yapf/yapf_base.hpp
@@ -37,11 +37,11 @@
  *  Requrements to your pathfinder class derived from CYapfBaseT:
  *  -------------------------------------------------------------
  *  Your pathfinder derived class needs to implement following methods:
- *    inline void PfSetStartupNodes()
- *    inline void PfFollowNode(Node& org)
- *    inline bool PfCalcCost(Node& n)
- *    inline bool PfCalcEstimate(Node& n)
- *    inline bool PfDetectDestination(Node& n)
+ *    INLINE void PfSetStartupNodes()
+ *    INLINE void PfFollowNode(Node& org)
+ *    INLINE bool PfCalcCost(Node& n)
+ *    INLINE bool PfCalcEstimate(Node& n)
+ *    INLINE bool PfDetectDestination(Node& n)
  *
  *  For more details about those methods, look at the end of CYapfBaseT
  *  declaration. There are some examples. For another example look at
@@ -80,7 +80,7 @@
 
 public:
 	/** default constructor */
-	inline CYapfBaseT()
+	INLINE CYapfBaseT()
 		: m_pBestDestNode(NULL)
 		, m_pBestIntermediateNode(NULL)
 		, m_settings(&_settings_game.pf.yapf)
@@ -97,14 +97,14 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
 
 public:
 	/** return current settings (can be custom - company based - but later) */
-	inline const YAPFSettings& PfGetSettings() const
+	INLINE const YAPFSettings& PfGetSettings() const
 	{
 		return *m_settings;
 	}
@@ -118,7 +118,7 @@
 	 *      - or the maximum amount of loops reached - m_max_search_nodes (default = 10000)
 	 * @return true if the path was found
 	 */
-	inline bool FindPath(const VehicleType *v)
+	INLINE bool FindPath(const VehicleType *v)
 	{
 		m_veh = v;
 
@@ -182,7 +182,7 @@
 	 * If path was found return the best node that has reached the destination. Otherwise
 	 *  return the best visited node (which was nearest to the destination).
 	 */
-	inline Node *GetBestNode()
+	INLINE Node *GetBestNode()
 	{
 		return (m_pBestDestNode != NULL) ? m_pBestDestNode : m_pBestIntermediateNode;
 	}
@@ -191,14 +191,14 @@
 	 * Calls NodeList::CreateNewNode() - allocates new node that can be filled and used
 	 *  as argument for AddStartupNode() or AddNewNode()
 	 */
-	inline Node& CreateNewNode()
+	INLINE Node& CreateNewNode()
 	{
 		Node& node = *m_nodes.CreateNewNode();
 		return node;
 	}
 
 	/** Add new node (created by CreateNewNode and filled with data) into open list */
-	inline void AddStartupNode(Node& n)
+	INLINE void AddStartupNode(Node& n)
 	{
 		Yapf().PfNodeCacheFetch(n);
 		/* insert the new node only if it is not there */
@@ -212,7 +212,7 @@
 	}
 
 	/** add multiple nodes - direct children of the given node */
-	inline void AddMultipleNodes(Node *parent, const TrackFollower &tf)
+	INLINE void AddMultipleNodes(Node *parent, const TrackFollower &tf)
 	{
 		bool is_choice = (KillFirstBit(tf.m_new_td_bits) != TRACKDIR_BIT_NONE);
 		for (TrackdirBits rtds = tf.m_new_td_bits; rtds != TRACKDIR_BIT_NONE; rtds = KillFirstBit(rtds)) {
@@ -315,7 +315,7 @@
 
 #if 0
 	/** Example: PfSetStartupNodes() - set source (origin) nodes */
-	inline void PfSetStartupNodes()
+	INLINE void PfSetStartupNodes()
 	{
 		/* example: */
 		Node& n1 = *base::m_nodes.CreateNewNode();
@@ -326,7 +326,7 @@
 	}
 
 	/** Example: PfFollowNode() - set following (child) nodes of the given node */
-	inline void PfFollowNode(Node& org)
+	INLINE void PfFollowNode(Node& org)
 	{
 		for (each follower of node org) {
 			Node& n = *base::m_nodes.CreateNewNode();
@@ -339,7 +339,7 @@
 	}
 
 	/** Example: PfCalcCost() - set path cost from origin to the given node */
-	inline bool PfCalcCost(Node& n)
+	INLINE bool PfCalcCost(Node& n)
 	{
 		/* evaluate last step cost */
 		int cost = ...;
@@ -349,7 +349,7 @@
 	}
 
 	/** Example: PfCalcEstimate() - set path cost estimate from origin to the target through given node */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		/* evaluate the distance to our destination */
 		int distance = ...;
@@ -359,7 +359,7 @@
 	}
 
 	/** Example: PfDetectDestination() - return true if the given node is our destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		bool bDest = (n.m_key.m_x == m_x2) && (n.m_key.m_y == m_y2);
 		return bDest;
diff --git a/src/pathfinder/yapf/yapf_common.hpp b/src/pathfinder/yapf/yapf_common.hpp
--- a/src/pathfinder/yapf/yapf_common.hpp
+++ b/src/pathfinder/yapf/yapf_common.hpp
@@ -26,7 +26,7 @@
 	TrackdirBits m_orgTrackdirs;                  ///< origin trackdir mask
 
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -70,7 +70,7 @@
 	bool        m_treat_first_red_two_way_signal_as_eol; ///< in some cases (leaving station) we need to handle first two-way signal differently
 
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -104,7 +104,7 @@
 	}
 
 	/** return true if first two-way signal should be treated as dead end */
-	inline bool TreatFirstRedTwoWaySignalAsEOL()
+	INLINE bool TreatFirstRedTwoWaySignalAsEOL()
 	{
 		return Yapf().PfGetSettings().rail_firstred_twoway_eol && m_treat_first_red_two_way_signal_as_eol;
 	}
@@ -140,7 +140,7 @@
 
 public:
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		bool bDest = (n.m_key.m_tile == m_destTile) && ((m_destTrackdirs & TrackdirToTrackdirBits(n.GetTrackdir())) != TRACKDIR_BIT_NONE);
 		return bDest;
@@ -150,7 +150,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		static const int dg_dir_to_x_offs[] = {-1, 0, 1, 0};
 		static const int dg_dir_to_y_offs[] = {0, 1, 0, -1};
diff --git a/src/pathfinder/yapf/yapf_costbase.hpp b/src/pathfinder/yapf/yapf_costbase.hpp
--- a/src/pathfinder/yapf/yapf_costbase.hpp
+++ b/src/pathfinder/yapf/yapf_costbase.hpp
@@ -20,7 +20,7 @@
 	 * @param td   The track direction to check.
 	 * @return True if there's a slope, otherwise false.
 	 */
-	inline static bool stSlopeCost(TileIndex tile, Trackdir td)
+	INLINE static bool stSlopeCost(TileIndex tile, Trackdir td)
 	{
 		if (IsDiagonalTrackdir(td)) {
 			if (IsBridgeTile(tile)) {
diff --git a/src/pathfinder/yapf/yapf_costcache.hpp b/src/pathfinder/yapf/yapf_costcache.hpp
--- a/src/pathfinder/yapf/yapf_costcache.hpp
+++ b/src/pathfinder/yapf/yapf_costcache.hpp
@@ -30,7 +30,7 @@
 	 * Called by YAPF to attach cached or local segment cost data to the given node.
 	 *  @return true if globally cached data were used or false if local data was used
 	 */
-	inline bool PfNodeCacheFetch(Node& n)
+	INLINE bool PfNodeCacheFetch(Node& n)
 	{
 		return false;
 	}
@@ -39,7 +39,7 @@
 	 * Called by YAPF to flush the cached segment cost data back into cache storage.
 	 *  Current cache implementation doesn't use that.
 	 */
-	inline void PfNodeCacheFlush(Node& n)
+	INLINE void PfNodeCacheFlush(Node& n)
 	{
 	}
 };
@@ -65,7 +65,7 @@
 	LocalCache      m_local_cache;
 
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -75,7 +75,7 @@
 	 * Called by YAPF to attach cached or local segment cost data to the given node.
 	 *  @return true if globally cached data were used or false if local data was used
 	 */
-	inline bool PfNodeCacheFetch(Node& n)
+	INLINE bool PfNodeCacheFetch(Node& n)
 	{
 		CacheKey key(n.GetKey());
 		Yapf().ConnectNodeToCachedData(n, *new (m_local_cache.Append()) CachedData(key));
@@ -86,7 +86,7 @@
 	 * Called by YAPF to flush the cached segment cost data back into cache storage.
 	 *  Current cache implementation doesn't use that.
 	 */
-	inline void PfNodeCacheFlush(Node& n)
+	INLINE void PfNodeCacheFlush(Node& n)
 	{
 	}
 };
@@ -133,16 +133,16 @@
 	HashTable    m_map;
 	Heap         m_heap;
 
-	inline CSegmentCostCacheT() {}
+	INLINE CSegmentCostCacheT() {}
 
 	/** flush (clear) the cache */
-	inline void Flush()
+	INLINE void Flush()
 	{
 		m_map.Clear();
 		m_heap.Clear();
 	}
 
-	inline Tsegment& Get(Key& key, bool *found)
+	INLINE Tsegment& Get(Key& key, bool *found)
 	{
 		Tsegment *item = m_map.Find(key);
 		if (item == NULL) {
@@ -177,15 +177,15 @@
 protected:
 	Cache&      m_global_cache;
 
-	inline CYapfSegmentCostCacheGlobalT() : m_global_cache(stGetGlobalCache()) {};
+	INLINE CYapfSegmentCostCacheGlobalT() : m_global_cache(stGetGlobalCache()) {};
 
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
 
-	inline static Cache& stGetGlobalCache()
+	INLINE static Cache& stGetGlobalCache()
 	{
 		static int last_rail_change_counter = 0;
 		static Date last_date = 0;
@@ -211,7 +211,7 @@
 	 * Called by YAPF to attach cached or local segment cost data to the given node.
 	 *  @return true if globally cached data were used or false if local data was used
 	 */
-	inline bool PfNodeCacheFetch(Node& n)
+	INLINE bool PfNodeCacheFetch(Node& n)
 	{
 		if (!Yapf().CanUseGlobalCache(n)) {
 			return Tlocal::PfNodeCacheFetch(n);
@@ -227,7 +227,7 @@
 	 * Called by YAPF to flush the cached segment cost data back into cache storage.
 	 *  Current cache implementation doesn't use that.
 	 */
-	inline void PfNodeCacheFlush(Node& n)
+	INLINE void PfNodeCacheFlush(Node& n)
 	{
 	}
 };
diff --git a/src/pathfinder/yapf/yapf_costrail.hpp b/src/pathfinder/yapf/yapf_costrail.hpp
--- a/src/pathfinder/yapf/yapf_costrail.hpp
+++ b/src/pathfinder/yapf/yapf_costrail.hpp
@@ -96,14 +96,14 @@
 	}
 
 public:
-	inline int SlopeCost(TileIndex tile, Trackdir td)
+	INLINE int SlopeCost(TileIndex tile, Trackdir td)
 	{
 		CPerfStart perf_cost(Yapf().m_perf_slope_cost);
 		if (!stSlopeCost(tile, td)) return 0;
 		return Yapf().PfGetSettings().rail_slope_penalty;
 	}
 
-	inline int CurveCost(Trackdir td1, Trackdir td2)
+	INLINE int CurveCost(Trackdir td1, Trackdir td2)
 	{
 		assert(IsValidTrackdir(td1));
 		assert(IsValidTrackdir(td2));
@@ -119,7 +119,7 @@
 		return cost;
 	}
 
-	inline int SwitchCost(TileIndex tile1, TileIndex tile2, DiagDirection exitdir)
+	INLINE int SwitchCost(TileIndex tile1, TileIndex tile2, DiagDirection exitdir)
 	{
 		if (IsPlainRailTile(tile1) && IsPlainRailTile(tile2)) {
 			bool t1 = KillFirstBit(GetTrackBits(tile1) & DiagdirReachesTracks(ReverseDiagDir(exitdir))) != TRACK_BIT_NONE;
@@ -130,7 +130,7 @@
 	}
 
 	/** Return one tile cost (base cost + level crossing penalty). */
-	inline int OneTileCost(TileIndex& tile, Trackdir trackdir)
+	INLINE int OneTileCost(TileIndex& tile, Trackdir trackdir)
 	{
 		int cost = 0;
 		/* set base cost */
@@ -155,7 +155,7 @@
 	}
 
 	/** Check for a reserved station platform. */
-	inline bool IsAnyStationTileReserved(TileIndex tile, Trackdir trackdir, int skipped)
+	INLINE bool IsAnyStationTileReserved(TileIndex tile, Trackdir trackdir, int skipped)
 	{
 		TileIndexDiff diff = TileOffsByDiagDir(TrackdirToExitdir(ReverseTrackdir(trackdir)));
 		for (; skipped >= 0; skipped--, tile += diff) {
@@ -165,7 +165,7 @@
 	}
 
 	/** The cost for reserved tiles, including skipped ones. */
-	inline int ReservationCost(Node& n, TileIndex tile, Trackdir trackdir, int skipped)
+	INLINE int ReservationCost(Node& n, TileIndex tile, Trackdir trackdir, int skipped)
 	{
 		if (n.m_num_signals_passed >= m_sig_look_ahead_costs.Size() / 2) return 0;
 		if (!IsPbsSignal(n.m_last_signal_type)) return 0;
@@ -251,7 +251,7 @@
 		return cost;
 	}
 
-	inline int PlatformLengthPenalty(int platform_length)
+	INLINE int PlatformLengthPenalty(int platform_length)
 	{
 		int cost = 0;
 		const Train *v = Yapf().GetVehicle();
@@ -270,7 +270,7 @@
 	}
 
 public:
-	inline void SetMaxCost(int max_cost)
+	INLINE void SetMaxCost(int max_cost)
 	{
 		m_max_cost = max_cost;
 	}
@@ -280,7 +280,7 @@
 	 *  Calculates only the cost of given node, adds it to the parent node cost
 	 *  and stores the result into Node::m_cost member
 	 */
-	inline bool PfCalcCost(Node &n, const TrackFollower *tf)
+	INLINE bool PfCalcCost(Node &n, const TrackFollower *tf)
 	{
 		assert(!n.flags_u.flags_s.m_targed_seen);
 		assert(tf->m_new_tile == n.m_key.m_tile);
@@ -613,14 +613,14 @@
 		return true;
 	}
 
-	inline bool CanUseGlobalCache(Node& n) const
+	INLINE bool CanUseGlobalCache(Node& n) const
 	{
 		return !m_disable_cache
 			&& (n.m_parent != NULL)
 			&& (n.m_parent->m_num_signals_passed >= m_sig_look_ahead_costs.Size());
 	}
 
-	inline void ConnectNodeToCachedData(Node& n, CachedData& ci)
+	INLINE void ConnectNodeToCachedData(Node& n, CachedData& ci)
 	{
 		n.m_segment = &ci;
 		if (n.m_segment->m_cost < 0) {
diff --git a/src/pathfinder/yapf/yapf_destrail.hpp b/src/pathfinder/yapf/yapf_destrail.hpp
--- a/src/pathfinder/yapf/yapf_destrail.hpp
+++ b/src/pathfinder/yapf/yapf_destrail.hpp
@@ -51,13 +51,13 @@
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		return PfDetectDestination(n.GetLastTile(), n.GetLastTrackdir());
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(TileIndex tile, Trackdir td)
+	INLINE bool PfDetectDestination(TileIndex tile, Trackdir td)
 	{
 		bool bDest = IsRailDepotTile(tile);
 		return bDest;
@@ -67,7 +67,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		n.m_estimate = n.m_cost;
 		return true;
@@ -91,13 +91,13 @@
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		return PfDetectDestination(n.GetLastTile(), n.GetLastTrackdir());
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(TileIndex tile, Trackdir td)
+	INLINE bool PfDetectDestination(TileIndex tile, Trackdir td)
 	{
 		return IsSafeWaitingPosition(Yapf().GetVehicle(), tile, td, true, !TrackFollower::Allow90degTurns()) &&
 				IsWaitingPositionFree(Yapf().GetVehicle(), tile, td, !TrackFollower::Allow90degTurns());
@@ -107,7 +107,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate.
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		n.m_estimate = n.m_cost;
 		return true;
@@ -164,13 +164,13 @@
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		return PfDetectDestination(n.GetLastTile(), n.GetLastTrackdir());
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(TileIndex tile, Trackdir td)
+	INLINE bool PfDetectDestination(TileIndex tile, Trackdir td)
 	{
 		bool bDest;
 		if (m_dest_station_id != INVALID_STATION) {
@@ -188,7 +188,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		static const int dg_dir_to_x_offs[] = {-1, 0, 1, 0};
 		static const int dg_dir_to_y_offs[] = {0, 1, 0, -1};
diff --git a/src/pathfinder/yapf/yapf_node.hpp b/src/pathfinder/yapf/yapf_node.hpp
--- a/src/pathfinder/yapf/yapf_node.hpp
+++ b/src/pathfinder/yapf/yapf_node.hpp
@@ -18,15 +18,15 @@
 	Trackdir       m_td;
 	DiagDirection  m_exitdir;
 
-	inline void Set(TileIndex tile, Trackdir td)
+	INLINE void Set(TileIndex tile, Trackdir td)
 	{
 		m_tile = tile;
 		m_td = td;
 		m_exitdir = (m_td == INVALID_TRACKDIR) ? INVALID_DIAGDIR : TrackdirToExitdir(m_td);
 	}
 
-	inline int CalcHash() const {return m_exitdir | (m_tile << 2);}
-	inline bool operator == (const CYapfNodeKeyExitDir& other) const {return (m_tile == other.m_tile) && (m_exitdir == other.m_exitdir);}
+	INLINE int CalcHash() const {return m_exitdir | (m_tile << 2);}
+	INLINE bool operator == (const CYapfNodeKeyExitDir& other) const {return (m_tile == other.m_tile) && (m_exitdir == other.m_exitdir);}
 
 	void Dump(DumpTarget &dmp) const
 	{
@@ -38,8 +38,8 @@
 
 struct CYapfNodeKeyTrackDir : public CYapfNodeKeyExitDir
 {
-	inline int CalcHash() const {return m_td | (m_tile << 4);}
-	inline bool operator == (const CYapfNodeKeyTrackDir& other) const {return (m_tile == other.m_tile) && (m_td == other.m_td);}
+	INLINE int CalcHash() const {return m_td | (m_tile << 4);}
+	INLINE bool operator == (const CYapfNodeKeyTrackDir& other) const {return (m_tile == other.m_tile) && (m_td == other.m_td);}
 };
 
 /** Yapf Node base */
@@ -54,7 +54,7 @@
 	int         m_cost;
 	int         m_estimate;
 
-	inline void Set(Node *parent, TileIndex tile, Trackdir td, bool is_choice)
+	INLINE void Set(Node *parent, TileIndex tile, Trackdir td, bool is_choice)
 	{
 		m_key.Set(tile, td);
 		m_hash_next = NULL;
@@ -63,14 +63,14 @@
 		m_estimate = 0;
 	}
 
-	inline Node *GetHashNext() {return m_hash_next;}
-	inline void SetHashNext(Node *pNext) {m_hash_next = pNext;}
-	inline TileIndex GetTile() const {return m_key.m_tile;}
-	inline Trackdir GetTrackdir() const {return m_key.m_td;}
-	inline const Tkey_& GetKey() const {return m_key;}
-	inline int GetCost() const {return m_cost;}
-	inline int GetCostEstimate() const {return m_estimate;}
-	inline bool operator < (const Node& other) const {return m_estimate < other.m_estimate;}
+	INLINE Node *GetHashNext() {return m_hash_next;}
+	INLINE void SetHashNext(Node *pNext) {m_hash_next = pNext;}
+	INLINE TileIndex GetTile() const {return m_key.m_tile;}
+	INLINE Trackdir GetTrackdir() const {return m_key.m_td;}
+	INLINE const Tkey_& GetKey() const {return m_key;}
+	INLINE int GetCost() const {return m_cost;}
+	INLINE int GetCostEstimate() const {return m_estimate;}
+	INLINE bool operator < (const Node& other) const {return m_estimate < other.m_estimate;}
 
 	void Dump(DumpTarget &dmp) const
 	{
diff --git a/src/pathfinder/yapf/yapf_node_rail.hpp b/src/pathfinder/yapf/yapf_node_rail.hpp
--- a/src/pathfinder/yapf/yapf_node_rail.hpp
+++ b/src/pathfinder/yapf/yapf_node_rail.hpp
@@ -17,39 +17,39 @@
 {
 	uint32    m_value;
 
-	inline CYapfRailSegmentKey(const CYapfRailSegmentKey& src) : m_value(src.m_value) {}
+	INLINE CYapfRailSegmentKey(const CYapfRailSegmentKey& src) : m_value(src.m_value) {}
 
-	inline CYapfRailSegmentKey(const CYapfNodeKeyTrackDir& node_key)
+	INLINE CYapfRailSegmentKey(const CYapfNodeKeyTrackDir& node_key)
 	{
 		Set(node_key);
 	}
 
-	inline void Set(const CYapfRailSegmentKey& src)
+	INLINE void Set(const CYapfRailSegmentKey& src)
 	{
 		m_value = src.m_value;
 	}
 
-	inline void Set(const CYapfNodeKeyTrackDir& node_key)
+	INLINE void Set(const CYapfNodeKeyTrackDir& node_key)
 	{
 		m_value = (((int)node_key.m_tile) << 4) | node_key.m_td;
 	}
 
-	inline int32 CalcHash() const
+	INLINE int32 CalcHash() const
 	{
 		return m_value;
 	}
 
-	inline TileIndex GetTile() const
+	INLINE TileIndex GetTile() const
 	{
 		return (TileIndex)(m_value >> 4);
 	}
 
-	inline Trackdir GetTrackdir() const
+	INLINE Trackdir GetTrackdir() const
 	{
 		return (Trackdir)(m_value & 0x0F);
 	}
 
-	inline bool operator == (const CYapfRailSegmentKey& other) const
+	INLINE bool operator == (const CYapfRailSegmentKey& other) const
 	{
 		return m_value == other.m_value;
 	}
@@ -117,7 +117,7 @@
 
 DECLARE_ENUM_AS_BIT_SET(EndSegmentReasonBits)
 
-inline CStrA ValueStr(EndSegmentReasonBits bits)
+INLINE CStrA ValueStr(EndSegmentReasonBits bits)
 {
 	static const char * const end_segment_reason_names[] = {
 		"DEAD_END", "RAIL_TYPE", "INFINITE_LOOP", "SEGMENT_TOO_LONG", "CHOICE_FOLLOWS",
@@ -144,7 +144,7 @@
 	EndSegmentReasonBits   m_end_segment_reason;
 	CYapfRailSegment      *m_hash_next;
 
-	inline CYapfRailSegment(const CYapfRailSegmentKey& key)
+	INLINE CYapfRailSegment(const CYapfRailSegmentKey& key)
 		: m_key(key)
 		, m_last_tile(INVALID_TILE)
 		, m_last_td(INVALID_TRACKDIR)
@@ -155,22 +155,22 @@
 		, m_hash_next(NULL)
 	{}
 
-	inline const Key& GetKey() const
+	INLINE const Key& GetKey() const
 	{
 		return m_key;
 	}
 
-	inline TileIndex GetTile() const
+	INLINE TileIndex GetTile() const
 	{
 		return m_key.GetTile();
 	}
 
-	inline CYapfRailSegment *GetHashNext()
+	INLINE CYapfRailSegment *GetHashNext()
 	{
 		return m_hash_next;
 	}
 
-	inline void SetHashNext(CYapfRailSegment *next)
+	INLINE void SetHashNext(CYapfRailSegment *next)
 	{
 		m_hash_next = next;
 	}
@@ -208,7 +208,7 @@
 	SignalType        m_last_red_signal_type;
 	SignalType        m_last_signal_type;
 
-	inline void Set(CYapfRailNodeT *parent, TileIndex tile, Trackdir td, bool is_choice)
+	INLINE void Set(CYapfRailNodeT *parent, TileIndex tile, Trackdir td, bool is_choice)
 	{
 		base::Set(parent, tile, td, is_choice);
 		m_segment = NULL;
@@ -236,19 +236,19 @@
 		flags_u.flags_s.m_choice_seen |= is_choice;
 	}
 
-	inline TileIndex GetLastTile() const
+	INLINE TileIndex GetLastTile() const
 	{
 		assert(m_segment != NULL);
 		return m_segment->m_last_tile;
 	}
 
-	inline Trackdir GetLastTrackdir() const
+	INLINE Trackdir GetLastTrackdir() const
 	{
 		assert(m_segment != NULL);
 		return m_segment->m_last_td;
 	}
 
-	inline void SetLastTileTrackdir(TileIndex tile, Trackdir td)
+	INLINE void SetLastTileTrackdir(TileIndex tile, Trackdir td)
 	{
 		assert(m_segment != NULL);
 		m_segment->m_last_tile = tile;
diff --git a/src/pathfinder/yapf/yapf_rail.cpp b/src/pathfinder/yapf/yapf_rail.cpp
--- a/src/pathfinder/yapf/yapf_rail.cpp
+++ b/src/pathfinder/yapf/yapf_rail.cpp
@@ -47,7 +47,7 @@
 
 protected:
 	/** to access inherited pathfinder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -125,7 +125,7 @@
 
 public:
 	/** Set the target to where the reservation should be extended. */
-	inline void SetReservationTarget(Node *node, TileIndex tile, Trackdir td)
+	INLINE void SetReservationTarget(Node *node, TileIndex tile, Trackdir td)
 	{
 		m_res_node = node;
 		m_res_dest = tile;
@@ -133,7 +133,7 @@
 	}
 
 	/** Check the node for a possible reservation target. */
-	inline void FindSafePositionOnNode(Node *node)
+	INLINE void FindSafePositionOnNode(Node *node)
 	{
 		assert(node->m_parent != NULL);
 
@@ -197,7 +197,7 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -208,7 +208,7 @@
 	 *  reachable trackdir on the new tile creates new node, initializes it
 	 *  and adds it to the open list by calling Yapf().AddNewNode(n)
 	 */
-	inline void PfFollowNode(Node& old_node)
+	INLINE void PfFollowNode(Node& old_node)
 	{
 		TrackFollower F(Yapf().GetVehicle());
 		if (F.Follow(old_node.GetLastTile(), old_node.GetLastTrackdir())) {
@@ -217,7 +217,7 @@
 	}
 
 	/** return debug report character to identify the transportation type */
-	inline char TransportTypeChar() const
+	INLINE char TransportTypeChar() const
 	{
 		return 't';
 	}
@@ -252,7 +252,7 @@
 		return result1;
 	}
 
-	inline bool FindNearestDepotTwoWay(const Train *v, TileIndex t1, Trackdir td1, TileIndex t2, Trackdir td2, int max_penalty, int reverse_penalty, TileIndex *depot_tile, bool *reversed)
+	INLINE bool FindNearestDepotTwoWay(const Train *v, TileIndex t1, Trackdir td1, TileIndex t2, Trackdir td2, int max_penalty, int reverse_penalty, TileIndex *depot_tile, bool *reversed)
 	{
 		/* set origin and destination nodes */
 		Yapf().SetOrigin(t1, td1, t2, td2, reverse_penalty, true);
@@ -293,7 +293,7 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -304,7 +304,7 @@
 	 *  reachable trackdir on the new tile creates new node, initializes it
 	 *  and adds it to the open list by calling Yapf().AddNewNode(n)
 	 */
-	inline void PfFollowNode(Node& old_node)
+	INLINE void PfFollowNode(Node& old_node)
 	{
 		TrackFollower F(Yapf().GetVehicle(), Yapf().GetCompatibleRailTypes());
 		if (F.Follow(old_node.GetLastTile(), old_node.GetLastTrackdir()) && F.MaskReservedTracks()) {
@@ -313,7 +313,7 @@
 	}
 
 	/** Return debug report character to identify the transportation type */
-	inline char TransportTypeChar() const
+	INLINE char TransportTypeChar() const
 	{
 		return 't';
 	}
@@ -376,7 +376,7 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -387,7 +387,7 @@
 	 *  reachable trackdir on the new tile creates new node, initializes it
 	 *  and adds it to the open list by calling Yapf().AddNewNode(n)
 	 */
-	inline void PfFollowNode(Node& old_node)
+	INLINE void PfFollowNode(Node& old_node)
 	{
 		TrackFollower F(Yapf().GetVehicle());
 		if (F.Follow(old_node.GetLastTile(), old_node.GetLastTrackdir())) {
@@ -396,7 +396,7 @@
 	}
 
 	/** return debug report character to identify the transportation type */
-	inline char TransportTypeChar() const
+	INLINE char TransportTypeChar() const
 	{
 		return 't';
 	}
@@ -422,7 +422,7 @@
 		return result1;
 	}
 
-	inline Trackdir ChooseRailTrack(const Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool &path_found, bool reserve_track, PBSTileInfo *target)
+	INLINE Trackdir ChooseRailTrack(const Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool &path_found, bool reserve_track, PBSTileInfo *target)
 	{
 		if (target != NULL) target->tile = INVALID_TILE;
 
@@ -480,7 +480,7 @@
 		return result1;
 	}
 
-	inline bool CheckReverseTrain(const Train *v, TileIndex t1, Trackdir td1, TileIndex t2, Trackdir td2, int reverse_penalty)
+	INLINE bool CheckReverseTrain(const Train *v, TileIndex t1, Trackdir td1, TileIndex t2, Trackdir td2, int reverse_penalty)
 	{
 		/* create pathfinder instance
 		 * set origin and destination nodes */
diff --git a/src/pathfinder/yapf/yapf_road.cpp b/src/pathfinder/yapf/yapf_road.cpp
--- a/src/pathfinder/yapf/yapf_road.cpp
+++ b/src/pathfinder/yapf/yapf_road.cpp
@@ -51,7 +51,7 @@
 	}
 
 	/** return one tile cost */
-	inline int OneTileCost(TileIndex tile, Trackdir trackdir)
+	INLINE int OneTileCost(TileIndex tile, Trackdir trackdir)
 	{
 		int cost = 0;
 		/* set base cost */
@@ -100,7 +100,7 @@
 	 *  Calculates only the cost of given node, adds it to the parent node cost
 	 *  and stores the result into Node::m_cost member
 	 */
-	inline bool PfCalcCost(Node& n, const TrackFollower *tf)
+	INLINE bool PfCalcCost(Node& n, const TrackFollower *tf)
 	{
 		int segment_cost = 0;
 		uint tiles = 0;
@@ -181,13 +181,13 @@
 	}
 
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		bool bDest = IsRoadDepotTile(n.m_segment_last_tile);
 		return bDest;
 	}
 
-	inline bool PfDetectDestinationTile(TileIndex tile, Trackdir trackdir)
+	INLINE bool PfDetectDestinationTile(TileIndex tile, Trackdir trackdir)
 	{
 		return IsRoadDepotTile(tile);
 	}
@@ -196,7 +196,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		n.m_estimate = n.m_cost;
 		return true;
@@ -245,12 +245,12 @@
 
 public:
 	/** Called by YAPF to detect if node ends in the desired destination */
-	inline bool PfDetectDestination(Node& n)
+	INLINE bool PfDetectDestination(Node& n)
 	{
 		return PfDetectDestinationTile(n.m_segment_last_tile, n.m_segment_last_td);
 	}
 
-	inline bool PfDetectDestinationTile(TileIndex tile, Trackdir trackdir)
+	INLINE bool PfDetectDestinationTile(TileIndex tile, Trackdir trackdir)
 	{
 		if (m_dest_station != INVALID_STATION) {
 			return IsTileType(tile, MP_STATION) &&
@@ -266,7 +266,7 @@
 	 * Called by YAPF to calculate cost estimate. Calculates distance to the destination
 	 *  adds it to the actual cost from origin and stores the sum to the Node::m_estimate
 	 */
-	inline bool PfCalcEstimate(Node& n)
+	INLINE bool PfCalcEstimate(Node& n)
 	{
 		static const int dg_dir_to_x_offs[] = {-1, 0, 1, 0};
 		static const int dg_dir_to_y_offs[] = {0, 1, 0, -1};
@@ -305,7 +305,7 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -317,7 +317,7 @@
 	 *  reachable trackdir on the new tile creates new node, initializes it
 	 *  and adds it to the open list by calling Yapf().AddNewNode(n)
 	 */
-	inline void PfFollowNode(Node& old_node)
+	INLINE void PfFollowNode(Node& old_node)
 	{
 		TrackFollower F(Yapf().GetVehicle());
 		if (F.Follow(old_node.m_segment_last_tile, old_node.m_segment_last_td)) {
@@ -326,7 +326,7 @@
 	}
 
 	/** return debug report character to identify the transportation type */
-	inline char TransportTypeChar() const
+	INLINE char TransportTypeChar() const
 	{
 		return 'r';
 	}
@@ -337,7 +337,7 @@
 		return pf.ChooseRoadTrack(v, tile, enterdir, path_found);
 	}
 
-	inline Trackdir ChooseRoadTrack(const RoadVehicle *v, TileIndex tile, DiagDirection enterdir, bool &path_found)
+	INLINE Trackdir ChooseRoadTrack(const RoadVehicle *v, TileIndex tile, DiagDirection enterdir, bool &path_found)
 	{
 		/* Handle special case - when next tile is destination tile.
 		 * However, when going to a station the (initial) destination
@@ -384,7 +384,7 @@
 		return pf.DistanceToTile(v, tile);
 	}
 
-	inline uint DistanceToTile(const RoadVehicle *v, TileIndex dst_tile)
+	INLINE uint DistanceToTile(const RoadVehicle *v, TileIndex dst_tile)
 	{
 		/* handle special case - when current tile is the destination tile */
 		if (dst_tile == v->tile) {
@@ -414,7 +414,7 @@
 	}
 
 	/** Return true if the valid origin (tile/trackdir) was set from the current vehicle position. */
-	inline bool SetOriginFromVehiclePos(const RoadVehicle *v)
+	INLINE bool SetOriginFromVehiclePos(const RoadVehicle *v)
 	{
 		/* set origin (tile, trackdir) */
 		TileIndex src_tile = v->tile;
@@ -434,7 +434,7 @@
 		return pf.FindNearestDepot(v, tile, td, max_distance, depot_tile);
 	}
 
-	inline bool FindNearestDepot(const RoadVehicle *v, TileIndex tile, Trackdir td, int max_distance, TileIndex *depot_tile)
+	INLINE bool FindNearestDepot(const RoadVehicle *v, TileIndex tile, Trackdir td, int max_distance, TileIndex *depot_tile)
 	{
 		/* set origin and destination nodes */
 		Yapf().SetOrigin(tile, TrackdirToTrackdirBits(td));
diff --git a/src/pathfinder/yapf/yapf_ship.cpp b/src/pathfinder/yapf/yapf_ship.cpp
--- a/src/pathfinder/yapf/yapf_ship.cpp
+++ b/src/pathfinder/yapf/yapf_ship.cpp
@@ -27,7 +27,7 @@
 
 protected:
 	/** to access inherited path finder */
-	inline Tpf& Yapf()
+	INLINE Tpf& Yapf()
 	{
 		return *static_cast<Tpf*>(this);
 	}
@@ -38,7 +38,7 @@
 	 *  reachable trackdir on the new tile creates new node, initializes it
 	 *  and adds it to the open list by calling Yapf().AddNewNode(n)
 	 */
-	inline void PfFollowNode(Node& old_node)
+	INLINE void PfFollowNode(Node& old_node)
 	{
 		TrackFollower F(Yapf().GetVehicle());
 		if (F.Follow(old_node.m_key.m_tile, old_node.m_key.m_td)) {
@@ -47,7 +47,7 @@
 	}
 
 	/** return debug report character to identify the transportation type */
-	inline char TransportTypeChar() const
+	INLINE char TransportTypeChar() const
 	{
 		return 'w';
 	}
@@ -159,7 +159,7 @@
 	 *  Calculates only the cost of given node, adds it to the parent node cost
 	 *  and stores the result into Node::m_cost member
 	 */
-	inline bool PfCalcCost(Node& n, const TrackFollower *tf)
+	INLINE bool PfCalcCost(Node& n, const TrackFollower *tf)
 	{
 		/* base tile cost depending on distance */
 		int c = IsDiagonalTrackdir(n.GetTrackdir()) ? YAPF_TILE_LENGTH : YAPF_TILE_CORNER_LENGTH;
diff --git a/src/pbs.h b/src/pbs.h
--- a/src/pbs.h
+++ b/src/pbs.h
@@ -57,7 +57,7 @@
  * @param tracks the tracks to test
  * @return true if at least on of tracks is reserved
  */
-static inline bool HasReservedTracks(TileIndex tile, TrackBits tracks)
+static INLINE bool HasReservedTracks(TileIndex tile, TrackBits tracks)
 {
 	return (GetReservedTrackbits(tile) & tracks) != TRACK_BIT_NONE;
 }
diff --git a/src/progress.h b/src/progress.h
--- a/src/progress.h
+++ b/src/progress.h
@@ -20,7 +20,7 @@
  * Check if we are currently in a modal progress state.
  * @return Are we in the modal state?
  */
-static inline bool HasModalProgress()
+static INLINE bool HasModalProgress()
 {
 	extern bool _in_modal_progress;
 	return _in_modal_progress;
diff --git a/src/rail.h b/src/rail.h
--- a/src/rail.h
+++ b/src/rail.h
@@ -260,7 +260,7 @@
 	 */
 	const SpriteGroup *group[RTSG_END];
 
-	inline bool UsesOverlay() const
+	INLINE bool UsesOverlay() const
 	{
 		return this->group[RTSG_GROUND] != NULL;
 	}
@@ -272,7 +272,7 @@
 	 * 2) The position where the railtype is loaded must always be the same, otherwise
 	 *    the offset will fail.
 	 */
-	inline uint GetRailtypeSpriteOffset() const
+	INLINE uint GetRailtypeSpriteOffset() const
 	{
 		return 82 * this->fallback_railtype;
 	}
@@ -284,7 +284,7 @@
  * @param railtype the rail type which the information is requested for
  * @return The pointer to the RailtypeInfo
  */
-static inline const RailtypeInfo *GetRailTypeInfo(RailType railtype)
+static INLINE const RailtypeInfo *GetRailTypeInfo(RailType railtype)
 {
 	extern RailtypeInfo _railtypes[RAILTYPE_END];
 	assert(railtype < RAILTYPE_END);
@@ -299,7 +299,7 @@
  * @param  enginetype The RailType of the engine we are considering.
  * @param  tiletype   The RailType of the tile we are considering.
  */
-static inline bool IsCompatibleRail(RailType enginetype, RailType tiletype)
+static INLINE bool IsCompatibleRail(RailType enginetype, RailType tiletype)
 {
 	return HasBit(GetRailTypeInfo(enginetype)->compatible_railtypes, tiletype);
 }
@@ -312,7 +312,7 @@
  * @param  enginetype The RailType of the engine we are considering.
  * @param  tiletype   The RailType of the tile we are considering.
  */
-static inline bool HasPowerOnRail(RailType enginetype, RailType tiletype)
+static INLINE bool HasPowerOnRail(RailType enginetype, RailType tiletype)
 {
 	return HasBit(GetRailTypeInfo(enginetype)->powered_railtypes, tiletype);
 }
@@ -322,7 +322,7 @@
  * @param rt The RailType to check.
  * @return Whether level crossings are not allowed.
  */
-static inline bool RailNoLevelCrossings(RailType rt)
+static INLINE bool RailNoLevelCrossings(RailType rt)
 {
 	return HasBit(GetRailTypeInfo(rt)->flags, RTF_NO_LEVEL_CROSSING);
 }
@@ -332,7 +332,7 @@
  * @param railtype The railtype being built.
  * @return The cost multiplier.
  */
-static inline Money RailBuildCost(RailType railtype)
+static INLINE Money RailBuildCost(RailType railtype)
 {
 	assert(railtype < RAILTYPE_END);
 	return (_price[PR_BUILD_RAIL] * GetRailTypeInfo(railtype)->cost_multiplier) >> 3;
@@ -343,7 +343,7 @@
  * @param railtype The railtype being removed.
  * @return The cost.
  */
-static inline Money RailClearCost(RailType railtype)
+static INLINE Money RailClearCost(RailType railtype)
 {
 	/* Clearing rail in fact earns money, but if the build cost is set
 	 * very low then a loophole exists where money can be made.
@@ -360,7 +360,7 @@
  * @param to   The railtype we are converting to
  * @return Cost per TrackBit
  */
-static inline Money RailConvertCost(RailType from, RailType to)
+static INLINE Money RailConvertCost(RailType from, RailType to)
 {
 	/* Get the costs for removing and building anew
 	 * A conversion can never be more costly */
@@ -387,7 +387,7 @@
  * @param total_num Total number of track bits of all railtypes.
  * @return Total cost.
  */
-static inline Money RailMaintenanceCost(RailType railtype, uint32 num, uint32 total_num)
+static INLINE Money RailMaintenanceCost(RailType railtype, uint32 num, uint32 total_num)
 {
 	assert(railtype < RAILTYPE_END);
 	return (_price[PR_INFRASTRUCTURE_RAIL] * GetRailTypeInfo(railtype)->maintenance_multiplier * num * (1 + IntSqrt(total_num))) >> 11; // 4 bits fraction for the multiplier and 7 bits scaling.
@@ -398,7 +398,7 @@
  * @param num Number of signals.
  * @return Total cost.
  */
-static inline Money SignalMaintenanceCost(uint32 num)
+static INLINE Money SignalMaintenanceCost(uint32 num)
 {
 	return (_price[PR_INFRASTRUCTURE_RAIL] * 15 * num * (1 + IntSqrt(num))) >> 8; // 1 bit fraction for the multiplier and 7 bits scaling.
 }
diff --git a/src/rail_cmd.cpp b/src/rail_cmd.cpp
--- a/src/rail_cmd.cpp
+++ b/src/rail_cmd.cpp
@@ -393,7 +393,7 @@
 }
 
 /* Validate functions for rail building */
-static inline bool ValParamTrackOrientation(Track track)
+static INLINE bool ValParamTrackOrientation(Track track)
 {
 	return IsValidTrack(track);
 }
@@ -2005,7 +2005,7 @@
 	{ -INF    , -INF  , INF    , 30 - 23 }  // CORNER_N, clip 23 pixels from bottom
 };
 
-static inline void DrawTrackSprite(SpriteID sprite, PaletteID pal, const TileInfo *ti, Slope s)
+static INLINE void DrawTrackSprite(SpriteID sprite, PaletteID pal, const TileInfo *ti, Slope s)
 {
 	DrawGroundSprite(sprite, pal, NULL, 0, (ti->tileh & s) ? -8 : 0);
 }
diff --git a/src/rail_map.h b/src/rail_map.h
--- a/src/rail_map.h
+++ b/src/rail_map.h
@@ -34,7 +34,7 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return the RailTileType
  */
-static inline RailTileType GetRailTileType(TileIndex t)
+static INLINE RailTileType GetRailTileType(TileIndex t)
 {
 	assert(IsTileType(t, MP_RAILWAY));
 	return (RailTileType)GB(_m[t].m5, 6, 2);
@@ -47,7 +47,7 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return true if and only if the tile is normal rail (with or without signals)
  */
-static inline bool IsPlainRail(TileIndex t)
+static INLINE bool IsPlainRail(TileIndex t)
 {
 	RailTileType rtt = GetRailTileType(t);
 	return rtt == RAIL_TILE_NORMAL || rtt == RAIL_TILE_SIGNALS;
@@ -58,7 +58,7 @@
  * @param t the tile to get the information from
  * @return true if and only if the tile is normal rail (with or without signals)
  */
-static inline bool IsPlainRailTile(TileIndex t)
+static INLINE bool IsPlainRailTile(TileIndex t)
 {
 	return IsTileType(t, MP_RAILWAY) && IsPlainRail(t);
 }
@@ -70,7 +70,7 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return true if and only if the tile has signals
  */
-static inline bool HasSignals(TileIndex t)
+static INLINE bool HasSignals(TileIndex t)
 {
 	return GetRailTileType(t) == RAIL_TILE_SIGNALS;
 }
@@ -81,7 +81,7 @@
  * @param signals whether the rail tile should have signals or not
  * @pre IsPlainRailTile(tile)
  */
-static inline void SetHasSignals(TileIndex tile, bool signals)
+static INLINE void SetHasSignals(TileIndex tile, bool signals)
 {
 	assert(IsPlainRailTile(tile));
 	SB(_m[tile].m5, 6, 1, signals);
@@ -93,7 +93,7 @@
  * @pre IsTileType(t, MP_RAILWAY)
  * @return true if and only if the tile is a rail depot
  */
-static inline bool IsRailDepot(TileIndex t)
+static INLINE bool IsRailDepot(TileIndex t)
 {
 	return GetRailTileType(t) == RAIL_TILE_DEPOT;
 }
@@ -103,7 +103,7 @@
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail depot
  */
-static inline bool IsRailDepotTile(TileIndex t)
+static INLINE bool IsRailDepotTile(TileIndex t)
 {
 	return IsTileType(t, MP_RAILWAY) && IsRailDepot(t);
 }
@@ -113,7 +113,7 @@
  * @param t the tile to get the rail type from
  * @return the rail type of the tile
  */
-static inline RailType GetRailType(TileIndex t)
+static INLINE RailType GetRailType(TileIndex t)
 {
 	return (RailType)GB(_m[t].m3, 0, 4);
 }
@@ -123,7 +123,7 @@
  * @param t the tile to set the rail type of
  * @param r the new rail type for the tile
  */
-static inline void SetRailType(TileIndex t, RailType r)
+static INLINE void SetRailType(TileIndex t, RailType r)
 {
 	SB(_m[t].m3, 0, 4, r);
 }
@@ -134,7 +134,7 @@
  * @param tile the tile to get the track bits from
  * @return the track bits of the tile
  */
-static inline TrackBits GetTrackBits(TileIndex tile)
+static INLINE TrackBits GetTrackBits(TileIndex tile)
 {
 	assert(IsPlainRailTile(tile));
 	return (TrackBits)GB(_m[tile].m5, 0, 6);
@@ -145,7 +145,7 @@
  * @param t the tile to set the track bits of
  * @param b the new track bits for the tile
  */
-static inline void SetTrackBits(TileIndex t, TrackBits b)
+static INLINE void SetTrackBits(TileIndex t, TrackBits b)
 {
 	assert(IsPlainRailTile(t));
 	SB(_m[t].m5, 0, 6, b);
@@ -158,7 +158,7 @@
  * @pre IsPlainRailTile(tile)
  * @return true if and only if the given track exists on the tile
  */
-static inline bool HasTrack(TileIndex tile, Track track)
+static INLINE bool HasTrack(TileIndex tile, Track track)
 {
 	return HasBit(GetTrackBits(tile), track);
 }
@@ -169,7 +169,7 @@
  * @pre IsRailDepotTile(t)
  * @return the direction the depot is facing
  */
-static inline DiagDirection GetRailDepotDirection(TileIndex t)
+static INLINE DiagDirection GetRailDepotDirection(TileIndex t)
 {
 	return (DiagDirection)GB(_m[t].m5, 0, 2);
 }
@@ -180,7 +180,7 @@
  * @param t the tile to get the depot track from
  * @return the track of the depot
  */
-static inline Track GetRailDepotTrack(TileIndex t)
+static INLINE Track GetRailDepotTrack(TileIndex t)
 {
 	return DiagDirToDiagTrack(GetRailDepotDirection(t));
 }
@@ -192,7 +192,7 @@
  * @param t the tile to query
  * @return the track bits
  */
-static inline TrackBits GetRailReservationTrackBits(TileIndex t)
+static INLINE TrackBits GetRailReservationTrackBits(TileIndex t)
 {
 	assert(IsPlainRailTile(t));
 	byte track_b = GB(_m[t].m2, 8, 3);
@@ -207,7 +207,7 @@
  * @param t the tile to change
  * @param b the track bits
  */
-static inline void SetTrackReservation(TileIndex t, TrackBits b)
+static INLINE void SetTrackReservation(TileIndex t, TrackBits b)
 {
 	assert(IsPlainRailTile(t));
 	assert(b != INVALID_TRACK_BIT);
@@ -224,7 +224,7 @@
  * @param t the rack to reserve
  * @return true if successful
  */
-static inline bool TryReserveTrack(TileIndex tile, Track t)
+static INLINE bool TryReserveTrack(TileIndex tile, Track t)
 {
 	assert(HasTrack(tile, t));
 	TrackBits bits = TrackToTrackBits(t);
@@ -242,7 +242,7 @@
  * @param tile the tile
  * @param t the track to free
  */
-static inline void UnreserveTrack(TileIndex tile, Track t)
+static INLINE void UnreserveTrack(TileIndex tile, Track t)
 {
 	assert(HasTrack(tile, t));
 	TrackBits res = GetRailReservationTrackBits(tile);
@@ -256,7 +256,7 @@
  * @param t the depot tile
  * @return reservation state
  */
-static inline bool HasDepotReservation(TileIndex t)
+static INLINE bool HasDepotReservation(TileIndex t)
 {
 	assert(IsRailDepot(t));
 	return HasBit(_m[t].m5, 4);
@@ -268,7 +268,7 @@
  * @param t the depot tile
  * @param b the reservation state
  */
-static inline void SetDepotReservation(TileIndex t, bool b)
+static INLINE void SetDepotReservation(TileIndex t, bool b)
 {
 	assert(IsRailDepot(t));
 	SB(_m[t].m5, 4, 1, (byte)b);
@@ -280,25 +280,25 @@
  * @param t the tile
  * @return reserved track bits
  */
-static inline TrackBits GetDepotReservationTrackBits(TileIndex t)
+static INLINE TrackBits GetDepotReservationTrackBits(TileIndex t)
 {
 	return HasDepotReservation(t) ? TrackToTrackBits(GetRailDepotTrack(t)) : TRACK_BIT_NONE;
 }
 
 
-static inline bool IsPbsSignal(SignalType s)
+static INLINE bool IsPbsSignal(SignalType s)
 {
 	return s == SIGTYPE_PBS || s == SIGTYPE_PBS_ONEWAY;
 }
 
-static inline SignalType GetSignalType(TileIndex t, Track track)
+static INLINE SignalType GetSignalType(TileIndex t, Track track)
 {
 	assert(GetRailTileType(t) == RAIL_TILE_SIGNALS);
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 0;
 	return (SignalType)GB(_m[t].m2, pos, 3);
 }
 
-static inline void SetSignalType(TileIndex t, Track track, SignalType s)
+static INLINE void SetSignalType(TileIndex t, Track track, SignalType s)
 {
 	assert(GetRailTileType(t) == RAIL_TILE_SIGNALS);
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 0;
@@ -306,23 +306,23 @@
 	if (track == INVALID_TRACK) SB(_m[t].m2, 4, 3, s);
 }
 
-static inline bool IsPresignalEntry(TileIndex t, Track track)
+static INLINE bool IsPresignalEntry(TileIndex t, Track track)
 {
 	return GetSignalType(t, track) == SIGTYPE_ENTRY || GetSignalType(t, track) == SIGTYPE_COMBO;
 }
 
-static inline bool IsPresignalExit(TileIndex t, Track track)
+static INLINE bool IsPresignalExit(TileIndex t, Track track)
 {
 	return GetSignalType(t, track) == SIGTYPE_EXIT || GetSignalType(t, track) == SIGTYPE_COMBO;
 }
 
 /** One-way signals can't be passed the 'wrong' way. */
-static inline bool IsOnewaySignal(TileIndex t, Track track)
+static INLINE bool IsOnewaySignal(TileIndex t, Track track)
 {
 	return GetSignalType(t, track) != SIGTYPE_PBS;
 }
 
-static inline void CycleSignalSide(TileIndex t, Track track)
+static INLINE void CycleSignalSide(TileIndex t, Track track)
 {
 	byte sig;
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 4 : 6;
@@ -332,13 +332,13 @@
 	SB(_m[t].m3, pos, 2, sig);
 }
 
-static inline SignalVariant GetSignalVariant(TileIndex t, Track track)
+static INLINE SignalVariant GetSignalVariant(TileIndex t, Track track)
 {
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 7 : 3;
 	return (SignalVariant)GB(_m[t].m2, pos, 1);
 }
 
-static inline void SetSignalVariant(TileIndex t, Track track, SignalVariant v)
+static INLINE void SetSignalVariant(TileIndex t, Track track, SignalVariant v)
 {
 	byte pos = (track == TRACK_LOWER || track == TRACK_RIGHT) ? 7 : 3;
 	SB(_m[t].m2, pos, 1, v);
@@ -350,7 +350,7 @@
  * @param tile  the tile to set the states for
  * @param state the new state
  */
-static inline void SetSignalStates(TileIndex tile, uint state)
+static INLINE void SetSignalStates(TileIndex tile, uint state)
 {
 	SB(_m[tile].m4, 4, 4, state);
 }
@@ -360,7 +360,7 @@
  * @param tile  the tile to set the states for
  * @return the state of the signals
  */
-static inline uint GetSignalStates(TileIndex tile)
+static INLINE uint GetSignalStates(TileIndex tile)
 {
 	return GB(_m[tile].m4, 4, 4);
 }
@@ -371,7 +371,7 @@
  * @param signalbit the signal
  * @return the state of the signal
  */
-static inline SignalState GetSingleSignalState(TileIndex t, byte signalbit)
+static INLINE SignalState GetSingleSignalState(TileIndex t, byte signalbit)
 {
 	return (SignalState)HasBit(GetSignalStates(t), signalbit);
 }
@@ -381,7 +381,7 @@
  * @param tile    the tile to set the present signals for
  * @param signals the signals that have to be present
  */
-static inline void SetPresentSignals(TileIndex tile, uint signals)
+static INLINE void SetPresentSignals(TileIndex tile, uint signals)
 {
 	SB(_m[tile].m3, 4, 4, signals);
 }
@@ -391,7 +391,7 @@
  * @param tile the tile to get the present signals for
  * @return the signals that are present
  */
-static inline uint GetPresentSignals(TileIndex tile)
+static INLINE uint GetPresentSignals(TileIndex tile)
 {
 	return GB(_m[tile].m3, 4, 4);
 }
@@ -402,7 +402,7 @@
  * @param signalbit the signal
  * @return true if and only if the signal is present
  */
-static inline bool IsSignalPresent(TileIndex t, byte signalbit)
+static INLINE bool IsSignalPresent(TileIndex t, byte signalbit)
 {
 	return HasBit(GetPresentSignals(t), signalbit);
 }
@@ -411,7 +411,7 @@
  * Checks for the presence of signals (either way) on the given track on the
  * given rail tile.
  */
-static inline bool HasSignalOnTrack(TileIndex tile, Track track)
+static INLINE bool HasSignalOnTrack(TileIndex tile, Track track)
 {
 	assert(IsValidTrack(track));
 	return GetRailTileType(tile) == RAIL_TILE_SIGNALS && (GetPresentSignals(tile) & SignalOnTrack(track)) != 0;
@@ -424,7 +424,7 @@
  * Along meaning if you are currently driving on the given trackdir, this is
  * the signal that is facing us (for which we stop when it's red).
  */
-static inline bool HasSignalOnTrackdir(TileIndex tile, Trackdir trackdir)
+static INLINE bool HasSignalOnTrackdir(TileIndex tile, Trackdir trackdir)
 {
 	assert (IsValidTrackdir(trackdir));
 	return GetRailTileType(tile) == RAIL_TILE_SIGNALS && GetPresentSignals(tile) & SignalAlongTrackdir(trackdir);
@@ -436,7 +436,7 @@
  * Along meaning if you are currently driving on the given trackdir, this is
  * the signal that is facing us (for which we stop when it's red).
  */
-static inline SignalState GetSignalStateByTrackdir(TileIndex tile, Trackdir trackdir)
+static INLINE SignalState GetSignalStateByTrackdir(TileIndex tile, Trackdir trackdir)
 {
 	assert(IsValidTrackdir(trackdir));
 	assert(HasSignalOnTrack(tile, TrackdirToTrack(trackdir)));
@@ -447,7 +447,7 @@
 /**
  * Sets the state of the signal along the given trackdir.
  */
-static inline void SetSignalStateByTrackdir(TileIndex tile, Trackdir trackdir, SignalState state)
+static INLINE void SetSignalStateByTrackdir(TileIndex tile, Trackdir trackdir, SignalState state)
 {
 	if (state == SIGNAL_STATE_GREEN) { // set 1
 		SetSignalStates(tile, GetSignalStates(tile) | SignalAlongTrackdir(trackdir));
@@ -461,7 +461,7 @@
  * @param tile the tile to check
  * @param td the trackdir to check
  */
-static inline bool HasPbsSignalOnTrackdir(TileIndex tile, Trackdir td)
+static INLINE bool HasPbsSignalOnTrackdir(TileIndex tile, Trackdir td)
 {
 	return IsTileType(tile, MP_RAILWAY) && HasSignalOnTrackdir(tile, td) &&
 			IsPbsSignal(GetSignalType(tile, TrackdirToTrack(td)));
@@ -473,7 +473,7 @@
  * @param tile the tile to check
  * @param td the trackdir to check
  */
-static inline bool HasOnewaySignalBlockingTrackdir(TileIndex tile, Trackdir td)
+static INLINE bool HasOnewaySignalBlockingTrackdir(TileIndex tile, Trackdir td)
 {
 	return IsTileType(tile, MP_RAILWAY) && HasSignalOnTrackdir(tile, ReverseTrackdir(td)) &&
 			!HasSignalOnTrackdir(tile, td) && IsOnewaySignal(tile, TrackdirToTrack(td));
@@ -501,23 +501,23 @@
 	RAIL_GROUND_HALF_SNOW    = 14, ///< Snow only on higher part of slope (steep or one corner raised)
 };
 
-static inline void SetRailGroundType(TileIndex t, RailGroundType rgt)
+static INLINE void SetRailGroundType(TileIndex t, RailGroundType rgt)
 {
 	SB(_m[t].m4, 0, 4, rgt);
 }
 
-static inline RailGroundType GetRailGroundType(TileIndex t)
+static INLINE RailGroundType GetRailGroundType(TileIndex t)
 {
 	return (RailGroundType)GB(_m[t].m4, 0, 4);
 }
 
-static inline bool IsSnowRailGround(TileIndex t)
+static INLINE bool IsSnowRailGround(TileIndex t)
 {
 	return GetRailGroundType(t) == RAIL_GROUND_ICE_DESERT;
 }
 
 
-static inline void MakeRailNormal(TileIndex t, Owner o, TrackBits b, RailType r)
+static INLINE void MakeRailNormal(TileIndex t, Owner o, TrackBits b, RailType r)
 {
 	SetTileType(t, MP_RAILWAY);
 	SetTileOwner(t, o);
@@ -530,7 +530,7 @@
 }
 
 
-static inline void MakeRailDepot(TileIndex t, Owner o, DepotID did, DiagDirection d, RailType r)
+static INLINE void MakeRailDepot(TileIndex t, Owner o, DepotID did, DiagDirection d, RailType r)
 {
 	SetTileType(t, MP_RAILWAY);
 	SetTileOwner(t, o);
diff --git a/src/road_func.h b/src/road_func.h
--- a/src/road_func.h
+++ b/src/road_func.h
@@ -32,7 +32,7 @@
  * @param rt the roadtype to check for validness
  * @return true if and only if valid
  */
-static inline bool IsValidRoadType(RoadType rt)
+static INLINE bool IsValidRoadType(RoadType rt)
 {
 	return rt == ROADTYPE_ROAD || rt == ROADTYPE_TRAM;
 }
@@ -43,7 +43,7 @@
  * @param rt the roadtype to get the roadtypes from
  * @return the roadtypes with the given roadtype
  */
-static inline RoadTypes RoadTypeToRoadTypes(RoadType rt)
+static INLINE RoadTypes RoadTypeToRoadTypes(RoadType rt)
 {
 	return (RoadTypes)(1 << rt);
 }
@@ -56,7 +56,7 @@
  * @param r The given RoadTypes
  * @return The complement of the given RoadTypes
  */
-static inline RoadTypes ComplementRoadTypes(RoadTypes r)
+static INLINE RoadTypes ComplementRoadTypes(RoadTypes r)
 {
 	return (RoadTypes)(ROADTYPES_ALL ^ r);
 }
@@ -71,7 +71,7 @@
  * @param r The given RoadBits value
  * @return the complement
  */
-static inline RoadBits ComplementRoadBits(RoadBits r)
+static INLINE RoadBits ComplementRoadBits(RoadBits r)
 {
 	return (RoadBits)(ROAD_ALL ^ r);
 }
@@ -84,7 +84,7 @@
  * @param r The given RoadBits value
  * @return the mirrored
  */
-static inline RoadBits MirrorRoadBits(RoadBits r)
+static INLINE RoadBits MirrorRoadBits(RoadBits r)
 {
 	return (RoadBits)(GB(r, 0, 2) << 2 | GB(r, 2, 2));
 }
@@ -98,7 +98,7 @@
  * @param rot The given Rotation angle
  * @return the rotated
  */
-static inline RoadBits RotateRoadBits(RoadBits r, DiagDirDiff rot)
+static INLINE RoadBits RotateRoadBits(RoadBits r, DiagDirDiff rot)
 {
 	for (; rot > (DiagDirDiff)0; rot--) {
 		r = (RoadBits)(GB(r, 0, 1) << 3 | GB(r, 1, 3));
@@ -112,7 +112,7 @@
  * @param r The given RoadBits
  * @return true if we've got a straight road
  */
-static inline bool IsStraightRoad(RoadBits r)
+static INLINE bool IsStraightRoad(RoadBits r)
 {
 	return (r == ROAD_X || r == ROAD_Y);
 }
@@ -126,7 +126,7 @@
  * @param d The DiagDirection
  * @return The result RoadBits which the selected road-part set
  */
-static inline RoadBits DiagDirToRoadBits(DiagDirection d)
+static INLINE RoadBits DiagDirToRoadBits(DiagDirection d)
 {
 	return (RoadBits)(ROAD_NW << (3 ^ d));
 }
@@ -140,7 +140,7 @@
  * @param a The Axis
  * @return The result RoadBits which the selected road-part set
  */
-static inline RoadBits AxisToRoadBits(Axis a)
+static INLINE RoadBits AxisToRoadBits(Axis a)
 {
 	return a == AXIS_X ? ROAD_X : ROAD_Y;
 }
@@ -152,7 +152,7 @@
  * @param num Number of road bits.
  * @return Total cost.
  */
-static inline Money RoadMaintenanceCost(RoadType roadtype, uint32 num)
+static INLINE Money RoadMaintenanceCost(RoadType roadtype, uint32 num)
 {
 	assert(roadtype < ROADTYPE_END);
 	return (_price[PR_INFRASTRUCTURE_ROAD] * (roadtype == ROADTYPE_TRAM ? 3 : 2) * num * (1 + IntSqrt(num))) >> 9; // 2 bits fraction for the multiplier and 7 bits scaling.
diff --git a/src/road_map.h b/src/road_map.h
--- a/src/road_map.h
+++ b/src/road_map.h
@@ -32,7 +32,7 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return The road tile type.
  */
-static inline RoadTileType GetRoadTileType(TileIndex t)
+static INLINE RoadTileType GetRoadTileType(TileIndex t)
 {
 	assert(IsTileType(t, MP_ROAD));
 	return (RoadTileType)GB(_m[t].m5, 6, 2);
@@ -44,7 +44,7 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if normal road.
  */
-static inline bool IsNormalRoad(TileIndex t)
+static INLINE bool IsNormalRoad(TileIndex t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_NORMAL;
 }
@@ -54,7 +54,7 @@
  * @param t Tile to query.
  * @return True if normal road tile.
  */
-static inline bool IsNormalRoadTile(TileIndex t)
+static INLINE bool IsNormalRoadTile(TileIndex t)
 {
 	return IsTileType(t, MP_ROAD) && IsNormalRoad(t);
 }
@@ -65,7 +65,7 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if level crossing.
  */
-static inline bool IsLevelCrossing(TileIndex t)
+static INLINE bool IsLevelCrossing(TileIndex t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_CROSSING;
 }
@@ -75,7 +75,7 @@
  * @param t Tile to query.
  * @return True if level crossing tile.
  */
-static inline bool IsLevelCrossingTile(TileIndex t)
+static INLINE bool IsLevelCrossingTile(TileIndex t)
 {
 	return IsTileType(t, MP_ROAD) && IsLevelCrossing(t);
 }
@@ -86,7 +86,7 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return True if road depot.
  */
-static inline bool IsRoadDepot(TileIndex t)
+static INLINE bool IsRoadDepot(TileIndex t)
 {
 	return GetRoadTileType(t) == ROAD_TILE_DEPOT;
 }
@@ -96,7 +96,7 @@
  * @param t Tile to query.
  * @return True if road depot tile.
  */
-static inline bool IsRoadDepotTile(TileIndex t)
+static INLINE bool IsRoadDepotTile(TileIndex t)
 {
 	return IsTileType(t, MP_ROAD) && IsRoadDepot(t);
 }
@@ -108,7 +108,7 @@
  * @pre IsNormalRoad(t)
  * @return The present road bits for the road type.
  */
-static inline RoadBits GetRoadBits(TileIndex t, RoadType rt)
+static INLINE RoadBits GetRoadBits(TileIndex t, RoadType rt)
 {
 	assert(IsNormalRoad(t));
 	switch (rt) {
@@ -125,7 +125,7 @@
  * @param rt The RoadType which we exclude from the querry
  * @return all set RoadBits of the tile which are not from the given RoadType
  */
-static inline RoadBits GetOtherRoadBits(TileIndex t, RoadType rt)
+static INLINE RoadBits GetOtherRoadBits(TileIndex t, RoadType rt)
 {
 	return GetRoadBits(t, rt == ROADTYPE_ROAD ? ROADTYPE_TRAM : ROADTYPE_ROAD);
 }
@@ -136,7 +136,7 @@
  * @param tile The tile from which we want to get the RoadBits
  * @return all set RoadBits of the tile
  */
-static inline RoadBits GetAllRoadBits(TileIndex tile)
+static INLINE RoadBits GetAllRoadBits(TileIndex tile)
 {
 	return GetRoadBits(tile, ROADTYPE_ROAD) | GetRoadBits(tile, ROADTYPE_TRAM);
 }
@@ -148,7 +148,7 @@
  * @param rt Road type.
  * @pre IsNormalRoad(t)
  */
-static inline void SetRoadBits(TileIndex t, RoadBits r, RoadType rt)
+static INLINE void SetRoadBits(TileIndex t, RoadBits r, RoadType rt)
 {
 	assert(IsNormalRoad(t)); // XXX incomplete
 	switch (rt) {
@@ -163,7 +163,7 @@
  * @param t The tile to query.
  * @return Present road types.
  */
-static inline RoadTypes GetRoadTypes(TileIndex t)
+static INLINE RoadTypes GetRoadTypes(TileIndex t)
 {
 	return (RoadTypes)GB(_me[t].m7, 6, 2);
 }
@@ -173,7 +173,7 @@
  * @param t  The tile to change.
  * @param rt The new road types.
  */
-static inline void SetRoadTypes(TileIndex t, RoadTypes rt)
+static INLINE void SetRoadTypes(TileIndex t, RoadTypes rt)
 {
 	assert(IsTileType(t, MP_ROAD) || IsTileType(t, MP_STATION) || IsTileType(t, MP_TUNNELBRIDGE));
 	SB(_me[t].m7, 6, 2, rt);
@@ -185,7 +185,7 @@
  * @param rt Road type to check.
  * @return True if the tile has the specified road type.
  */
-static inline bool HasTileRoadType(TileIndex t, RoadType rt)
+static INLINE bool HasTileRoadType(TileIndex t, RoadType rt)
 {
 	return HasBit(GetRoadTypes(t), rt);
 }
@@ -196,7 +196,7 @@
  * @param rt The road type to get the owner of.
  * @return Owner of the given road type.
  */
-static inline Owner GetRoadOwner(TileIndex t, RoadType rt)
+static INLINE Owner GetRoadOwner(TileIndex t, RoadType rt)
 {
 	assert(IsTileType(t, MP_ROAD) || IsTileType(t, MP_STATION) || IsTileType(t, MP_TUNNELBRIDGE));
 	switch (rt) {
@@ -217,7 +217,7 @@
  * @param rt The road type to change the owner of.
  * @param o  New owner of the given road type.
  */
-static inline void SetRoadOwner(TileIndex t, RoadType rt, Owner o)
+static INLINE void SetRoadOwner(TileIndex t, RoadType rt, Owner o)
 {
 	switch (rt) {
 		default: NOT_REACHED();
@@ -234,7 +234,7 @@
  * @pre HasTileRoadType(t, rt)
  * @return True if the road type is owned by the given owner.
  */
-static inline bool IsRoadOwner(TileIndex t, RoadType rt, Owner o)
+static INLINE bool IsRoadOwner(TileIndex t, RoadType rt, Owner o)
 {
 	assert(HasTileRoadType(t, rt));
 	return (GetRoadOwner(t, rt) == o);
@@ -246,7 +246,7 @@
  * @pre IsTileType(t, MP_ROAD)
  * @return true iff tile has road and the road is owned by a town
  */
-static inline bool HasTownOwnedRoad(TileIndex t)
+static INLINE bool HasTownOwnedRoad(TileIndex t)
 {
 	return HasTileRoadType(t, ROADTYPE_ROAD) && IsRoadOwner(t, ROADTYPE_ROAD, OWNER_TOWN);
 }
@@ -268,7 +268,7 @@
  * @param t the tile to get the directions from
  * @return the disallowed directions
  */
-static inline DisallowedRoadDirections GetDisallowedRoadDirections(TileIndex t)
+static INLINE DisallowedRoadDirections GetDisallowedRoadDirections(TileIndex t)
 {
 	assert(IsNormalRoad(t));
 	return (DisallowedRoadDirections)GB(_m[t].m5, 4, 2);
@@ -279,7 +279,7 @@
  * @param t   the tile to set the directions for
  * @param drd the disallowed directions
  */
-static inline void SetDisallowedRoadDirections(TileIndex t, DisallowedRoadDirections drd)
+static INLINE void SetDisallowedRoadDirections(TileIndex t, DisallowedRoadDirections drd)
 {
 	assert(IsNormalRoad(t));
 	assert(drd < DRD_END);
@@ -292,7 +292,7 @@
  * @pre IsLevelCrossing(t)
  * @return The axis of the road.
  */
-static inline Axis GetCrossingRoadAxis(TileIndex t)
+static INLINE Axis GetCrossingRoadAxis(TileIndex t)
 {
 	assert(IsLevelCrossing(t));
 	return (Axis)GB(_m[t].m5, 0, 1);
@@ -304,7 +304,7 @@
  * @pre IsLevelCrossing(t)
  * @return The axis of the rail.
  */
-static inline Axis GetCrossingRailAxis(TileIndex t)
+static INLINE Axis GetCrossingRailAxis(TileIndex t)
 {
 	assert(IsLevelCrossing(t));
 	return OtherAxis((Axis)GetCrossingRoadAxis(t));
@@ -315,7 +315,7 @@
  * @param tile The tile to query.
  * @return The present road bits.
  */
-static inline RoadBits GetCrossingRoadBits(TileIndex tile)
+static INLINE RoadBits GetCrossingRoadBits(TileIndex tile)
 {
 	return GetCrossingRoadAxis(tile) == AXIS_X ? ROAD_X : ROAD_Y;
 }
@@ -325,7 +325,7 @@
  * @param tile The tile to query.
  * @return The rail track.
  */
-static inline Track GetCrossingRailTrack(TileIndex tile)
+static INLINE Track GetCrossingRailTrack(TileIndex tile)
 {
 	return AxisToTrack(GetCrossingRailAxis(tile));
 }
@@ -335,7 +335,7 @@
  * @param tile The tile to query.
  * @return The rail track bits.
  */
-static inline TrackBits GetCrossingRailBits(TileIndex tile)
+static INLINE TrackBits GetCrossingRailBits(TileIndex tile)
 {
 	return AxisToTrackBits(GetCrossingRailAxis(tile));
 }
@@ -347,7 +347,7 @@
  * @return reservation state
  * @pre IsLevelCrossingTile(t)
  */
-static inline bool HasCrossingReservation(TileIndex t)
+static INLINE bool HasCrossingReservation(TileIndex t)
 {
 	assert(IsLevelCrossingTile(t));
 	return HasBit(_m[t].m5, 4);
@@ -360,7 +360,7 @@
  * @param b the reservation state
  * @pre IsLevelCrossingTile(t)
  */
-static inline void SetCrossingReservation(TileIndex t, bool b)
+static INLINE void SetCrossingReservation(TileIndex t, bool b)
 {
 	assert(IsLevelCrossingTile(t));
 	SB(_m[t].m5, 4, 1, b ? 1 : 0);
@@ -372,7 +372,7 @@
  * @pre IsLevelCrossingTile(t)
  * @return reserved track bits
  */
-static inline TrackBits GetCrossingReservationTrackBits(TileIndex t)
+static INLINE TrackBits GetCrossingReservationTrackBits(TileIndex t)
 {
 	return HasCrossingReservation(t) ? GetCrossingRailBits(t) : TRACK_BIT_NONE;
 }
@@ -383,7 +383,7 @@
  * @pre IsLevelCrossing(t)
  * @return True if the level crossing is barred.
  */
-static inline bool IsCrossingBarred(TileIndex t)
+static INLINE bool IsCrossingBarred(TileIndex t)
 {
 	assert(IsLevelCrossing(t));
 	return HasBit(_m[t].m5, 5);
@@ -395,7 +395,7 @@
  * @param barred True if the crossing should be barred, false otherwise.
  * @pre IsLevelCrossing(t)
  */
-static inline void SetCrossingBarred(TileIndex t, bool barred)
+static INLINE void SetCrossingBarred(TileIndex t, bool barred)
 {
 	assert(IsLevelCrossing(t));
 	SB(_m[t].m5, 5, 1, barred ? 1 : 0);
@@ -405,7 +405,7 @@
  * Unbar a level crossing.
  * @param t The tile to change.
  */
-static inline void UnbarCrossing(TileIndex t)
+static INLINE void UnbarCrossing(TileIndex t)
 {
 	SetCrossingBarred(t, false);
 }
@@ -414,7 +414,7 @@
  * Bar a level crossing.
  * @param t The tile to change.
  */
-static inline void BarCrossing(TileIndex t)
+static INLINE void BarCrossing(TileIndex t)
 {
 	SetCrossingBarred(t, true);
 }
@@ -426,7 +426,7 @@
  * @param t The tile to query.
  * @return True if the tile has snow/desert.
  */
-static inline bool IsOnSnow(TileIndex t)
+static INLINE bool IsOnSnow(TileIndex t)
 {
 	return HasBit(_me[t].m7, 5);
 }
@@ -437,7 +437,7 @@
  * Toggle the snow/desert state of a road tile.
  * @param t The tile to change.
  */
-static inline void ToggleSnow(TileIndex t)
+static INLINE void ToggleSnow(TileIndex t)
 {
 	ToggleBit(_me[t].m7, 5);
 }
@@ -459,7 +459,7 @@
  * @param tile The tile to query.
  * @return The road decoration of the tile.
  */
-static inline Roadside GetRoadside(TileIndex tile)
+static INLINE Roadside GetRoadside(TileIndex tile)
 {
 	return (Roadside)GB(_m[tile].m6, 3, 3);
 }
@@ -469,7 +469,7 @@
  * @param tile The tile to change.
  * @param s    The new road decoration of the tile.
  */
-static inline void SetRoadside(TileIndex tile, Roadside s)
+static INLINE void SetRoadside(TileIndex tile, Roadside s)
 {
 	SB(_m[tile].m6, 3, 3, s);
 }
@@ -479,7 +479,7 @@
  * @param t The tile to check.
  * @return True if the tile has road works in progress.
  */
-static inline bool HasRoadWorks(TileIndex t)
+static INLINE bool HasRoadWorks(TileIndex t)
 {
 	return GetRoadside(t) >= ROADSIDE_GRASS_ROAD_WORKS;
 }
@@ -489,7 +489,7 @@
  * @param t The tile to modify.
  * @return True if the road works are in the last stage.
  */
-static inline bool IncreaseRoadWorksCounter(TileIndex t)
+static INLINE bool IncreaseRoadWorksCounter(TileIndex t)
 {
 	AB(_me[t].m7, 0, 4, 1);
 
@@ -501,7 +501,7 @@
  * @param t The tile to start the work on.
  * @pre !HasRoadWorks(t)
  */
-static inline void StartRoadWorks(TileIndex t)
+static INLINE void StartRoadWorks(TileIndex t)
 {
 	assert(!HasRoadWorks(t));
 	/* Remove any trees or lamps in case or roadwork */
@@ -517,7 +517,7 @@
  * @param t Tile to stop the road works on.
  * @pre HasRoadWorks(t)
  */
-static inline void TerminateRoadWorks(TileIndex t)
+static INLINE void TerminateRoadWorks(TileIndex t)
 {
 	assert(HasRoadWorks(t));
 	SetRoadside(t, (Roadside)(GetRoadside(t) - ROADSIDE_GRASS_ROAD_WORKS + ROADSIDE_GRASS));
@@ -531,7 +531,7 @@
  * @param t The tile to query.
  * @return Diagonal direction of the depot exit.
  */
-static inline DiagDirection GetRoadDepotDirection(TileIndex t)
+static INLINE DiagDirection GetRoadDepotDirection(TileIndex t)
 {
 	assert(IsRoadDepot(t));
 	return (DiagDirection)GB(_m[t].m5, 0, 2);
@@ -550,7 +550,7 @@
  * @param road New owner of road.
  * @param tram New owner of tram tracks.
  */
-static inline void MakeRoadNormal(TileIndex t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram)
+static INLINE void MakeRoadNormal(TileIndex t, RoadBits bits, RoadTypes rot, TownID town, Owner road, Owner tram)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, road);
@@ -574,7 +574,7 @@
  * @param rot     New present road types.
  * @param town    Town ID if the road is a town-owned road.
  */
-static inline void MakeRoadCrossing(TileIndex t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town)
+static INLINE void MakeRoadCrossing(TileIndex t, Owner road, Owner tram, Owner rail, Axis roaddir, RailType rat, RoadTypes rot, uint town)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, rail);
@@ -595,7 +595,7 @@
  * @param dir   Direction of the depot exit.
  * @param rt    Road type of the depot.
  */
-static inline void MakeRoadDepot(TileIndex t, Owner owner, DepotID did, DiagDirection dir, RoadType rt)
+static INLINE void MakeRoadDepot(TileIndex t, Owner owner, DepotID did, DiagDirection dir, RoadType rt)
 {
 	SetTileType(t, MP_ROAD);
 	SetTileOwner(t, owner);
diff --git a/src/roadstop_base.h b/src/roadstop_base.h
--- a/src/roadstop_base.h
+++ b/src/roadstop_base.h
@@ -46,7 +46,7 @@
 		 * Get the length of this drive through stop.
 		 * @return the length in tile units.
 		 */
-		inline int GetLength() const
+		INLINE int GetLength() const
 		{
 			return this->length;
 		}
@@ -55,7 +55,7 @@
 		 * Get the amount of occupied space in this drive through stop.
 		 * @return the occupied space in tile units.
 		 */
-		inline int GetOccupied() const
+		INLINE int GetOccupied() const
 		{
 			return this->occupied;
 		}
@@ -71,7 +71,7 @@
 	struct RoadStop *next;  ///< Next stop of the given type at this station
 
 	/** Initializes a RoadStop */
-	inline RoadStop(TileIndex tile = INVALID_TILE) :
+	INLINE RoadStop(TileIndex tile = INVALID_TILE) :
 		xy(tile),
 		status((1 << RSSFB_BAY_COUNT) - 1)
 	{ }
@@ -82,7 +82,7 @@
 	 * Checks whether there is a free bay in this road stop
 	 * @return is at least one bay free?
 	 */
-	inline bool HasFreeBay() const
+	INLINE bool HasFreeBay() const
 	{
 		return GB(this->status, 0, RSSFB_BAY_COUNT) != 0;
 	}
@@ -92,7 +92,7 @@
 	 * @param nr bay to check
 	 * @return is given bay free?
 	 */
-	inline bool IsFreeBay(uint nr) const
+	INLINE bool IsFreeBay(uint nr) const
 	{
 		assert(nr < RSSFB_BAY_COUNT);
 		return HasBit(this->status, nr);
@@ -102,7 +102,7 @@
 	 * Checks whether the entrance of the road stop is occupied by a vehicle
 	 * @return is entrance busy?
 	 */
-	inline bool IsEntranceBusy() const
+	INLINE bool IsEntranceBusy() const
 	{
 		return HasBit(this->status, RSSFB_ENTRY_BUSY);
 	}
@@ -111,7 +111,7 @@
 	 * Makes an entrance occupied or free
 	 * @param busy If true, marks busy; free otherwise.
 	 */
-	inline void SetEntranceBusy(bool busy)
+	INLINE void SetEntranceBusy(bool busy)
 	{
 		SB(this->status, RSSFB_ENTRY_BUSY, 1, busy);
 	}
@@ -121,7 +121,7 @@
 	 * @param dir The direction to get the entry for.
 	 * @return the entry
 	 */
-	inline const Entry *GetEntry(DiagDirection dir) const
+	INLINE const Entry *GetEntry(DiagDirection dir) const
 	{
 		return HasBit((int)dir, 1) ? this->west : this->east;
 	}
@@ -131,7 +131,7 @@
 	 * @param dir The direction to get the entry for.
 	 * @return the entry
 	 */
-	inline Entry *GetEntry(DiagDirection dir)
+	INLINE Entry *GetEntry(DiagDirection dir)
 	{
 		return HasBit((int)dir, 1) ? this->west : this->east;
 	}
@@ -157,7 +157,7 @@
 	 * @return the allocated bay number
 	 * @pre this->HasFreeBay()
 	 */
-	inline uint AllocateBay()
+	INLINE uint AllocateBay()
 	{
 		assert(this->HasFreeBay());
 
@@ -173,7 +173,7 @@
 	 * Allocates a bay in a drive-through road stop
 	 * @param nr the number of the bay to allocate
 	 */
-	inline void AllocateDriveThroughBay(uint nr)
+	INLINE void AllocateDriveThroughBay(uint nr)
 	{
 		assert(nr < RSSFB_BAY_COUNT);
 		ClrBit(this->status, nr);
@@ -183,7 +183,7 @@
 	 * Frees the given bay
 	 * @param nr the number of the bay to free
 	 */
-	inline void FreeBay(uint nr)
+	INLINE void FreeBay(uint nr)
 	{
 		assert(nr < RSSFB_BAY_COUNT);
 		SetBit(this->status, nr);
diff --git a/src/roadveh.h b/src/roadveh.h
--- a/src/roadveh.h
+++ b/src/roadveh.h
@@ -131,7 +131,7 @@
 	 * Allows to know the power value that this vehicle will use.
 	 * @return Power value from the engine in HP, or zero if the vehicle is not powered.
 	 */
-	inline uint16 GetPower() const
+	INLINE uint16 GetPower() const
 	{
 		/* Power is not added for articulated parts */
 		if (!this->IsArticulatedPart()) {
@@ -145,7 +145,7 @@
 	 * Returns a value if this articulated part is powered.
 	 * @return Zero, because road vehicles don't have powered parts.
 	 */
-	inline uint16 GetPoweredPartPower(const RoadVehicle *head) const
+	INLINE uint16 GetPoweredPartPower(const RoadVehicle *head) const
 	{
 		return 0;
 	}
@@ -154,7 +154,7 @@
 	 * Allows to know the weight value that this vehicle will use.
 	 * @return Weight value from the engine in tonnes.
 	 */
-	inline uint16 GetWeight() const
+	INLINE uint16 GetWeight() const
 	{
 		uint16 weight = (CargoSpec::Get(this->cargo_type)->weight * this->cargo.Count()) / 16;
 
@@ -171,7 +171,7 @@
 	 * Allows to know the tractive effort value that this vehicle will use.
 	 * @return Tractive effort value from the engine.
 	 */
-	inline byte GetTractiveEffort() const
+	INLINE byte GetTractiveEffort() const
 	{
 		/* The tractive effort coefficient is in units of 1/256.  */
 		return GetVehicleProperty(this, PROP_ROADVEH_TRACTIVE_EFFORT, RoadVehInfo(this->engine_type)->tractive_effort);
@@ -181,7 +181,7 @@
 	 * Gets the area used for calculating air drag.
 	 * @return Area of the engine in m^2.
 	 */
-	inline byte GetAirDragArea() const
+	INLINE byte GetAirDragArea() const
 	{
 		return 6;
 	}
@@ -190,7 +190,7 @@
 	 * Gets the air drag coefficient of this vehicle.
 	 * @return Air drag value from the engine.
 	 */
-	inline byte GetAirDrag() const
+	INLINE byte GetAirDrag() const
 	{
 		return RoadVehInfo(this->engine_type)->air_drag;
 	}
@@ -199,7 +199,7 @@
 	 * Checks the current acceleration status of this vehicle.
 	 * @return Acceleration status.
 	 */
-	inline AccelStatus GetAccelerationStatus() const
+	INLINE AccelStatus GetAccelerationStatus() const
 	{
 		return (this->vehstatus & VS_STOPPED) ? AS_BRAKE : AS_ACCEL;
 	}
@@ -208,7 +208,7 @@
 	 * Calculates the current speed of this vehicle.
 	 * @return Current speed in km/h-ish.
 	 */
-	inline uint16 GetCurrentSpeed() const
+	INLINE uint16 GetCurrentSpeed() const
 	{
 		return this->cur_speed / 2;
 	}
@@ -217,7 +217,7 @@
 	 * Returns the rolling friction coefficient of this vehicle.
 	 * @return Rolling friction coefficient in [1e-4].
 	 */
-	inline uint32 GetRollingFriction() const
+	INLINE uint32 GetRollingFriction() const
 	{
 		/* Trams have a slightly greater friction coefficient than trains.
 		 * The rest of road vehicles have bigger values. */
@@ -231,7 +231,7 @@
 	 * Allows to know the acceleration type of a vehicle.
 	 * @return Zero, road vehicles always use a normal acceleration method.
 	 */
-	inline int GetAccelerationType() const
+	INLINE int GetAccelerationType() const
 	{
 		return 0;
 	}
@@ -240,7 +240,7 @@
 	 * Returns the slope steepness used by this vehicle.
 	 * @return Slope steepness used by the vehicle.
 	 */
-	inline uint32 GetSlopeSteepness() const
+	INLINE uint32 GetSlopeSteepness() const
 	{
 		return _settings_game.vehicle.roadveh_slope_steepness;
 	}
@@ -249,7 +249,7 @@
 	 * Gets the maximum speed allowed by the track for this vehicle.
 	 * @return Since roads don't limit road vehicle speed, it returns always zero.
 	 */
-	inline uint16 GetMaxTrackSpeed() const
+	INLINE uint16 GetMaxTrackSpeed() const
 	{
 		return 0;
 	}
@@ -258,7 +258,7 @@
 	 * Checks if the vehicle is at a tile that can be sloped.
 	 * @return True if the tile can be sloped.
 	 */
-	inline bool TileMayHaveSlopedTrack() const
+	INLINE bool TileMayHaveSlopedTrack() const
 	{
 		TrackStatus ts = GetTileTrackStatus(this->tile, TRANSPORT_ROAD, this->compatible_roadtypes);
 		TrackBits trackbits = TrackStatusToTrackBits(ts);
@@ -273,7 +273,7 @@
 	 * even if it is not reversing.
 	 * @return are we (possibly) reversing?
 	 */
-	inline bool HasToUseGetSlopePixelZ()
+	INLINE bool HasToUseGetSlopePixelZ()
 	{
 		const RoadVehicle *rv = this->First();
 
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -407,7 +407,7 @@
  * Calculates the maximum speed of the vehicle under its current conditions.
  * @return Maximum speed of the vehicle.
  */
-inline int RoadVehicle::GetCurrentMaxSpeed() const
+INLINE int RoadVehicle::GetCurrentMaxSpeed() const
 {
 	if (_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL) return min(this->vcache.cached_max_speed, this->current_order.max_speed * 2);
 
@@ -1420,7 +1420,7 @@
 			if (IsDriveThroughStopTile(v->tile)) {
 				TileIndex next_tile = TILE_ADD(v->tile, TileOffsByDir(v->direction));
 
-				/* Check if next inline bay is free and has compatible road. */
+				/* Check if next INLINE bay is free and has compatible road. */
 				if (RoadStop::IsDriveThroughRoadStopContinuation(v->tile, next_tile) && (GetRoadTypes(next_tile) & v->compatible_roadtypes) != 0) {
 					v->frame++;
 					v->x_pos = x;
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -204,7 +204,7 @@
 	for (i = 0; i < MapSizeX(); ++i) MakeVoid(MapSizeX() * MapMaxY() + i);
 }
 
-static inline RailType UpdateRailType(RailType rt, RailType min)
+static INLINE RailType UpdateRailType(RailType rt, RailType min)
 {
 	return rt >= min ? (RailType)(rt + 1): rt;
 }
diff --git a/src/saveload/oldloader.cpp b/src/saveload/oldloader.cpp
--- a/src/saveload/oldloader.cpp
+++ b/src/saveload/oldloader.cpp
@@ -28,11 +28,11 @@
 
 uint32 _bump_assert_value;
 
-static inline OldChunkType GetOldChunkType(OldChunkType type)     {return (OldChunkType)GB(type, 0, 4);}
-static inline OldChunkType GetOldChunkVarType(OldChunkType type)  {return (OldChunkType)(GB(type, 8, 8) << 8);}
-static inline OldChunkType GetOldChunkFileType(OldChunkType type) {return (OldChunkType)(GB(type, 16, 8) << 16);}
+static INLINE OldChunkType GetOldChunkType(OldChunkType type)     {return (OldChunkType)GB(type, 0, 4);}
+static INLINE OldChunkType GetOldChunkVarType(OldChunkType type)  {return (OldChunkType)(GB(type, 8, 8) << 8);}
+static INLINE OldChunkType GetOldChunkFileType(OldChunkType type) {return (OldChunkType)(GB(type, 16, 8) << 16);}
 
-static inline byte CalcOldVarLen(OldChunkType type)
+static INLINE byte CalcOldVarLen(OldChunkType type)
 {
 	static const byte type_mem_size[] = {0, 1, 1, 2, 2, 4, 4, 8};
 	byte length = GB(type, 8, 8);
@@ -225,7 +225,7 @@
 	return sum == sum2;
 }
 
-static inline bool CheckOldSavegameType(FILE *f, char *temp, const char *last, uint len)
+static INLINE bool CheckOldSavegameType(FILE *f, char *temp, const char *last, uint len)
 {
 	assert(last - temp + 1 >= (int)len);
 
diff --git a/src/saveload/oldloader.h b/src/saveload/oldloader.h
--- a/src/saveload/oldloader.h
+++ b/src/saveload/oldloader.h
@@ -104,13 +104,13 @@
 bool LoadTTDMain(LoadgameState *ls);
 bool LoadTTOMain(LoadgameState *ls);
 
-static inline uint16 ReadUint16(LoadgameState *ls)
+static INLINE uint16 ReadUint16(LoadgameState *ls)
 {
 	byte x = ReadByte(ls);
 	return x | ReadByte(ls) << 8;
 }
 
-static inline uint32 ReadUint32(LoadgameState *ls)
+static INLINE uint32 ReadUint32(LoadgameState *ls)
 {
 	uint16 x = ReadUint16(ls);
 	return x | ReadUint16(ls) << 16;
diff --git a/src/saveload/oldloader_sl.cpp b/src/saveload/oldloader_sl.cpp
--- a/src/saveload/oldloader_sl.cpp
+++ b/src/saveload/oldloader_sl.cpp
@@ -461,7 +461,7 @@
 	}
 }
 
-static inline byte RemapTTOColour(byte tto)
+static INLINE byte RemapTTOColour(byte tto)
 {
 	/** Lossy remapping of TTO colours to TTD colours. SVXConverter uses the same conversion. */
 	static const byte tto_colour_remap[] = {
@@ -476,12 +476,12 @@
 	return tto_colour_remap[tto];
 }
 
-static inline uint RemapTownIndex(uint x)
+static INLINE uint RemapTownIndex(uint x)
 {
 	return _savegame_type == SGT_TTO ? (x - 0x264) / 78 : (x - 0x264) / 94;
 }
 
-static inline uint RemapOrderIndex(uint x)
+static INLINE uint RemapOrderIndex(uint x)
 {
 	return _savegame_type == SGT_TTO ? (x - 0x1AC4) / 2 : (x - 0x1C18) / 2;
 }
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -286,7 +286,7 @@
 	{
 	}
 
-	inline byte ReadByte()
+	INLINE byte ReadByte()
 	{
 		if (this->bufp == this->bufe) {
 			size_t len = this->reader->Read(this->buf, lengthof(this->buf));
@@ -326,7 +326,7 @@
 	 * Write a single byte into the dumper.
 	 * @param b The byte to write.
 	 */
-	inline void WriteByte(byte b)
+	INLINE void WriteByte(byte b)
 	{
 		/* Are we at the end of this chunk? */
 		if (this->buf == this->bufe) {
@@ -587,38 +587,38 @@
 	_sl.dumper->WriteByte(b);
 }
 
-static inline int SlReadUint16()
+static INLINE int SlReadUint16()
 {
 	int x = SlReadByte() << 8;
 	return x | SlReadByte();
 }
 
-static inline uint32 SlReadUint32()
+static INLINE uint32 SlReadUint32()
 {
 	uint32 x = SlReadUint16() << 16;
 	return x | SlReadUint16();
 }
 
-static inline uint64 SlReadUint64()
+static INLINE uint64 SlReadUint64()
 {
 	uint32 x = SlReadUint32();
 	uint32 y = SlReadUint32();
 	return (uint64)x << 32 | y;
 }
 
-static inline void SlWriteUint16(uint16 v)
+static INLINE void SlWriteUint16(uint16 v)
 {
 	SlWriteByte(GB(v, 8, 8));
 	SlWriteByte(GB(v, 0, 8));
 }
 
-static inline void SlWriteUint32(uint32 v)
+static INLINE void SlWriteUint32(uint32 v)
 {
 	SlWriteUint16(GB(v, 16, 16));
 	SlWriteUint16(GB(v,  0, 16));
 }
 
-static inline void SlWriteUint64(uint64 x)
+static INLINE void SlWriteUint64(uint64 x)
 {
 	SlWriteUint32((uint32)(x >> 32));
 	SlWriteUint32((uint32)x);
@@ -629,7 +629,7 @@
  * anything with them, discarding them in effect
  * @param length The amount of bytes that is being treated this way
  */
-static inline void SlSkipBytes(size_t length)
+static INLINE void SlSkipBytes(size_t length)
 {
 	for (; length != 0; length--) SlReadByte();
 }
@@ -696,32 +696,32 @@
 }
 
 /** Return how many bytes used to encode a gamma value */
-static inline uint SlGetGammaLength(size_t i)
+static INLINE uint SlGetGammaLength(size_t i)
 {
 	return 1 + (i >= (1 << 7)) + (i >= (1 << 14)) + (i >= (1 << 21));
 }
 
-static inline uint SlReadSparseIndex()
+static INLINE uint SlReadSparseIndex()
 {
 	return SlReadSimpleGamma();
 }
 
-static inline void SlWriteSparseIndex(uint index)
+static INLINE void SlWriteSparseIndex(uint index)
 {
 	SlWriteSimpleGamma(index);
 }
 
-static inline uint SlReadArrayLength()
+static INLINE uint SlReadArrayLength()
 {
 	return SlReadSimpleGamma();
 }
 
-static inline void SlWriteArrayLength(size_t length)
+static INLINE void SlWriteArrayLength(size_t length)
 {
 	SlWriteSimpleGamma(length);
 }
 
-static inline uint SlGetArrayLength(size_t length)
+static INLINE uint SlGetArrayLength(size_t length)
 {
 	return SlGetGammaLength(length);
 }
@@ -732,7 +732,7 @@
  * @param conv VarType type of variable that is used for calculating the size
  * @return Return the size of this type in bytes
  */
-static inline uint SlCalcConvMemLen(VarType conv)
+static INLINE uint SlCalcConvMemLen(VarType conv)
 {
 	static const byte conv_mem_size[] = {1, 1, 1, 2, 2, 4, 4, 8, 8, 0};
 	byte length = GB(conv, 4, 4);
@@ -756,7 +756,7 @@
  * @param conv VarType type of variable that is used for calculating the size
  * @return Return the size of this type in bytes
  */
-static inline byte SlCalcConvFileLen(VarType conv)
+static INLINE byte SlCalcConvFileLen(VarType conv)
 {
 	static const byte conv_file_size[] = {1, 1, 2, 2, 4, 4, 8, 8, 2};
 	byte length = GB(conv, 0, 4);
@@ -765,7 +765,7 @@
 }
 
 /** Return the size in bytes of a reference (pointer) */
-static inline size_t SlCalcRefLen()
+static INLINE size_t SlCalcRefLen()
 {
 	return IsSavegameVersionBefore(69) ? 2 : 4;
 }
@@ -1007,7 +1007,7 @@
  * about a maximum length, but take string length as it is.
  * @return return the net length of the string
  */
-static inline size_t SlCalcNetStringLen(const char *ptr, size_t length)
+static INLINE size_t SlCalcNetStringLen(const char *ptr, size_t length)
 {
 	if (ptr == NULL) return 0;
 	return min(strlen(ptr), length - 1);
@@ -1022,7 +1022,7 @@
  * @param conv type of data been used
  * @return return the gross length of the string
  */
-static inline size_t SlCalcStringLen(const void *ptr, size_t length, VarType conv)
+static INLINE size_t SlCalcStringLen(const void *ptr, size_t length, VarType conv)
 {
 	size_t len;
 	const char *str;
@@ -1129,7 +1129,7 @@
  * @param length The length of the array counted in elements
  * @param conv VarType type of the variable that is used in calculating the size
  */
-static inline size_t SlCalcArrayLen(size_t length, VarType conv)
+static INLINE size_t SlCalcArrayLen(size_t length, VarType conv)
 {
 	return SlCalcConvFileLen(conv) * length;
 }
@@ -1293,7 +1293,7 @@
  * Return the size in bytes of a list
  * @param list The std::list to find the size of
  */
-static inline size_t SlCalcListLen(const void *list)
+static INLINE size_t SlCalcListLen(const void *list)
 {
 	const std::list<void *> *l = (const std::list<void *> *) list;
 
@@ -1363,7 +1363,7 @@
 
 
 /** Are we going to save this object or not? */
-static inline bool SlIsObjectValidInSavegame(const SaveLoad *sld)
+static INLINE bool SlIsObjectValidInSavegame(const SaveLoad *sld)
 {
 	if (_sl_version < sld->version_from || _sl_version > sld->version_to) return false;
 	if (sld->conv & SLF_NOT_IN_SAVE) return false;
@@ -1376,7 +1376,7 @@
  * @note If the variable is skipped it is skipped in the savegame
  * bytestream itself as well, so there is no need to skip it somewhere else
  */
-static inline bool SlSkipVariableOnLoad(const SaveLoad *sld)
+static INLINE bool SlSkipVariableOnLoad(const SaveLoad *sld)
 {
 	if ((sld->conv & SLF_NO_NETWORK_SYNC) && _sl.action != SLA_SAVE && _networking && !_network_server) {
 		SlSkipBytes(SlCalcConvMemLen(sld->conv) * sld->length);
@@ -1658,7 +1658,7 @@
  * Actually call the intended chunk handler.
  * @param arg ignored parameter.
  */
-static inline void SlStubSaveProc2(void *arg)
+static INLINE void SlStubSaveProc2(void *arg)
 {
 	_stub_save_proc();
 }
@@ -2341,7 +2341,7 @@
 /**
  * Clear/free saveload state.
  */
-static inline void ClearSaveLoadState()
+static INLINE void ClearSaveLoadState()
 {
 	delete _sl.dumper;
 	_sl.dumper = NULL;
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -454,7 +454,7 @@
  * @param minor Minor number of the version to check against. If \a minor is 0 or not specified, only the major number is checked.
  * @return Savegame version is earlier than the specified version.
  */
-static inline bool IsSavegameVersionBefore(uint16 major, byte minor = 0)
+static INLINE bool IsSavegameVersionBefore(uint16 major, byte minor = 0)
 {
 	extern uint16 _sl_version;
 	extern byte   _sl_minor_version;
@@ -468,7 +468,7 @@
  * @param version_to   Highest version number that falls within the range.
  * @return Active savegame version falls within the given range.
  */
-static inline bool SlIsObjectCurrentlyValid(uint16 version_from, uint16 version_to)
+static INLINE bool SlIsObjectCurrentlyValid(uint16 version_from, uint16 version_to)
 {
 	extern const uint16 SAVEGAME_VERSION;
 	if (SAVEGAME_VERSION < version_from || SAVEGAME_VERSION > version_to) return false;
@@ -482,7 +482,7 @@
  * @param type VarType holding information about the variable-type
  * @return return the SLE_VAR_* part of a variable-type description
  */
-static inline VarType GetVarMemType(VarType type)
+static INLINE VarType GetVarMemType(VarType type)
 {
 	return type & 0xF0; // GB(type, 4, 4) << 4;
 }
@@ -493,7 +493,7 @@
  * @param type VarType holding information about the file-type
  * @param return the SLE_FILE_* part of a variable-type description
  */
-static inline VarType GetVarFileType(VarType type)
+static INLINE VarType GetVarFileType(VarType type)
 {
 	return type & 0xF; // GB(type, 0, 4);
 }
@@ -503,7 +503,7 @@
  * @param conv the type to check
  * @return True if it's a numeric type.
  */
-static inline bool IsNumericType(VarType conv)
+static INLINE bool IsNumericType(VarType conv)
 {
 	return GetVarMemType(conv) <= SLE_VAR_U64;
 }
@@ -514,7 +514,7 @@
  * is taken. If non-null only the offset is stored in the union and we need
  * to add this to the address of the object
  */
-static inline void *GetVariableAddress(const void *object, const SaveLoad *sld)
+static INLINE void *GetVariableAddress(const void *object, const SaveLoad *sld)
 {
 	return const_cast<byte *>((const byte*)(sld->global ? NULL : object) + (ptrdiff_t)sld->address);
 }
diff --git a/src/script/script_instance.hpp b/src/script/script_instance.hpp
--- a/src/script/script_instance.hpp
+++ b/src/script/script_instance.hpp
@@ -115,7 +115,7 @@
 	/**
 	 * Return the "this script died" value
 	 */
-	inline bool IsDead() const { return this->is_dead; }
+	INLINE bool IsDead() const { return this->is_dead; }
 
 	/**
 	 * Call the script Save function and save all data in the savegame.
diff --git a/src/script/squirrel_helper.hpp b/src/script/squirrel_helper.hpp
--- a/src/script/squirrel_helper.hpp
+++ b/src/script/squirrel_helper.hpp
@@ -79,34 +79,34 @@
 	 */
 	template <typename T> static int Return(HSQUIRRELVM vm, T t);
 
-	template <> inline int Return<uint8>       (HSQUIRRELVM vm, uint8 res)       { sq_pushinteger(vm, (int32)res); return 1; }
-	template <> inline int Return<uint16>      (HSQUIRRELVM vm, uint16 res)      { sq_pushinteger(vm, (int32)res); return 1; }
-	template <> inline int Return<uint32>      (HSQUIRRELVM vm, uint32 res)      { sq_pushinteger(vm, (int32)res); return 1; }
-	template <> inline int Return<int8>        (HSQUIRRELVM vm, int8 res)        { sq_pushinteger(vm, res); return 1; }
-	template <> inline int Return<int16>       (HSQUIRRELVM vm, int16 res)       { sq_pushinteger(vm, res); return 1; }
-	template <> inline int Return<int32>       (HSQUIRRELVM vm, int32 res)       { sq_pushinteger(vm, res); return 1; }
-	template <> inline int Return<int64>       (HSQUIRRELVM vm, int64 res)       { sq_pushinteger(vm, ClampToI32(res)); return 1; }
-	template <> inline int Return<Money>       (HSQUIRRELVM vm, Money res)       { sq_pushinteger(vm, ClampToI32(res)); return 1; }
-	template <> inline int Return<bool>        (HSQUIRRELVM vm, bool res)        { sq_pushbool   (vm, res); return 1; }
-	template <> inline int Return<char *>      (HSQUIRRELVM vm, char *res)       { if (res == NULL) sq_pushnull(vm); else { sq_pushstring(vm, OTTD2SQ(res), -1); free(res); } return 1; }
-	template <> inline int Return<const char *>(HSQUIRRELVM vm, const char *res) { if (res == NULL) sq_pushnull(vm); else { sq_pushstring(vm, OTTD2SQ(res), -1); } return 1; }
-	template <> inline int Return<void *>      (HSQUIRRELVM vm, void *res)       { sq_pushuserpointer(vm, res); return 1; }
-	template <> inline int Return<HSQOBJECT>   (HSQUIRRELVM vm, HSQOBJECT res)   { sq_pushobject(vm, res); return 1; }
+	template <> INLINE int Return<uint8>       (HSQUIRRELVM vm, uint8 res)       { sq_pushinteger(vm, (int32)res); return 1; }
+	template <> INLINE int Return<uint16>      (HSQUIRRELVM vm, uint16 res)      { sq_pushinteger(vm, (int32)res); return 1; }
+	template <> INLINE int Return<uint32>      (HSQUIRRELVM vm, uint32 res)      { sq_pushinteger(vm, (int32)res); return 1; }
+	template <> INLINE int Return<int8>        (HSQUIRRELVM vm, int8 res)        { sq_pushinteger(vm, res); return 1; }
+	template <> INLINE int Return<int16>       (HSQUIRRELVM vm, int16 res)       { sq_pushinteger(vm, res); return 1; }
+	template <> INLINE int Return<int32>       (HSQUIRRELVM vm, int32 res)       { sq_pushinteger(vm, res); return 1; }
+	template <> INLINE int Return<int64>       (HSQUIRRELVM vm, int64 res)       { sq_pushinteger(vm, ClampToI32(res)); return 1; }
+	template <> INLINE int Return<Money>       (HSQUIRRELVM vm, Money res)       { sq_pushinteger(vm, ClampToI32(res)); return 1; }
+	template <> INLINE int Return<bool>        (HSQUIRRELVM vm, bool res)        { sq_pushbool   (vm, res); return 1; }
+	template <> INLINE int Return<char *>      (HSQUIRRELVM vm, char *res)       { if (res == NULL) sq_pushnull(vm); else { sq_pushstring(vm, OTTD2SQ(res), -1); free(res); } return 1; }
+	template <> INLINE int Return<const char *>(HSQUIRRELVM vm, const char *res) { if (res == NULL) sq_pushnull(vm); else { sq_pushstring(vm, OTTD2SQ(res), -1); } return 1; }
+	template <> INLINE int Return<void *>      (HSQUIRRELVM vm, void *res)       { sq_pushuserpointer(vm, res); return 1; }
+	template <> INLINE int Return<HSQOBJECT>   (HSQUIRRELVM vm, HSQOBJECT res)   { sq_pushobject(vm, res); return 1; }
 
 	/**
 	 * To get a param from squirrel, we call this function. It converts to the right format.
 	 */
 	template <typename T> static T GetParam(ForceType<T>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr);
 
-	template <> inline uint8       GetParam(ForceType<uint8>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline uint16      GetParam(ForceType<uint16>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline uint32      GetParam(ForceType<uint32>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline int8        GetParam(ForceType<int8>        , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline int16       GetParam(ForceType<int16>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline int32       GetParam(ForceType<int32>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
-	template <> inline bool        GetParam(ForceType<bool>        , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQBool        tmp; sq_getbool       (vm, index, &tmp); return tmp != 0; }
-	template <> inline void       *GetParam(ForceType<void *>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQUserPointer tmp; sq_getuserpointer(vm, index, &tmp); return tmp; }
-	template <> inline const char *GetParam(ForceType<const char *>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr)
+	template <> INLINE uint8       GetParam(ForceType<uint8>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE uint16      GetParam(ForceType<uint16>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE uint32      GetParam(ForceType<uint32>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE int8        GetParam(ForceType<int8>        , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE int16       GetParam(ForceType<int16>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE int32       GetParam(ForceType<int32>       , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQInteger     tmp; sq_getinteger    (vm, index, &tmp); return tmp; }
+	template <> INLINE bool        GetParam(ForceType<bool>        , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQBool        tmp; sq_getbool       (vm, index, &tmp); return tmp != 0; }
+	template <> INLINE void       *GetParam(ForceType<void *>      , HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr) { SQUserPointer tmp; sq_getuserpointer(vm, index, &tmp); return tmp; }
+	template <> INLINE const char *GetParam(ForceType<const char *>, HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr)
 	{
 		/* Convert what-ever there is as parameter to a string */
 		sq_tostring(vm, index);
@@ -120,7 +120,7 @@
 		return tmp_str;
 	}
 
-	template <> inline Array      *GetParam(ForceType<Array *>,      HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr)
+	template <> INLINE Array      *GetParam(ForceType<Array *>,      HSQUIRRELVM vm, int index, SQAutoFreePointers *ptr)
 	{
 		/* Sanity check of the size. */
 		if (sq_getsize(vm, index) > UINT16_MAX) throw sq_throwerror(vm, _SC("an array used as parameter to a function is too large"));
@@ -733,7 +733,7 @@
 	 *  can handle this exact amount of params.
 	 */
 	template <typename Tcls, typename Tmethod, ScriptType Ttype>
-	inline SQInteger DefSQNonStaticCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQNonStaticCallback(HSQUIRRELVM vm)
 	{
 		/* Find the amount of params we got */
 		int nparam = sq_gettop(vm);
@@ -775,7 +775,7 @@
 	 *  can handle this exact amount of params.
 	 */
 	template <typename Tcls, typename Tmethod, ScriptType Ttype>
-	inline SQInteger DefSQAdvancedNonStaticCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQAdvancedNonStaticCallback(HSQUIRRELVM vm)
 	{
 		/* Find the amount of params we got */
 		int nparam = sq_gettop(vm);
@@ -813,7 +813,7 @@
 	 *  can handle this exact amount of params.
 	 */
 	template <typename Tcls, typename Tmethod>
-	inline SQInteger DefSQStaticCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQStaticCallback(HSQUIRRELVM vm)
 	{
 		/* Find the amount of params we got */
 		int nparam = sq_gettop(vm);
@@ -837,7 +837,7 @@
 	 *  can handle this exact amount of params.
 	 */
 	template <typename Tcls, typename Tmethod>
-	inline SQInteger DefSQAdvancedStaticCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQAdvancedStaticCallback(HSQUIRRELVM vm)
 	{
 		/* Find the amount of params we got */
 		int nparam = sq_gettop(vm);
@@ -870,7 +870,7 @@
 	 *  settings in SQ to register the instance.
 	 */
 	template <typename Tcls, typename Tmethod, int Tnparam>
-	inline SQInteger DefSQConstructorCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQConstructorCallback(HSQUIRRELVM vm)
 	{
 		try {
 			/* Create the real instance */
@@ -889,7 +889,7 @@
 	 *  constructor.
 	 */
 	template <typename Tcls>
-	inline SQInteger DefSQAdvancedConstructorCallback(HSQUIRRELVM vm)
+	INLINE SQInteger DefSQAdvancedConstructorCallback(HSQUIRRELVM vm)
 	{
 		try {
 			/* Find the amount of params we got */
diff --git a/src/settings_func.h b/src/settings_func.h
--- a/src/settings_func.h
+++ b/src/settings_func.h
@@ -39,7 +39,7 @@
 #if defined(ENABLE_NETWORK)
 void SyncCompanySettings();
 #else /* ENABLE_NETWORK */
-static inline void SyncCompanySettings() {}
+static INLINE void SyncCompanySettings() {}
 #endif /* ENABLE_NETWORK */
 
 #endif /* SETTINGS_FUNC_H */
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -81,7 +81,7 @@
  * @param town_name Number of the wanted town name.
  * @return Name of the town as string ID.
  */
-static inline StringID TownName(int town_name)
+static INLINE StringID TownName(int town_name)
 {
 	if (town_name < _nb_orig_names) return STR_GAME_OPTIONS_TOWN_NAME_ORIGINAL_ENGLISH + town_name;
 	town_name -= _nb_orig_names;
@@ -1044,7 +1044,7 @@
 	 * Get the help text of a single setting.
 	 * @return The requested help text.
 	 */
-	inline StringID GetHelpText()
+	INLINE StringID GetHelpText()
 	{
 		assert((this->flags & SEF_KIND_MASK) == SEF_SETTING_KIND);
 		return this->d.entry.setting->desc.str_help;
diff --git a/src/settings_type.h b/src/settings_type.h
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -496,7 +496,7 @@
  * Get the settings-object applicable for the current situation: the newgame settings
  * when we're in the main menu and otherwise the settings of the current game.
  */
-static inline GameSettings &GetGameSettings()
+static INLINE GameSettings &GetGameSettings()
 {
 	return (_game_mode == GM_MENU) ? _settings_newgame : _settings_game;
 }
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -57,7 +57,7 @@
 
 static const uint16 _ship_sprites[] = {0x0E5D, 0x0E55, 0x0E65, 0x0E6D};
 
-static inline TrackBits GetTileShipTrackStatus(TileIndex tile)
+static INLINE TrackBits GetTileShipTrackStatus(TileIndex tile)
 {
 	return TrackStatusToTrackBits(GetTileTrackStatus(tile, TRANSPORT_WATER, 0));
 }
@@ -451,7 +451,7 @@
 	return _new_vehicle_direction_table[offs];
 }
 
-static inline TrackBits GetAvailShipTracks(TileIndex tile, DiagDirection dir)
+static INLINE TrackBits GetAvailShipTracks(TileIndex tile, DiagDirection dir)
 {
 	return GetTileShipTrackStatus(tile) & DiagdirReachesTracks(dir);
 }
diff --git a/src/signal.cpp b/src/signal.cpp
--- a/src/signal.cpp
+++ b/src/signal.cpp
@@ -209,7 +209,7 @@
  * @param d2 direction (tile side) we are leaving
  * @return false iff reverse direction was in Todo set
  */
-static inline bool CheckAddToTodoSet(TileIndex t1, DiagDirection d1, TileIndex t2, DiagDirection d2)
+static INLINE bool CheckAddToTodoSet(TileIndex t1, DiagDirection d1, TileIndex t2, DiagDirection d2)
 {
 	_globset.Remove(t1, d1); // it can be in Global but not in Todo
 	_globset.Remove(t2, d2); // remove in all cases
@@ -235,7 +235,7 @@
  * @param d2 direction (tile side) we are leaving
  * @return false iff the Todo buffer would be overrun
  */
-static inline bool MaybeAddToTodoSet(TileIndex t1, DiagDirection d1, TileIndex t2, DiagDirection d2)
+static INLINE bool MaybeAddToTodoSet(TileIndex t1, DiagDirection d1, TileIndex t2, DiagDirection d2)
 {
 	if (!CheckAddToTodoSet(t1, d1, t2, d2)) return true;
 
@@ -451,7 +451,7 @@
 
 
 /** Reset all sets after one set overflowed */
-static inline void ResetSets()
+static INLINE void ResetSets()
 {
 	_tbuset.Reset();
 	_tbdset.Reset();
diff --git a/src/signal_func.h b/src/signal_func.h
--- a/src/signal_func.h
+++ b/src/signal_func.h
@@ -21,7 +21,7 @@
  * Maps a trackdir to the bit that stores its status in the map arrays, in the
  * direction along with the trackdir.
  */
-static inline byte SignalAlongTrackdir(Trackdir trackdir)
+static INLINE byte SignalAlongTrackdir(Trackdir trackdir)
 {
 	extern const byte _signal_along_trackdir[TRACKDIR_END];
 	return _signal_along_trackdir[trackdir];
@@ -31,7 +31,7 @@
  * Maps a trackdir to the bit that stores its status in the map arrays, in the
  * direction against the trackdir.
  */
-static inline byte SignalAgainstTrackdir(Trackdir trackdir)
+static INLINE byte SignalAgainstTrackdir(Trackdir trackdir)
 {
 	extern const byte _signal_against_trackdir[TRACKDIR_END];
 	return _signal_against_trackdir[trackdir];
@@ -41,7 +41,7 @@
  * Maps a Track to the bits that store the status of the two signals that can
  * be present on the given track.
  */
-static inline byte SignalOnTrack(Track track)
+static INLINE byte SignalOnTrack(Track track)
 {
 	extern const byte _signal_on_track[TRACK_END];
 	return _signal_on_track[track];
diff --git a/src/slope_func.h b/src/slope_func.h
--- a/src/slope_func.h
+++ b/src/slope_func.h
@@ -23,7 +23,7 @@
  * @param corner A #Corner.
  * @return true iff corner is in a valid range.
  */
-static inline bool IsValidCorner(Corner corner)
+static INLINE bool IsValidCorner(Corner corner)
 {
 	return IsInsideMM(corner, 0, CORNER_END);
 }
@@ -35,7 +35,7 @@
  * @param s The given #Slope.
  * @return True if the slope is steep, else false.
  */
-static inline bool IsSteepSlope(Slope s)
+static INLINE bool IsSteepSlope(Slope s)
 {
 	return (s & SLOPE_STEEP) != 0;
 }
@@ -46,7 +46,7 @@
  * @param s The given #Slope.
  * @return True if the slope is non-continuous, else false.
  */
-static inline bool IsHalftileSlope(Slope s)
+static INLINE bool IsHalftileSlope(Slope s)
 {
 	return (s & SLOPE_HALFTILE) != 0;
 }
@@ -59,7 +59,7 @@
  * @param s A #Slope.
  * @return The slope s without its halftile slope.
  */
-static inline Slope RemoveHalftileSlope(Slope s)
+static INLINE Slope RemoveHalftileSlope(Slope s)
 {
 	return s & ~SLOPE_HALFTILE_MASK;
 }
@@ -75,7 +75,7 @@
  * @param s The #Slope to get the complement.
  * @return a complement Slope of the given slope.
  */
-static inline Slope ComplementSlope(Slope s)
+static INLINE Slope ComplementSlope(Slope s)
 {
 	assert(!IsSteepSlope(s) && !IsHalftileSlope(s));
 	return s ^ SLOPE_ELEVATED;
@@ -87,7 +87,7 @@
  * @param s The #Slope
  * @return true iff exactly one corner is raised
  */
-static inline bool IsSlopeWithOneCornerRaised(Slope s)
+static INLINE bool IsSlopeWithOneCornerRaised(Slope s)
 {
 	return (s == SLOPE_W) || (s == SLOPE_S) || (s == SLOPE_E) || (s == SLOPE_N);
 }
@@ -98,7 +98,7 @@
  * @param corner The #Corner.
  * @return The #Slope with corner "corner" raised.
  */
-static inline Slope SlopeWithOneCornerRaised(Corner corner)
+static INLINE Slope SlopeWithOneCornerRaised(Corner corner)
 {
 	assert(IsValidCorner(corner));
 	return (Slope)(1 << corner);
@@ -112,7 +112,7 @@
  * @param s The #Slope.
  * @return  true iff the slope has a highest corner.
  */
-static inline bool HasSlopeHighestCorner(Slope s)
+static INLINE bool HasSlopeHighestCorner(Slope s)
 {
 	s = RemoveHalftileSlope(s);
 	return IsSteepSlope(s) || IsSlopeWithOneCornerRaised(s);
@@ -125,7 +125,7 @@
  * @param s  The #Slope.
  * @return   Highest corner.
  */
-static inline Corner GetHighestSlopeCorner(Slope s)
+static INLINE Corner GetHighestSlopeCorner(Slope s)
 {
 	switch (RemoveHalftileSlope(s)) {
 		case SLOPE_W:
@@ -147,7 +147,7 @@
  * @param s The #Slope.
  * @return  The corner of the leveled halftile.
  */
-static inline Corner GetHalftileSlopeCorner(Slope s)
+static INLINE Corner GetHalftileSlopeCorner(Slope s)
 {
 	assert(IsHalftileSlope(s));
 	return (Corner)((s >> 6) & 3);
@@ -159,7 +159,7 @@
  * @param s The #Slope.
  * @return Relative height of highest corner.
  */
-static inline int GetSlopeMaxZ(Slope s)
+static INLINE int GetSlopeMaxZ(Slope s)
 {
 	if (s == SLOPE_FLAT) return 0;
 	if (IsSteepSlope(s)) return 2;
@@ -172,7 +172,7 @@
  * @param s The #Slope.
  * @return Relative height of highest corner.
  */
-static inline int GetSlopeMaxPixelZ(Slope s)
+static INLINE int GetSlopeMaxPixelZ(Slope s)
 {
 	return GetSlopeMaxZ(s) * TILE_HEIGHT;
 }
@@ -183,7 +183,7 @@
  * @param corner A #Corner.
  * @return The opposite corner to "corner".
  */
-static inline Corner OppositeCorner(Corner corner)
+static INLINE Corner OppositeCorner(Corner corner)
 {
 	return (Corner)(corner ^ 2);
 }
@@ -194,7 +194,7 @@
  * @param s The #Slope
  * @return true iff exactly three corners are raised
  */
-static inline bool IsSlopeWithThreeCornersRaised(Slope s)
+static INLINE bool IsSlopeWithThreeCornersRaised(Slope s)
 {
 	return !IsHalftileSlope(s) && !IsSteepSlope(s) && IsSlopeWithOneCornerRaised(ComplementSlope(s));
 }
@@ -205,7 +205,7 @@
  * @param corner The #Corner.
  * @return The #Slope with all corners but "corner" raised.
  */
-static inline Slope SlopeWithThreeCornersRaised(Corner corner)
+static INLINE Slope SlopeWithThreeCornersRaised(Corner corner)
 {
 	return ComplementSlope(SlopeWithOneCornerRaised(corner));
 }
@@ -216,7 +216,7 @@
  * @param corner A #Corner.
  * @return The steep #Slope with "corner" as highest corner.
  */
-static inline Slope SteepSlope(Corner corner)
+static INLINE Slope SteepSlope(Corner corner)
 {
 	return SLOPE_STEEP | SlopeWithThreeCornersRaised(OppositeCorner(corner));
 }
@@ -227,7 +227,7 @@
  * @param s The #Slope
  * @return true iff the slope is inclined.
  */
-static inline bool IsInclinedSlope(Slope s)
+static INLINE bool IsInclinedSlope(Slope s)
 {
 	return (s == SLOPE_NW) || (s == SLOPE_SW) || (s == SLOPE_SE) || (s == SLOPE_NE);
 }
@@ -238,7 +238,7 @@
  * @param s A #Slope
  * @return The direction the slope goes up in. Or INVALID_DIAGDIR if the slope is not an inclined slope.
  */
-static inline DiagDirection GetInclinedSlopeDirection(Slope s)
+static INLINE DiagDirection GetInclinedSlopeDirection(Slope s)
 {
 	switch (s) {
 		case SLOPE_NE: return DIAGDIR_NE;
@@ -255,7 +255,7 @@
  * @param dir A #DiagDirection
  * @return The #Slope that goes up in direction dir.
  */
-static inline Slope InclinedSlope(DiagDirection dir)
+static INLINE Slope InclinedSlope(DiagDirection dir)
 {
 	switch (dir) {
 		case DIAGDIR_NE: return SLOPE_NE;
@@ -273,7 +273,7 @@
  * @param corner The #Corner of the halftile.
  * @return The #Slope s with the halftile slope added.
  */
-static inline Slope HalftileSlope(Slope s, Corner corner)
+static INLINE Slope HalftileSlope(Slope s, Corner corner)
 {
 	assert(IsValidCorner(corner));
 	return (Slope)(s | SLOPE_HALFTILE | (corner << 6));
@@ -286,7 +286,7 @@
  * @param f  Maybe a #Foundation.
  * @return   true iff f is a foundation.
  */
-static inline bool IsFoundation(Foundation f)
+static INLINE bool IsFoundation(Foundation f)
 {
 	return f != FOUNDATION_NONE;
 }
@@ -297,7 +297,7 @@
  * @param f  The #Foundation.
  * @return   true iff f is a leveled foundation.
  */
-static inline bool IsLeveledFoundation(Foundation f)
+static INLINE bool IsLeveledFoundation(Foundation f)
 {
 	return f == FOUNDATION_LEVELED;
 }
@@ -308,7 +308,7 @@
  * @param f  The #Foundation.
  * @return   true iff f is an inclined foundation.
  */
-static inline bool IsInclinedFoundation(Foundation f)
+static INLINE bool IsInclinedFoundation(Foundation f)
 {
 	return (f == FOUNDATION_INCLINED_X) || (f == FOUNDATION_INCLINED_Y);
 }
@@ -319,7 +319,7 @@
  * @param f  The #Foundation.
  * @return   true iff f is a non-continuous foundation
  */
-static inline bool IsNonContinuousFoundation(Foundation f)
+static INLINE bool IsNonContinuousFoundation(Foundation f)
 {
 	return IsInsideMM(f, FOUNDATION_STEEP_BOTH, FOUNDATION_HALFTILE_N + 1);
 }
@@ -332,7 +332,7 @@
  * @param f  The #Foundation.
  * @return   The #Corner with track.
  */
-static inline Corner GetHalftileFoundationCorner(Foundation f)
+static INLINE Corner GetHalftileFoundationCorner(Foundation f)
 {
 	assert(IsInsideMM(f, FOUNDATION_HALFTILE_W, FOUNDATION_HALFTILE_N + 1));
 	return (Corner)(f - FOUNDATION_HALFTILE_W);
@@ -344,7 +344,7 @@
  * @param f  The #Foundation.
  * @return   true iff f is a special rail foundation for single horizontal/vertical track.
  */
-static inline bool IsSpecialRailFoundation(Foundation f)
+static INLINE bool IsSpecialRailFoundation(Foundation f)
 {
 	return IsInsideMM(f, FOUNDATION_RAIL_W, FOUNDATION_RAIL_N + 1);
 }
@@ -355,7 +355,7 @@
  * @param f  The #Foundation.
  * @return   The #Corner with track.
  */
-static inline Corner GetRailFoundationCorner(Foundation f)
+static INLINE Corner GetRailFoundationCorner(Foundation f)
 {
 	assert(IsSpecialRailFoundation(f));
 	return (Corner)(f - FOUNDATION_RAIL_W);
@@ -368,7 +368,7 @@
  * @param s  The current #Slope.
  * @return   The needed #Foundation.
  */
-static inline Foundation FlatteningFoundation(Slope s)
+static INLINE Foundation FlatteningFoundation(Slope s)
 {
 	return (s == SLOPE_FLAT ? FOUNDATION_NONE : FOUNDATION_LEVELED);
 }
@@ -379,7 +379,7 @@
  * @param axis  The #Axis.
  * @return      The needed #Foundation.
  */
-static inline Foundation InclinedFoundation(Axis axis)
+static INLINE Foundation InclinedFoundation(Axis axis)
 {
 	return (axis == AXIS_X ? FOUNDATION_INCLINED_X : FOUNDATION_INCLINED_Y);
 }
@@ -390,7 +390,7 @@
  * @param corner The #Corner with the track.
  * @return       The wanted #Foundation.
  */
-static inline Foundation HalftileFoundation(Corner corner)
+static INLINE Foundation HalftileFoundation(Corner corner)
 {
 	assert(IsValidCorner(corner));
 	return (Foundation)(FOUNDATION_HALFTILE_W + corner);
@@ -402,7 +402,7 @@
  * @param corner The #Corner with the track.
  * @return       The wanted #Foundation.
  */
-static inline Foundation SpecialRailFoundation(Corner corner)
+static INLINE Foundation SpecialRailFoundation(Corner corner)
 {
 	assert(IsValidCorner(corner));
 	return (Foundation)(FOUNDATION_RAIL_W + corner);
@@ -414,7 +414,7 @@
  * @param s The #Slope to get the offset for.
  * @return The sprite offset for this #Slope.
  */
-static inline uint SlopeToSpriteOffset(Slope s)
+static INLINE uint SlopeToSpriteOffset(Slope s)
 {
 	extern const byte _slope_to_sprite_offset[32];
 	return _slope_to_sprite_offset[s];
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -338,7 +338,7 @@
 	uint32 mand;
 };
 
-static inline uint32 ApplyMask(uint32 colour, const AndOr *mask)
+static INLINE uint32 ApplyMask(uint32 colour, const AndOr *mask)
 {
 	return (colour & mask->mand) | mask->mor;
 }
@@ -393,7 +393,7 @@
 };
 
 
-static inline TileType GetEffectiveTileType(TileIndex tile)
+static INLINE TileType GetEffectiveTileType(TileIndex tile)
 {
 	TileType t = GetTileType(tile);
 
@@ -415,7 +415,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile in the small map in mode "Contour"
  */
-static inline uint32 GetSmallMapContoursPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapContoursPixels(TileIndex tile, TileType t)
 {
 	const SmallMapColourScheme *cs = &_heightmap_schemes[_settings_client.gui.smallmap_land_colour];
 	return ApplyMask(cs->height_colours[TileHeight(tile)], &_smallmap_contours_andor[t]);
@@ -428,7 +428,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile in the small map in mode "Vehicles"
  */
-static inline uint32 GetSmallMapVehiclesPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapVehiclesPixels(TileIndex tile, TileType t)
 {
 	const SmallMapColourScheme *cs = &_heightmap_schemes[_settings_client.gui.smallmap_land_colour];
 	return ApplyMask(cs->default_colour, &_smallmap_vehicles_andor[t]);
@@ -441,7 +441,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile in the small map in mode "Industries"
  */
-static inline uint32 GetSmallMapIndustriesPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapIndustriesPixels(TileIndex tile, TileType t)
 {
 	if (t == MP_INDUSTRY) {
 		/* If industry is allowed to be seen, use its colour on the map */
@@ -466,7 +466,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile  in the small map in mode "Routes"
  */
-static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
 {
 	if (t == MP_STATION) {
 		switch (GetStationType(tile)) {
@@ -511,7 +511,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile  in the smallmap in mode "Vegetation"
  */
-static inline uint32 GetSmallMapVegetationPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapVegetationPixels(TileIndex tile, TileType t)
 {
 	switch (t) {
 		case MP_CLEAR:
@@ -538,7 +538,7 @@
  * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
  * @return The colour of tile in the small map in mode "Owner"
  */
-static inline uint32 GetSmallMapOwnerPixels(TileIndex tile, TileType t)
+static INLINE uint32 GetSmallMapOwnerPixels(TileIndex tile, TileType t)
 {
 	Owner o;
 
@@ -605,7 +605,7 @@
 	static const uint BLINK_PERIOD         = 0x0F; ///< highlight blinking interval
 	uint8 refresh; ///< refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks
 
-	inline Point SmallmapRemapCoords(int x, int y) const
+	INLINE Point SmallmapRemapCoords(int x, int y) const
 	{
 		Point pt;
 		pt.x = (y - x) * 2;
@@ -619,7 +619,7 @@
 	 * @param tile_y Y coordinate of the tile.
 	 * @return Position to draw on.
 	 */
-	inline Point RemapTile(int tile_x, int tile_y) const
+	INLINE Point RemapTile(int tile_x, int tile_y) const
 	{
 		int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
 		int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
@@ -643,7 +643,7 @@
 	 * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
 	 * @note The #subscroll offset is already accounted for.
 	 */
-	inline Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const
+	INLINE Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const
 	{
 		if (add_sub) px += this->subscroll;  // Total horizontal offset.
 
@@ -749,7 +749,7 @@
 	 * @param ta Tile area to investigate.
 	 * @return Colours to display.
 	 */
-	inline uint32 GetTileColours(const TileArea &ta) const
+	INLINE uint32 GetTileColours(const TileArea &ta) const
 	{
 		int importance = 0;
 		TileIndex tile = INVALID_TILE; // Position of the most important tile.
@@ -907,7 +907,7 @@
 	 * @param y Y coord of top border of main viewport
 	 * @param y2 Y coord of bottom border of main viewport
 	 */
-	static inline void DrawVertMapIndicator(int x, int y, int y2)
+	static INLINE void DrawVertMapIndicator(int x, int y, int y2)
 	{
 		GfxFillRect(x, y,      x, y + 3, PC_VERY_LIGHT_YELLOW);
 		GfxFillRect(x, y2 - 3, x, y2,    PC_VERY_LIGHT_YELLOW);
@@ -919,7 +919,7 @@
 	 * @param x2 X coord of right border of main viewport
 	 * @param y Y coord of top/bottom border of main viewport
 	 */
-	static inline void DrawHorizMapIndicator(int x, int x2, int y)
+	static INLINE void DrawHorizMapIndicator(int x, int x2, int y)
 	{
 		GfxFillRect(x,      y, x + 3, y, PC_VERY_LIGHT_YELLOW);
 		GfxFillRect(x2 - 3, y, x2,    y, PC_VERY_LIGHT_YELLOW);
@@ -1079,7 +1079,7 @@
 	 * Compute minimal required width of the legends.
 	 * @return Minimally needed width for displaying the smallmap legends in pixels.
 	 */
-	inline uint GetMinLegendWidth() const
+	INLINE uint GetMinLegendWidth() const
 	{
 		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
 	}
@@ -1088,7 +1088,7 @@
 	 * Return number of columns that can be displayed in \a width pixels.
 	 * @return Number of columns to display.
 	 */
-	inline uint GetNumberColumnsLegend(uint width) const
+	INLINE uint GetNumberColumnsLegend(uint width) const
 	{
 		return width / this->column_width;
 	}
diff --git a/src/sprite.h b/src/sprite.h
--- a/src/sprite.h
+++ b/src/sprite.h
@@ -88,7 +88,7 @@
  * @param total_offset Spriteoffset from normal rail to current railtype.
  * @param newgrf_offset Startsprite of the Action1 to use.
  */
-static inline void DrawRailTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, int32 total_offset, uint32 newgrf_offset, PaletteID default_palette)
+static INLINE void DrawRailTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, int32 total_offset, uint32 newgrf_offset, PaletteID default_palette)
 {
 	DrawCommonTileSeq(ti, dts, to, total_offset, newgrf_offset, default_palette, false);
 }
@@ -98,7 +98,7 @@
  * @param total_offset Spriteoffset from normal rail to current railtype.
  * @param newgrf_offset Startsprite of the Action1 to use.
  */
-static inline void DrawRailTileSeqInGUI(int x, int y, const DrawTileSprites *dts, int32 total_offset, uint32 newgrf_offset, PaletteID default_palette)
+static INLINE void DrawRailTileSeqInGUI(int x, int y, const DrawTileSprites *dts, int32 total_offset, uint32 newgrf_offset, PaletteID default_palette)
 {
 	DrawCommonTileSeqInGUI(x, y, dts, total_offset, newgrf_offset, default_palette, false);
 }
@@ -106,7 +106,7 @@
 /**
  * Draw TTD sprite sequence on tile.
  */
-static inline void DrawOrigTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, PaletteID default_palette)
+static INLINE void DrawOrigTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, PaletteID default_palette)
 {
 	DrawCommonTileSeq(ti, dts, to, 0, 0, default_palette, false);
 }
@@ -114,7 +114,7 @@
 /**
  * Draw TTD sprite sequence in GUI.
  */
-static inline void DrawOrigTileSeqInGUI(int x, int y, const DrawTileSprites *dts, PaletteID default_palette)
+static INLINE void DrawOrigTileSeqInGUI(int x, int y, const DrawTileSprites *dts, PaletteID default_palette)
 {
 	DrawCommonTileSeqInGUI(x, y, dts, 0, 0, default_palette, false);
 }
@@ -123,7 +123,7 @@
  * Draw NewGRF industrytile or house sprite layout
  * @param stage Sprite inside the Action1 spritesets to use, i.e. construction stage.
  */
-static inline void DrawNewGRFTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, uint32 stage, PaletteID default_palette)
+static INLINE void DrawNewGRFTileSeq(const struct TileInfo *ti, const DrawTileSprites *dts, TransparencyOption to, uint32 stage, PaletteID default_palette)
 {
 	DrawCommonTileSeq(ti, dts, to, 0, stage, default_palette, true);
 }
@@ -132,7 +132,7 @@
  * Draw NewGRF object in GUI
  * @param stage Sprite inside the Action1 spritesets to use, i.e. construction stage.
  */
-static inline void DrawNewGRFTileSeqInGUI(int x, int y, const DrawTileSprites *dts, uint32 stage, PaletteID default_palette)
+static INLINE void DrawNewGRFTileSeqInGUI(int x, int y, const DrawTileSprites *dts, uint32 stage, PaletteID default_palette)
 {
 	DrawCommonTileSeqInGUI(x, y, dts, 0, stage, default_palette, true);
 }
@@ -148,7 +148,7 @@
  * @param default_pal The default recolour sprite to use (typically company colour resp. random industry/house colour)
  * @return The palette to use
  */
-static inline PaletteID SpriteLayoutPaletteTransform(SpriteID image, PaletteID pal, PaletteID default_pal)
+static INLINE PaletteID SpriteLayoutPaletteTransform(SpriteID image, PaletteID pal, PaletteID default_pal)
 {
 	if (HasBit(image, PALETTE_MODIFIER_TRANSPARENT) || HasBit(image, PALETTE_MODIFIER_COLOUR)) {
 		return (pal != 0 ? pal : default_pal);
@@ -167,7 +167,7 @@
  * @param default_pal The default recolour sprite to use (typically company colour resp. random industry/house colour)
  * @return The palette to use
  */
-static inline PaletteID GroundSpritePaletteTransform(SpriteID image, PaletteID pal, PaletteID default_pal)
+static INLINE PaletteID GroundSpritePaletteTransform(SpriteID image, PaletteID pal, PaletteID default_pal)
 {
 	if (HasBit(image, PALETTE_MODIFIER_COLOUR)) {
 		return (pal != 0 ? pal : default_pal);
diff --git a/src/spritecache.cpp b/src/spritecache.cpp
--- a/src/spritecache.cpp
+++ b/src/spritecache.cpp
@@ -43,12 +43,12 @@
 static SpriteCache *_spritecache = NULL;
 
 
-static inline SpriteCache *GetSpriteCache(uint index)
+static INLINE SpriteCache *GetSpriteCache(uint index)
 {
 	return &_spritecache[index];
 }
 
-static inline bool IsMapgenSpriteID(SpriteID sprite)
+static INLINE bool IsMapgenSpriteID(SpriteID sprite)
 {
 	return IsInsideMM(sprite, 4845, 4882);
 }
@@ -525,7 +525,7 @@
 	} else {
 		FioSkipBytes(7);
 		type = SkipSpriteData(grf_type, num - 8) ? ST_NORMAL : ST_INVALID;
-		/* Inline sprites are not supported for container version >= 2. */
+		/* INLINE sprites are not supported for container version >= 2. */
 		if (container_version >= 2) return false;
 	}
 
@@ -583,7 +583,7 @@
 /* make sure it's a power of two */
 assert_compile((sizeof(size_t) & (sizeof(size_t) - 1)) == 0);
 
-static inline MemBlock *NextBlock(MemBlock *block)
+static INLINE MemBlock *NextBlock(MemBlock *block)
 {
 	return (MemBlock*)((byte*)block + (block->size & ~S_FREE_MASK));
 }
diff --git a/src/spritecache.h b/src/spritecache.h
--- a/src/spritecache.h
+++ b/src/spritecache.h
@@ -35,13 +35,13 @@
 uint GetMaxSpriteID();
 
 
-static inline const Sprite *GetSprite(SpriteID sprite, SpriteType type)
+static INLINE const Sprite *GetSprite(SpriteID sprite, SpriteType type)
 {
 	assert(type != ST_RECOLOUR);
 	return (Sprite*)GetRawSprite(sprite, type);
 }
 
-static inline const byte *GetNonSprite(SpriteID sprite, SpriteType type)
+static INLINE const byte *GetNonSprite(SpriteID sprite, SpriteType type)
 {
 	assert(type == ST_RECOLOUR);
 	return (byte*)GetRawSprite(sprite, type);
diff --git a/src/station_base.h b/src/station_base.h
--- a/src/station_base.h
+++ b/src/station_base.h
@@ -150,7 +150,7 @@
 	}
 
 	/** Check if this airport has at least one hangar. */
-	inline bool HasHangar() const
+	INLINE bool HasHangar() const
 	{
 		return this->GetSpec()->nof_depots > 0;
 	}
@@ -163,7 +163,7 @@
 	 * @param tidc The tilediff to add to the airport tile.
 	 * @return The tile of this airport plus the rotated offset.
 	 */
-	inline TileIndex GetRotatedTileFromOffset(TileIndexDiffC tidc) const
+	INLINE TileIndex GetRotatedTileFromOffset(TileIndexDiffC tidc) const
 	{
 		const AirportSpec *as = this->GetSpec();
 		switch (this->rotation) {
@@ -185,7 +185,7 @@
 	 * @pre hangar_num < GetNumHangars().
 	 * @return A tile with the given hangar.
 	 */
-	inline TileIndex GetHangarTile(uint hangar_num) const
+	INLINE TileIndex GetHangarTile(uint hangar_num) const
 	{
 		const AirportSpec *as = this->GetSpec();
 		for (uint i = 0; i < as->nof_depots; i++) {
@@ -202,7 +202,7 @@
 	 * @pre IsHangarTile(tile).
 	 * @return The exit direction of the hangar, taking airport rotation into account.
 	 */
-	inline Direction GetHangarExitDirection(TileIndex tile) const
+	INLINE Direction GetHangarExitDirection(TileIndex tile) const
 	{
 		const AirportSpec *as = this->GetSpec();
 		const HangarTileTable *htt = GetHangarDataByTile(tile);
@@ -215,14 +215,14 @@
 	 * @pre IsHangarTile(tile).
 	 * @return The hangar number of the hangar at the given tile.
 	 */
-	inline uint GetHangarNum(TileIndex tile) const
+	INLINE uint GetHangarNum(TileIndex tile) const
 	{
 		const HangarTileTable *htt = GetHangarDataByTile(tile);
 		return htt->hangar_num;
 	}
 
 	/** Get the number of hangars on this airport. */
-	inline uint GetNumHangars() const
+	INLINE uint GetNumHangars() const
 	{
 		uint num = 0;
 		uint counted = 0;
@@ -243,7 +243,7 @@
 	 * @return The requested hangar information.
 	 * @pre The \a tile must be at a hangar tile at an airport.
 	 */
-	inline const HangarTileTable *GetHangarDataByTile(TileIndex tile) const
+	INLINE const HangarTileTable *GetHangarDataByTile(TileIndex tile) const
 	{
 		const AirportSpec *as = this->GetSpec();
 		for (uint i = 0; i < as->nof_depots; i++) {
@@ -306,12 +306,12 @@
 	uint GetCatchmentRadius() const;
 	Rect GetCatchmentRect() const;
 
-	/* virtual */ inline bool TileBelongsToRailStation(TileIndex tile) const
+	/* virtual */ INLINE bool TileBelongsToRailStation(TileIndex tile) const
 	{
 		return IsRailStationTile(tile) && GetStationIndex(tile) == this->index;
 	}
 
-	inline bool TileBelongsToAirport(TileIndex tile) const
+	INLINE bool TileBelongsToAirport(TileIndex tile) const
 	{
 		return IsAirportTile(tile) && GetStationIndex(tile) == this->index;
 	}
@@ -338,7 +338,7 @@
 		if (!st->TileBelongsToAirport(this->tile)) ++(*this);
 	}
 
-	inline TileIterator& operator ++()
+	INLINE TileIterator& operator ++()
 	{
 		(*this).OrthogonalTileIterator::operator++();
 		while (this->tile != INVALID_TILE && !st->TileBelongsToAirport(this->tile)) {
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -981,7 +981,7 @@
 	return CommandCost();
 }
 
-static inline byte *CreateSingle(byte *layout, int n)
+static INLINE byte *CreateSingle(byte *layout, int n)
 {
 	int i = n;
 	do *layout++ = 0; while (--i);
@@ -989,7 +989,7 @@
 	return layout;
 }
 
-static inline byte *CreateMulti(byte *layout, int n, byte b)
+static INLINE byte *CreateMulti(byte *layout, int n, byte b)
 {
 	int i = n;
 	do *layout++ = b; while (--i);
@@ -3162,7 +3162,7 @@
 	return true;
 }
 
-static inline void byte_inc_sat(byte *p)
+static INLINE void byte_inc_sat(byte *p)
 {
 	byte b = *p + 1;
 	if (b != 0) *p = b;
diff --git a/src/station_func.h b/src/station_func.h
--- a/src/station_func.h
+++ b/src/station_func.h
@@ -49,7 +49,7 @@
  * @param num Number of station tiles.
  * @return Total cost.
  */
-static inline Money StationMaintenanceCost(uint32 num)
+static INLINE Money StationMaintenanceCost(uint32 num)
 {
 	return (_price[PR_INFRASTRUCTURE_STATION] * num * (1 + IntSqrt(num))) >> 7; // 7 bits scaling.
 }
diff --git a/src/station_map.h b/src/station_map.h
--- a/src/station_map.h
+++ b/src/station_map.h
@@ -26,7 +26,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return Station ID of the station at \a t
  */
-static inline StationID GetStationIndex(TileIndex t)
+static INLINE StationID GetStationIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return (StationID)_m[t].m2;
@@ -42,7 +42,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return the station type
  */
-static inline StationType GetStationType(TileIndex t)
+static INLINE StationType GetStationType(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return (StationType)GB(_m[t].m6, 3, 3);
@@ -54,7 +54,7 @@
  * @pre GetStationType(t) == STATION_TRUCK || GetStationType(t) == STATION_BUS
  * @return the road stop type
  */
-static inline RoadStopType GetRoadStopType(TileIndex t)
+static INLINE RoadStopType GetRoadStopType(TileIndex t)
 {
 	assert(GetStationType(t) == STATION_TRUCK || GetStationType(t) == STATION_BUS);
 	return GetStationType(t) == STATION_TRUCK ? ROADSTOP_TRUCK : ROADSTOP_BUS;
@@ -66,7 +66,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return the station graphics
  */
-static inline StationGfx GetStationGfx(TileIndex t)
+static INLINE StationGfx GetStationGfx(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return _m[t].m5;
@@ -78,7 +78,7 @@
  * @param gfx the new graphics
  * @pre IsTileType(t, MP_STATION)
  */
-static inline void SetStationGfx(TileIndex t, StationGfx gfx)
+static INLINE void SetStationGfx(TileIndex t, StationGfx gfx)
 {
 	assert(IsTileType(t, MP_STATION));
 	_m[t].m5 = gfx;
@@ -90,7 +90,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is a rail station
  */
-static inline bool IsRailStation(TileIndex t)
+static INLINE bool IsRailStation(TileIndex t)
 {
 	return GetStationType(t) == STATION_RAIL;
 }
@@ -100,7 +100,7 @@
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail station
  */
-static inline bool IsRailStationTile(TileIndex t)
+static INLINE bool IsRailStationTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsRailStation(t);
 }
@@ -111,7 +111,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is a rail waypoint
  */
-static inline bool IsRailWaypoint(TileIndex t)
+static INLINE bool IsRailWaypoint(TileIndex t)
 {
 	return GetStationType(t) == STATION_WAYPOINT;
 }
@@ -121,7 +121,7 @@
  * @param t the tile to get the information from
  * @return true if and only if the tile is a rail waypoint
  */
-static inline bool IsRailWaypointTile(TileIndex t)
+static INLINE bool IsRailWaypointTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsRailWaypoint(t);
 }
@@ -133,7 +133,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile has rail
  */
-static inline bool HasStationRail(TileIndex t)
+static INLINE bool HasStationRail(TileIndex t)
 {
 	return IsRailStation(t) || IsRailWaypoint(t);
 }
@@ -144,7 +144,7 @@
  * @param t the tile to check
  * @return true if and only if the tile is a station tile and has rail
  */
-static inline bool HasStationTileRail(TileIndex t)
+static INLINE bool HasStationTileRail(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && HasStationRail(t);
 }
@@ -155,7 +155,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return true if and only if the tile is an airport
  */
-static inline bool IsAirport(TileIndex t)
+static INLINE bool IsAirport(TileIndex t)
 {
 	return GetStationType(t) == STATION_AIRPORT;
 }
@@ -165,7 +165,7 @@
  * @param t the tile to get the information from
  * @return true if and only if the tile is an airport
  */
-static inline bool IsAirportTile(TileIndex t)
+static INLINE bool IsAirportTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsAirport(t);
 }
@@ -178,7 +178,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station is a truck stop, \c false otherwise
  */
-static inline bool IsTruckStop(TileIndex t)
+static INLINE bool IsTruckStop(TileIndex t)
 {
 	return GetStationType(t) == STATION_TRUCK;
 }
@@ -189,7 +189,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station is a bus stop, \c false otherwise
  */
-static inline bool IsBusStop(TileIndex t)
+static INLINE bool IsBusStop(TileIndex t)
 {
 	return GetStationType(t) == STATION_BUS;
 }
@@ -200,7 +200,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if station at the tile is a bus top or a truck stop, \c false otherwise
  */
-static inline bool IsRoadStop(TileIndex t)
+static INLINE bool IsRoadStop(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return IsTruckStop(t) || IsBusStop(t);
@@ -211,7 +211,7 @@
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a road stop
  */
-static inline bool IsRoadStopTile(TileIndex t)
+static INLINE bool IsRoadStopTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsRoadStop(t);
 }
@@ -221,7 +221,7 @@
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a standard road stop
  */
-static inline bool IsStandardRoadStopTile(TileIndex t)
+static INLINE bool IsStandardRoadStopTile(TileIndex t)
 {
 	return IsRoadStopTile(t) && GetStationGfx(t) < GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET;
 }
@@ -231,7 +231,7 @@
  * @param t Tile to check
  * @return \c true if the tile is a station tile and a drive through road stop
  */
-static inline bool IsDriveThroughStopTile(TileIndex t)
+static INLINE bool IsDriveThroughStopTile(TileIndex t)
 {
 	return IsRoadStopTile(t) && GetStationGfx(t) >= GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET;
 }
@@ -242,7 +242,7 @@
  * @pre IsAirport(t)
  * @return the station graphics
  */
-static inline StationGfx GetAirportGfx(TileIndex t)
+static INLINE StationGfx GetAirportGfx(TileIndex t)
 {
 	assert(IsAirport(t));
 	extern StationGfx GetTranslatedAirportTileID(StationGfx gfx);
@@ -255,7 +255,7 @@
  * @pre IsRoadStopTile(t)
  * @return the direction of the entrance
  */
-static inline DiagDirection GetRoadStopDir(TileIndex t)
+static INLINE DiagDirection GetRoadStopDir(TileIndex t)
 {
 	StationGfx gfx = GetStationGfx(t);
 	assert(IsRoadStopTile(t));
@@ -272,7 +272,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if the tile is an oilrig tile
  */
-static inline bool IsOilRig(TileIndex t)
+static INLINE bool IsOilRig(TileIndex t)
 {
 	return GetStationType(t) == STATION_OILRIG;
 }
@@ -283,7 +283,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if the tile is a dock
  */
-static inline bool IsDock(TileIndex t)
+static INLINE bool IsDock(TileIndex t)
 {
 	return GetStationType(t) == STATION_DOCK;
 }
@@ -293,7 +293,7 @@
  * @param t Tile to check
  * @return \c true if the tile is a dock
  */
-static inline bool IsDockTile(TileIndex t)
+static INLINE bool IsDockTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && GetStationType(t) == STATION_DOCK;
 }
@@ -304,7 +304,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return \c true if the tile is a buoy
  */
-static inline bool IsBuoy(TileIndex t)
+static INLINE bool IsBuoy(TileIndex t)
 {
 	return GetStationType(t) == STATION_BUOY;
 }
@@ -314,7 +314,7 @@
  * @param t Tile to check
  * @return \c true if the tile is a buoy
  */
-static inline bool IsBuoyTile(TileIndex t)
+static INLINE bool IsBuoyTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsBuoy(t);
 }
@@ -324,7 +324,7 @@
  * @param t Tile to check
  * @return \c true if the tile is an hangar
  */
-static inline bool IsHangarTile(TileIndex t)
+static INLINE bool IsHangarTile(TileIndex t)
 {
 	return IsTileType(t, MP_STATION) && IsHangar(t);
 }
@@ -335,7 +335,7 @@
  * @pre HasStationRail(t)
  * @return The direction of the rails on tile \a t.
  */
-static inline Axis GetRailStationAxis(TileIndex t)
+static INLINE Axis GetRailStationAxis(TileIndex t)
 {
 	assert(HasStationRail(t));
 	return HasBit(GetStationGfx(t), 0) ? AXIS_Y : AXIS_X;
@@ -347,7 +347,7 @@
  * @pre HasStationRail(t)
  * @return The rail track of the rails on tile \a t.
  */
-static inline Track GetRailStationTrack(TileIndex t)
+static INLINE Track GetRailStationTrack(TileIndex t)
 {
 	return AxisToTrack(GetRailStationAxis(t));
 }
@@ -358,7 +358,7 @@
  * @pre HasStationRail(t)
  * @return The trackbits of the rails on tile \a t.
  */
-static inline TrackBits GetRailStationTrackBits(TileIndex t)
+static INLINE TrackBits GetRailStationTrackBits(TileIndex t)
 {
 	return AxisToTrackBits(GetRailStationAxis(t));
 }
@@ -376,7 +376,7 @@
  * @pre IsRailStationTile(t2)
  * @return true if the two tiles are compatible
  */
-static inline bool IsCompatibleTrainStationTile(TileIndex t1, TileIndex t2)
+static INLINE bool IsCompatibleTrainStationTile(TileIndex t1, TileIndex t2)
 {
 	assert(IsRailStationTile(t2));
 	return IsRailStationTile(t1) && IsCompatibleRail(GetRailType(t1), GetRailType(t2)) &&
@@ -391,7 +391,7 @@
  * @param t the station tile
  * @return reservation state
  */
-static inline bool HasStationReservation(TileIndex t)
+static INLINE bool HasStationReservation(TileIndex t)
 {
 	assert(HasStationRail(t));
 	return HasBit(_m[t].m6, 2);
@@ -403,7 +403,7 @@
  * @param t the station tile
  * @param b the reservation state
  */
-static inline void SetRailStationReservation(TileIndex t, bool b)
+static INLINE void SetRailStationReservation(TileIndex t, bool b)
 {
 	assert(HasStationRail(t));
 	SB(_m[t].m6, 2, 1, b ? 1 : 0);
@@ -415,7 +415,7 @@
  * @param t the tile
  * @return reserved track bits
  */
-static inline TrackBits GetStationReservationTrackBits(TileIndex t)
+static INLINE TrackBits GetStationReservationTrackBits(TileIndex t)
 {
 	return HasStationReservation(t) ? GetRailStationTrackBits(t) : TRACK_BIT_NONE;
 }
@@ -427,7 +427,7 @@
  * @pre \a t is the land part of the dock
  * @return The direction of the dock on tile \a t.
  */
-static inline DiagDirection GetDockDirection(TileIndex t)
+static INLINE DiagDirection GetDockDirection(TileIndex t)
 {
 	StationGfx gfx = GetStationGfx(t);
 	assert(IsDock(t) && gfx < GFX_DOCK_BASE_WATER_PART);
@@ -441,7 +441,7 @@
  * @pre IsBuoy(t) || IsOilRig(t) || IsDock(t)
  * @return The offset from this tile that should be used as destination for ships.
  */
-static inline TileIndexDiffC GetDockOffset(TileIndex t)
+static INLINE TileIndexDiffC GetDockOffset(TileIndex t)
 {
 	static const TileIndexDiffC buoy_offset = {0, 0};
 	static const TileIndexDiffC oilrig_offset = {2, 0};
@@ -467,7 +467,7 @@
  * @pre HasStationTileRail(t)
  * @return True if this station is part of a newgrf station.
  */
-static inline bool IsCustomStationSpecIndex(TileIndex t)
+static INLINE bool IsCustomStationSpecIndex(TileIndex t)
 {
 	assert(HasStationTileRail(t));
 	return _m[t].m4 != 0;
@@ -479,7 +479,7 @@
  * @param specindex The new spec.
  * @pre HasStationTileRail(t)
  */
-static inline void SetCustomStationSpecIndex(TileIndex t, byte specindex)
+static INLINE void SetCustomStationSpecIndex(TileIndex t, byte specindex)
 {
 	assert(HasStationTileRail(t));
 	_m[t].m4 = specindex;
@@ -491,7 +491,7 @@
  * @pre HasStationTileRail(t)
  * @return The custom station spec of this tile.
  */
-static inline uint GetCustomStationSpecIndex(TileIndex t)
+static INLINE uint GetCustomStationSpecIndex(TileIndex t)
 {
 	assert(HasStationTileRail(t));
 	return _m[t].m4;
@@ -503,7 +503,7 @@
  * @param random_bits The random bits.
  * @pre IsTileType(t, MP_STATION)
  */
-static inline void SetStationTileRandomBits(TileIndex t, byte random_bits)
+static INLINE void SetStationTileRandomBits(TileIndex t, byte random_bits)
 {
 	assert(IsTileType(t, MP_STATION));
 	SB(_m[t].m3, 4, 4, random_bits);
@@ -515,7 +515,7 @@
  * @pre IsTileType(t, MP_STATION)
  * @return The random bits for this station tile.
  */
-static inline byte GetStationTileRandomBits(TileIndex t)
+static INLINE byte GetStationTileRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_STATION));
 	return GB(_m[t].m3, 4, 4);
@@ -530,7 +530,7 @@
  * @param section the StationGfx to be used for this tile
  * @param wc The water class of the station
  */
-static inline void MakeStation(TileIndex t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID)
+static INLINE void MakeStation(TileIndex t, Owner o, StationID sid, StationType st, byte section, WaterClass wc = WATER_CLASS_INVALID)
 {
 	SetTileType(t, MP_STATION);
 	SetTileOwner(t, o);
@@ -553,7 +553,7 @@
  * @param section the StationGfx to be used for this tile
  * @param rt the railtype of this tile
  */
-static inline void MakeRailStation(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
+static INLINE void MakeRailStation(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
 {
 	MakeStation(t, o, sid, STATION_RAIL, section + a);
 	SetRailType(t, rt);
@@ -569,7 +569,7 @@
  * @param section the StationGfx to be used for this tile
  * @param rt the railtype of this tile
  */
-static inline void MakeRailWaypoint(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
+static INLINE void MakeRailWaypoint(TileIndex t, Owner o, StationID sid, Axis a, byte section, RailType rt)
 {
 	MakeStation(t, o, sid, STATION_WAYPOINT, section + a);
 	SetRailType(t, rt);
@@ -585,7 +585,7 @@
  * @param rt the roadtypes on this tile
  * @param d the direction of the roadstop
  */
-static inline void MakeRoadStop(TileIndex t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d)
+static INLINE void MakeRoadStop(TileIndex t, Owner o, StationID sid, RoadStopType rst, RoadTypes rt, DiagDirection d)
 {
 	MakeStation(t, o, sid, (rst == ROADSTOP_BUS ? STATION_BUS : STATION_TRUCK), d);
 	SetRoadTypes(t, rt);
@@ -604,7 +604,7 @@
  * @param rt the roadtypes on this tile
  * @param a the direction of the roadstop
  */
-static inline void MakeDriveThroughRoadStop(TileIndex t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a)
+static INLINE void MakeDriveThroughRoadStop(TileIndex t, Owner station, Owner road, Owner tram, StationID sid, RoadStopType rst, RoadTypes rt, Axis a)
 {
 	MakeStation(t, station, sid, (rst == ROADSTOP_BUS ? STATION_BUS : STATION_TRUCK), GFX_TRUCK_BUS_DRIVETHROUGH_OFFSET + a);
 	SetRoadTypes(t, rt);
@@ -620,7 +620,7 @@
  * @param section the StationGfx to be used for this tile
  * @param wc the type of water on this tile
  */
-static inline void MakeAirport(TileIndex t, Owner o, StationID sid, byte section, WaterClass wc)
+static INLINE void MakeAirport(TileIndex t, Owner o, StationID sid, byte section, WaterClass wc)
 {
 	MakeStation(t, o, sid, STATION_AIRPORT, section, wc);
 }
@@ -631,7 +631,7 @@
  * @param sid the station to which this tile belongs
  * @param wc the type of water on this tile
  */
-static inline void MakeBuoy(TileIndex t, StationID sid, WaterClass wc)
+static INLINE void MakeBuoy(TileIndex t, StationID sid, WaterClass wc)
 {
 	/* Make the owner of the buoy tile the same as the current owner of the
 	 * water tile. In this way, we can reset the owner of the water to its
@@ -647,7 +647,7 @@
  * @param d the direction of the dock
  * @param wc the type of water on this tile
  */
-static inline void MakeDock(TileIndex t, Owner o, StationID sid, DiagDirection d, WaterClass wc)
+static INLINE void MakeDock(TileIndex t, Owner o, StationID sid, DiagDirection d, WaterClass wc)
 {
 	MakeStation(t, o, sid, STATION_DOCK, d);
 	MakeStation(t + TileOffsByDiagDir(d), o, sid, STATION_DOCK, GFX_DOCK_BASE_WATER_PART + DiagDirToAxis(d), wc);
@@ -659,7 +659,7 @@
  * @param sid the station to which this tile belongs
  * @param wc the type of water on this tile
  */
-static inline void MakeOilrig(TileIndex t, StationID sid, WaterClass wc)
+static INLINE void MakeOilrig(TileIndex t, StationID sid, WaterClass wc)
 {
 	MakeStation(t, OWNER_NONE, sid, STATION_OILRIG, 0, wc);
 }
diff --git a/src/stdafx.h b/src/stdafx.h
--- a/src/stdafx.h
+++ b/src/stdafx.h
@@ -184,7 +184,7 @@
 
 	#include <malloc.h> // alloca()
 	#define NORETURN __declspec(noreturn)
-	#define inline __forceinline
+	#define INLINE __forceinline
 
 	#if !defined(WINCE)
 		#define CDECL _cdecl
@@ -446,7 +446,7 @@
  * Version of the standard free that accepts const pointers.
  * @param ptr The data to free.
  */
-static inline void free(const void *ptr)
+static INLINE void free(const void *ptr)
 {
 	free(const_cast<void *>(ptr));
 }
diff --git a/src/string_func.h b/src/string_func.h
--- a/src/string_func.h
+++ b/src/string_func.h
@@ -53,7 +53,7 @@
  * @return true if the buffer starts with the terminating null-character or
  *         if the given pointer points to NULL else return false
  */
-static inline bool StrEmpty(const char *s)
+static INLINE bool StrEmpty(const char *s)
 {
 	return s == NULL || s[0] == '\0';
 }
@@ -65,7 +65,7 @@
  * @param maxlen The maximum size of the buffer
  * @return The length of the string
  */
-static inline size_t ttd_strnlen(const char *str, size_t maxlen)
+static INLINE size_t ttd_strnlen(const char *str, size_t maxlen)
 {
 	const char *t;
 	for (t = str; (size_t)(t - str) < maxlen && *t != '\0'; t++) {}
@@ -81,7 +81,7 @@
 size_t Utf8TrimString(char *s, size_t maxlen);
 
 
-static inline WChar Utf8Consume(const char **s)
+static INLINE WChar Utf8Consume(const char **s)
 {
 	WChar c;
 	*s += Utf8Decode(&c, *s);
@@ -94,7 +94,7 @@
  * @param c Unicode character.
  * @return Length of UTF-8 encoding for character.
  */
-static inline int8 Utf8CharLen(WChar c)
+static INLINE int8 Utf8CharLen(WChar c)
 {
 	if (c < 0x80)       return 1;
 	if (c < 0x800)      return 2;
@@ -113,7 +113,7 @@
  * @param c char to query length of
  * @return requested size
  */
-static inline int8 Utf8EncodedCharLen(char c)
+static INLINE int8 Utf8EncodedCharLen(char c)
 {
 	if (GB(c, 3, 5) == 0x1E) return 4;
 	if (GB(c, 4, 4) == 0x0E) return 3;
@@ -126,7 +126,7 @@
 
 
 /* Check if the given character is part of a UTF8 sequence */
-static inline bool IsUtf8Part(char c)
+static INLINE bool IsUtf8Part(char c)
 {
 	return GB(c, 6, 2) == 2;
 }
@@ -138,7 +138,7 @@
  * @note The function should not be used to determine the length of the previous
  * encoded char because it might be an invalid/corrupt start-sequence
  */
-static inline char *Utf8PrevChar(char *s)
+static INLINE char *Utf8PrevChar(char *s)
 {
 	char *ret = s;
 	while (IsUtf8Part(*--ret)) {}
@@ -153,7 +153,7 @@
  * @return true iff the character is used to influence
  *         the text direction.
  */
-static inline bool IsTextDirectionChar(WChar c)
+static INLINE bool IsTextDirectionChar(WChar c)
 {
 	switch (c) {
 		case CHAR_TD_LRM:
@@ -170,7 +170,7 @@
 	}
 }
 
-static inline bool IsPrintable(WChar c)
+static INLINE bool IsPrintable(WChar c)
 {
 	if (c < 0x20)   return false;
 	if (c < 0xE000) return true;
@@ -185,7 +185,7 @@
  * @return a boolean value whether 'c' is a whitespace character or not
  * @see http://www.fileformat.info/info/unicode/category/Zs/list.htm
  */
-static inline bool IsWhitespace(WChar c)
+static INLINE bool IsWhitespace(WChar c)
 {
 	return c == 0x0020 /* SPACE */ || c == 0x3000; /* IDEOGRAPHIC SPACE */
 }
diff --git a/src/strings.cpp b/src/strings.cpp
--- a/src/strings.cpp
+++ b/src/strings.cpp
@@ -1668,7 +1668,7 @@
 #ifdef ENABLE_NETWORK
 extern void SortNetworkLanguages();
 #else /* ENABLE_NETWORK */
-static inline void SortNetworkLanguages() {}
+static INLINE void SortNetworkLanguages() {}
 #endif /* ENABLE_NETWORK */
 
 /**
diff --git a/src/strings_func.h b/src/strings_func.h
--- a/src/strings_func.h
+++ b/src/strings_func.h
@@ -140,7 +140,7 @@
  * @param n Index of the string parameter.
  * @param v Value of the string parameter.
  */
-static inline void SetDParamX(uint64 *s, uint n, uint64 v)
+static INLINE void SetDParamX(uint64 *s, uint n, uint64 v)
 {
 	s[n] = v;
 }
@@ -150,7 +150,7 @@
  * @param n Index of the string parameter.
  * @param v Value of the string parameter.
  */
-static inline void SetDParam(uint n, uint64 v)
+static INLINE void SetDParam(uint n, uint64 v)
 {
 	_global_string_params.SetParam(n, v);
 }
@@ -167,7 +167,7 @@
  * @param n Index of the string parameter.
  * @return Value of the requested string parameter.
  */
-static inline uint64 GetDParamX(const uint64 *s, uint n)
+static INLINE uint64 GetDParamX(const uint64 *s, uint n)
 {
 	return s[n];
 }
@@ -177,7 +177,7 @@
  * @param n Index of the string parameter.
  * @return Value of the requested string parameter.
  */
-static inline uint64 GetDParam(uint n)
+static INLINE uint64 GetDParam(uint n)
 {
 	return _global_string_params.GetParam(n);
 }
diff --git a/src/subsidy.cpp b/src/subsidy.cpp
--- a/src/subsidy.cpp
+++ b/src/subsidy.cpp
@@ -117,7 +117,7 @@
  * @param index index of town/industry
  * @param flag flag to set
  */
-static inline void SetPartOfSubsidyFlag(SourceType type, SourceID index, PartOfSubsidy flag)
+static INLINE void SetPartOfSubsidyFlag(SourceType type, SourceID index, PartOfSubsidy flag)
 {
 	switch (type) {
 		case ST_INDUSTRY: Industry::Get(index)->part_of_subsidy |= flag; return;
diff --git a/src/subsidy_base.h b/src/subsidy_base.h
--- a/src/subsidy_base.h
+++ b/src/subsidy_base.h
@@ -33,18 +33,18 @@
 	/**
 	 * We need an (empty) constructor so struct isn't zeroed (as C++ standard states)
 	 */
-	inline Subsidy() { }
+	INLINE Subsidy() { }
 
 	/**
 	 * (Empty) destructor has to be defined else operator delete might be called with NULL parameter
 	 */
-	inline ~Subsidy() { }
+	INLINE ~Subsidy() { }
 
 	/**
 	 * Tests whether this subsidy has been awarded to someone
 	 * @return is this subsidy awarded?
 	 */
-	inline bool IsAwarded() const
+	INLINE bool IsAwarded() const
 	{
 		return this->awarded != INVALID_COMPANY;
 	}
diff --git a/src/table/control_codes.h b/src/table/control_codes.h
--- a/src/table/control_codes.h
+++ b/src/table/control_codes.h
@@ -149,7 +149,7 @@
 	SCC_NEWGRF_ROTATE_TOP_4_WORDS,                    ///< Rotate the top 4 words of the stack (W4 W1 W2 W3)
 	SCC_NEWGRF_LAST = SCC_NEWGRF_ROTATE_TOP_4_WORDS,
 
-	SCC_NEWGRF_STRINL,                                ///< Inline another string at the current position, StringID is encoded in the string
+	SCC_NEWGRF_STRINL,                                ///< INLINE another string at the current position, StringID is encoded in the string
 
 	/* Special printable symbols.
 	 * These are mapped to the original glyphs */
diff --git a/src/tgp.cpp b/src/tgp.cpp
--- a/src/tgp.cpp
+++ b/src/tgp.cpp
@@ -174,7 +174,7 @@
 	 * @param y Y position
 	 * @return height as fixed point number
 	 */
-	inline height_t &height(uint x, uint y)
+	INLINE height_t &height(uint x, uint y)
 	{
 		return h[x + y * dim_x];
 	}
@@ -236,7 +236,7 @@
  * @param y coordinate y
  * @return true if within the map
  */
-static inline bool IsValidXY(uint x, uint y)
+static INLINE bool IsValidXY(uint x, uint y)
 {
 	return ((int)x) >= 0 && x < _height_map.size_x && ((int)y) >= 0 && y < _height_map.size_y;
 }
@@ -246,7 +246,7 @@
  * Allocate array of (MapSizeX()+1)*(MapSizeY()+1) heights and init the _height_map structure members
  * @return true on success
  */
-static inline bool AllocHeightMap()
+static INLINE bool AllocHeightMap()
 {
 	height_t *h;
 
@@ -265,7 +265,7 @@
 }
 
 /** Free height map */
-static inline void FreeHeightMap()
+static INLINE void FreeHeightMap()
 {
 	if (_height_map.h == NULL) return;
 	free(_height_map.h);
@@ -277,7 +277,7 @@
  * @param rMax Limit of result
  * @return generated height
  */
-static inline height_t RandomHeight(amplitude_t rMax)
+static INLINE height_t RandomHeight(amplitude_t rMax)
 {
 	amplitude_t ra = (Random() << 16) | (Random() & 0x0000FFFF);
 	height_t rh;
@@ -892,7 +892,7 @@
 /**
  * This routine determines the interpolated value between a and b
  */
-static inline double linear_interpolate(const double a, const double b, const double x)
+static INLINE double linear_interpolate(const double a, const double b, const double x)
 {
 	return a + x * (b - a);
 }
diff --git a/src/tile_cmd.h b/src/tile_cmd.h
--- a/src/tile_cmd.h
+++ b/src/tile_cmd.h
@@ -163,7 +163,7 @@
 void ChangeTileOwner(TileIndex tile, Owner old_owner, Owner new_owner);
 void GetTileDesc(TileIndex tile, TileDesc *td);
 
-static inline void AddAcceptedCargo(TileIndex tile, CargoArray &acceptance, uint32 *always_accepted)
+static INLINE void AddAcceptedCargo(TileIndex tile, CargoArray &acceptance, uint32 *always_accepted)
 {
 	AddAcceptedCargoProc *proc = _tile_type_procs[GetTileType(tile)]->add_accepted_cargo_proc;
 	if (proc == NULL) return;
@@ -171,21 +171,21 @@
 	proc(tile, acceptance, always_accepted == NULL ? &dummy : always_accepted);
 }
 
-static inline void AddProducedCargo(TileIndex tile, CargoArray &produced)
+static INLINE void AddProducedCargo(TileIndex tile, CargoArray &produced)
 {
 	AddProducedCargoProc *proc = _tile_type_procs[GetTileType(tile)]->add_produced_cargo_proc;
 	if (proc == NULL) return;
 	proc(tile, produced);
 }
 
-static inline void AnimateTile(TileIndex tile)
+static INLINE void AnimateTile(TileIndex tile)
 {
 	AnimateTileProc *proc = _tile_type_procs[GetTileType(tile)]->animate_tile_proc;
 	assert(proc != NULL);
 	proc(tile);
 }
 
-static inline bool ClickTile(TileIndex tile)
+static INLINE bool ClickTile(TileIndex tile)
 {
 	ClickTileProc *proc = _tile_type_procs[GetTileType(tile)]->click_tile_proc;
 	if (proc == NULL) return false;
diff --git a/src/tile_map.h b/src/tile_map.h
--- a/src/tile_map.h
+++ b/src/tile_map.h
@@ -28,7 +28,7 @@
  * @return the height of the tile
  * @pre tile < MapSize()
  */
-static inline uint TileHeight(TileIndex tile)
+static INLINE uint TileHeight(TileIndex tile)
 {
 	assert(tile < MapSize());
 	return GB(_m[tile].type_height, 0, 4);
@@ -44,7 +44,7 @@
  * @pre tile < MapSize()
  * @pre heigth <= MAX_TILE_HEIGHT
  */
-static inline void SetTileHeight(TileIndex tile, uint height)
+static INLINE void SetTileHeight(TileIndex tile, uint height)
 {
 	assert(tile < MapSize());
 	assert(height <= MAX_TILE_HEIGHT);
@@ -59,7 +59,7 @@
  * @param tile The tile to get the height
  * @return The height of the tile in pixel
  */
-static inline uint TilePixelHeight(TileIndex tile)
+static INLINE uint TilePixelHeight(TileIndex tile)
 {
 	return TileHeight(tile) * TILE_HEIGHT;
 }
@@ -71,7 +71,7 @@
  * @return The tiletype of the tile
  * @pre tile < MapSize()
  */
-static inline TileType GetTileType(TileIndex tile)
+static INLINE TileType GetTileType(TileIndex tile)
 {
 	assert(tile < MapSize());
 	return (TileType)GB(_m[tile].type_height, 4, 4);
@@ -89,7 +89,7 @@
  * @pre tile < MapSize()
  * @pre type MP_VOID <=> tile is on the south-east or south-west edge.
  */
-static inline void SetTileType(TileIndex tile, TileType type)
+static INLINE void SetTileType(TileIndex tile, TileType type)
 {
 	assert(tile < MapSize());
 	/* VOID tiles (and no others) are exactly allowed at the lower left and right
@@ -108,7 +108,7 @@
  * @param type The type to check agains
  * @return true If the type matches agains the type of the tile
  */
-static inline bool IsTileType(TileIndex tile, TileType type)
+static INLINE bool IsTileType(TileIndex tile, TileType type)
 {
 	return GetTileType(tile) == type;
 }
@@ -119,7 +119,7 @@
  * @param tile The tile to check
  * @return True if the tile is on the map and not one of MP_VOID.
  */
-static inline bool IsValidTile(TileIndex tile)
+static INLINE bool IsValidTile(TileIndex tile)
 {
 	return tile < MapSize() && !IsTileType(tile, MP_VOID);
 }
@@ -136,7 +136,7 @@
  * @pre IsValidTile(tile)
  * @pre The type of the tile must not be MP_HOUSE and MP_INDUSTRY
  */
-static inline Owner GetTileOwner(TileIndex tile)
+static INLINE Owner GetTileOwner(TileIndex tile)
 {
 	assert(IsValidTile(tile));
 	assert(!IsTileType(tile, MP_HOUSE));
@@ -156,7 +156,7 @@
  * @pre IsValidTile(tile)
  * @pre The type of the tile must not be MP_HOUSE and MP_INDUSTRY
  */
-static inline void SetTileOwner(TileIndex tile, Owner owner)
+static INLINE void SetTileOwner(TileIndex tile, Owner owner)
 {
 	assert(IsValidTile(tile));
 	assert(!IsTileType(tile, MP_HOUSE));
@@ -172,7 +172,7 @@
  * @param owner The owner to check agains
  * @return True if a tile belongs the the given owner
  */
-static inline bool IsTileOwner(TileIndex tile, Owner owner)
+static INLINE bool IsTileOwner(TileIndex tile, Owner owner)
 {
 	return GetTileOwner(tile) == owner;
 }
@@ -183,7 +183,7 @@
  * @param type the new type
  * @pre tile < MapSize()
  */
-static inline void SetTropicZone(TileIndex tile, TropicZone type)
+static INLINE void SetTropicZone(TileIndex tile, TropicZone type)
 {
 	assert(tile < MapSize());
 	assert(!IsTileType(tile, MP_VOID) || type == TROPICZONE_NORMAL);
@@ -196,7 +196,7 @@
  * @pre tile < MapSize()
  * @return the zone type
  */
-static inline TropicZone GetTropicZone(TileIndex tile)
+static INLINE TropicZone GetTropicZone(TileIndex tile)
 {
 	assert(tile < MapSize());
 	return (TropicZone)GB(_m[tile].m6, 0, 2);
@@ -208,7 +208,7 @@
  * @pre IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION)
  * @return frame number
  */
-static inline byte GetAnimationFrame(TileIndex t)
+static INLINE byte GetAnimationFrame(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION));
 	return _me[t].m7;
@@ -220,7 +220,7 @@
  * @param frame the new frame number
  * @pre IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION)
  */
-static inline void SetAnimationFrame(TileIndex t, byte frame)
+static INLINE void SetAnimationFrame(TileIndex t, byte frame)
 {
 	assert(IsTileType(t, MP_HOUSE) || IsTileType(t, MP_OBJECT) || IsTileType(t, MP_INDUSTRY) ||IsTileType(t, MP_STATION));
 	_me[t].m7 = frame;
@@ -236,7 +236,7 @@
  * @param h    If not \c NULL, pointer to storage of z height
  * @return Slope of the tile, except for the HALFTILE part
  */
-static inline Slope GetTilePixelSlope(TileIndex tile, int *h)
+static INLINE Slope GetTilePixelSlope(TileIndex tile, int *h)
 {
 	Slope s = GetTileSlope(tile, h);
 	if (h != NULL) *h *= TILE_HEIGHT;
@@ -248,7 +248,7 @@
  * @param tile Tile to compute height of
  * @return Minimum height of the tile
  */
-static inline int GetTilePixelZ(TileIndex tile)
+static INLINE int GetTilePixelZ(TileIndex tile)
 {
 	return GetTileZ(tile) * TILE_HEIGHT;
 }
@@ -258,7 +258,7 @@
  * @param t Tile to compute height of
  * @return Maximum height of the tile
  */
-static inline int GetTileMaxPixelZ(TileIndex tile)
+static INLINE int GetTileMaxPixelZ(TileIndex tile)
 {
 	return GetTileMaxZ(tile) * TILE_HEIGHT;
 }
@@ -271,7 +271,7 @@
  * @param y The Y coordinate
  * @return The hash of the tile
  */
-static inline uint TileHash(uint x, uint y)
+static INLINE uint TileHash(uint x, uint y)
 {
 	uint hash = x >> 4;
 	hash ^= x >> 6;
@@ -289,7 +289,7 @@
  * @param y The Y coordinate
  * @return The last two bits from hash of the tile
  */
-static inline uint TileHash2Bit(uint x, uint y)
+static INLINE uint TileHash2Bit(uint x, uint y)
 {
 	return GB(TileHash(x, y), 0, 2);
 }
diff --git a/src/tilearea_type.h b/src/tilearea_type.h
--- a/src/tilearea_type.h
+++ b/src/tilearea_type.h
@@ -85,7 +85,7 @@
 	 * Get the tile we are currently at.
 	 * @return The tile we are at, or INVALID_TILE when we're done.
 	 */
-	inline operator TileIndex () const
+	INLINE operator TileIndex () const
 	{
 		return this->tile;
 	}
@@ -120,7 +120,7 @@
 	/**
 	 * Move ourselves to the next tile in the rectange on the map.
 	 */
-	inline TileIterator& operator ++()
+	INLINE TileIterator& operator ++()
 	{
 		assert(this->tile != INVALID_TILE);
 
diff --git a/src/tilematrix_type.hpp b/src/tilematrix_type.hpp
--- a/src/tilematrix_type.hpp
+++ b/src/tilematrix_type.hpp
@@ -137,7 +137,7 @@
 	}
 
 	/** Array access operator, see #Get. */
-	inline T &operator[](TileIndex tile)
+	INLINE T &operator[](TileIndex tile)
 	{
 		return *this->Get(tile);
 	}
diff --git a/src/timetable_gui.cpp b/src/timetable_gui.cpp
--- a/src/timetable_gui.cpp
+++ b/src/timetable_gui.cpp
@@ -497,7 +497,7 @@
 		}
 	}
 
-	static inline uint32 PackTimetableArgs(const Vehicle *v, uint selected, bool speed)
+	static INLINE uint32 PackTimetableArgs(const Vehicle *v, uint selected, bool speed)
 	{
 		uint order_number = (selected + 1) / 2;
 		ModifyTimetableFlags mtf = (selected % 2 == 1) ? (speed ? MTF_TRAVEL_SPEED : MTF_TRAVEL_TIME) : MTF_WAIT_TIME;
diff --git a/src/town.h b/src/town.h
--- a/src/town.h
+++ b/src/town.h
@@ -85,7 +85,7 @@
 
 	char *text; ///< General text with additional information.
 
-	inline byte GetPercentTransported(CargoID cid) const { return this->supplied[cid].old_act * 256 / (this->supplied[cid].old_max + 1); }
+	INLINE byte GetPercentTransported(CargoID cid) const { return this->supplied[cid].old_act * 256 / (this->supplied[cid].old_max + 1); }
 
 	/* Cargo production and acceptance stats. */
 	uint32 cargo_produced;           ///< Bitmap of all cargoes produced by houses in this town.
@@ -122,7 +122,7 @@
 	 * entry in town_noise_population corresponding to the town's tolerance.
 	 * @return the maximum noise level the town will tolerate.
 	 */
-	inline uint16 MaxTownNoise() const
+	INLINE uint16 MaxTownNoise() const
 	{
 		if (this->cache.population == 0) return 0; // no population? no noise
 
@@ -132,7 +132,7 @@
 
 	void UpdateVirtCoord();
 
-	static inline Town *GetByTile(TileIndex tile)
+	static INLINE Town *GetByTile(TileIndex tile)
 	{
 		return Town::Get(GetTownIndex(tile));
 	}
diff --git a/src/town_cmd.cpp b/src/town_cmd.cpp
--- a/src/town_cmd.cpp
+++ b/src/town_cmd.cpp
@@ -197,7 +197,7 @@
  *
  * @return a random direction
  */
-static inline DiagDirection RandomDiagDir()
+static INLINE DiagDirection RandomDiagDir()
 {
 	return (DiagDirection)(3 & Random());
 }
@@ -580,7 +580,7 @@
 	}
 }
 
-static inline void AddAcceptedCargoSetMask(CargoID cargo, uint amount, CargoArray &acceptance, uint32 *always_accepted)
+static INLINE void AddAcceptedCargoSetMask(CargoID cargo, uint amount, CargoArray &acceptance, uint32 *always_accepted)
 {
 	if (cargo == CT_INVALID || amount == 0) return;
 	acceptance[cargo] += amount;
@@ -1938,7 +1938,7 @@
  * @param random_bits required for newgrf houses
  * @pre house can be built here
  */
-static inline void ClearMakeHouseTile(TileIndex tile, Town *t, byte counter, byte stage, HouseID type, byte random_bits)
+static INLINE void ClearMakeHouseTile(TileIndex tile, Town *t, byte counter, byte stage, HouseID type, byte random_bits)
 {
 	CommandCost cc = DoCommand(tile, 0, 0, DC_EXEC | DC_AUTO | DC_NO_WATER, CMD_LANDSCAPE_CLEAR);
 
@@ -1981,7 +1981,7 @@
  * @param noslope are slopes (foundations) allowed?
  * @return true iff house can be built here
  */
-static inline bool CanBuildHouseHere(TileIndex tile, TownID town, bool noslope)
+static INLINE bool CanBuildHouseHere(TileIndex tile, TownID town, bool noslope)
 {
 	/* cannot build on these slopes... */
 	Slope slope = GetTileSlope(tile);
@@ -2007,7 +2007,7 @@
  * @return true iff house can be built here
  * @see CanBuildHouseHere()
  */
-static inline bool CheckBuildHouseSameZ(TileIndex tile, TownID town, int z, bool noslope)
+static INLINE bool CheckBuildHouseSameZ(TileIndex tile, TownID town, int z, bool noslope)
 {
 	if (!CanBuildHouseHere(tile, town, noslope)) return false;
 
@@ -2048,7 +2048,7 @@
  * @return true iff town layout allows building here
  * @note see layouts
  */
-static inline bool TownLayoutAllowsHouseHere(Town *t, TileIndex tile)
+static INLINE bool TownLayoutAllowsHouseHere(Town *t, TileIndex tile)
 {
 	/* Allow towns everywhere when we don't build roads */
 	if (!_settings_game.economy.allow_town_roads && !_generating_world) return true;
@@ -2079,7 +2079,7 @@
  * @return true iff town layout allows 2x2 building here
  * @note see layouts
  */
-static inline bool TownLayoutAllows2x2HouseHere(Town *t, TileIndex tile)
+static INLINE bool TownLayoutAllows2x2HouseHere(Town *t, TileIndex tile)
 {
 	/* Allow towns everywhere when we don't build roads */
 	if (!_settings_game.economy.allow_town_roads && !_generating_world) return true;
diff --git a/src/town_map.h b/src/town_map.h
--- a/src/town_map.h
+++ b/src/town_map.h
@@ -21,7 +21,7 @@
  * @pre IsTileType(t, MP_HOUSE) or IsTileType(t, MP_ROAD) but not a road depot
  * @return TownID
  */
-static inline TownID GetTownIndex(TileIndex t)
+static INLINE TownID GetTownIndex(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) || (IsTileType(t, MP_ROAD) && !IsRoadDepot(t)));
 	return _m[t].m2;
@@ -33,7 +33,7 @@
  * @param index the index of the town
  * @pre IsTileType(t, MP_HOUSE) or IsTileType(t, MP_ROAD) but not a road depot
  */
-static inline void SetTownIndex(TileIndex t, TownID index)
+static INLINE void SetTownIndex(TileIndex t, TownID index)
 {
 	assert(IsTileType(t, MP_HOUSE) || (IsTileType(t, MP_ROAD) && !IsRoadDepot(t)));
 	_m[t].m2 = index;
@@ -46,7 +46,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return house type
  */
-static inline HouseID GetCleanHouseType(TileIndex t)
+static INLINE HouseID GetCleanHouseType(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return _m[t].m4 | (GB(_m[t].m3, 6, 1) << 8);
@@ -58,7 +58,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return house type
  */
-static inline HouseID GetHouseType(TileIndex t)
+static INLINE HouseID GetHouseType(TileIndex t)
 {
 	return GetTranslatedHouseID(GetCleanHouseType(t));
 }
@@ -69,7 +69,7 @@
  * @param house_id the new house type
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void SetHouseType(TileIndex t, HouseID house_id)
+static INLINE void SetHouseType(TileIndex t, HouseID house_id)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	_m[t].m4 = GB(house_id, 0, 8);
@@ -81,7 +81,7 @@
  * @param t the tile
  * @return has destination
  */
-static inline bool LiftHasDestination(TileIndex t)
+static INLINE bool LiftHasDestination(TileIndex t)
 {
 	return HasBit(_me[t].m7, 0);
 }
@@ -92,7 +92,7 @@
  * @param t the tile
  * @param dest new destination
  */
-static inline void SetLiftDestination(TileIndex t, byte dest)
+static INLINE void SetLiftDestination(TileIndex t, byte dest)
 {
 	SetBit(_me[t].m7, 0);
 	SB(_me[t].m7, 1, 3, dest);
@@ -103,7 +103,7 @@
  * @param t the tile
  * @return destination
  */
-static inline byte GetLiftDestination(TileIndex t)
+static INLINE byte GetLiftDestination(TileIndex t)
 {
 	return GB(_me[t].m7, 1, 3);
 }
@@ -114,7 +114,7 @@
  * and the destination.
  * @param t the tile
  */
-static inline void HaltLift(TileIndex t)
+static INLINE void HaltLift(TileIndex t)
 {
 	SB(_me[t].m7, 0, 4, 0);
 }
@@ -124,7 +124,7 @@
  * @param t the tile
  * @return position, from 0 to 36
  */
-static inline byte GetLiftPosition(TileIndex t)
+static INLINE byte GetLiftPosition(TileIndex t)
 {
 	return GB(_m[t].m6, 2, 6);
 }
@@ -134,7 +134,7 @@
  * @param t the tile
  * @param pos position, from 0 to 36
  */
-static inline void SetLiftPosition(TileIndex t, byte pos)
+static INLINE void SetLiftPosition(TileIndex t, byte pos)
 {
 	SB(_m[t].m6, 2, 6, pos);
 }
@@ -144,7 +144,7 @@
  * @param t the tile
  * @return true if it is, false if it is not
  */
-static inline bool IsHouseCompleted(TileIndex t)
+static INLINE bool IsHouseCompleted(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return HasBit(_m[t].m3, 7);
@@ -155,7 +155,7 @@
  * @param t the tile
  * @param status
  */
-static inline void SetHouseCompleted(TileIndex t, bool status)
+static INLINE void SetHouseCompleted(TileIndex t, bool status)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	SB(_m[t].m3, 7, 1, !!status);
@@ -182,7 +182,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return the building stage of the house
  */
-static inline byte GetHouseBuildingStage(TileIndex t)
+static INLINE byte GetHouseBuildingStage(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return IsHouseCompleted(t) ? (byte)TOWN_HOUSE_COMPLETED : GB(_m[t].m5, 3, 2);
@@ -194,7 +194,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return the construction stage of the house
  */
-static inline byte GetHouseConstructionTick(TileIndex t)
+static INLINE byte GetHouseConstructionTick(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return IsHouseCompleted(t) ? 0 : GB(_m[t].m5, 0, 3);
@@ -207,7 +207,7 @@
  * @param t the tile of the house to increment the construction stage of
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void IncHouseConstructionTick(TileIndex t)
+static INLINE void IncHouseConstructionTick(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	AB(_m[t].m5, 0, 5, 1);
@@ -225,7 +225,7 @@
  * @param t the tile of this house
  * @pre IsTileType(t, MP_HOUSE) && IsHouseCompleted(t)
  */
-static inline void ResetHouseAge(TileIndex t)
+static INLINE void ResetHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE) && IsHouseCompleted(t));
 	_m[t].m5 = 0;
@@ -236,7 +236,7 @@
  * @param t the tile of this house
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void IncrementHouseAge(TileIndex t)
+static INLINE void IncrementHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	if (IsHouseCompleted(t) && _m[t].m5 < 0xFF) _m[t].m5++;
@@ -248,7 +248,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return year
  */
-static inline Year GetHouseAge(TileIndex t)
+static INLINE Year GetHouseAge(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return IsHouseCompleted(t) ? _m[t].m5 : 0;
@@ -261,7 +261,7 @@
  * @param random the new random bits
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void SetHouseRandomBits(TileIndex t, byte random)
+static INLINE void SetHouseRandomBits(TileIndex t, byte random)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	_m[t].m1 = random;
@@ -274,7 +274,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return random bits
  */
-static inline byte GetHouseRandomBits(TileIndex t)
+static INLINE byte GetHouseRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return _m[t].m1;
@@ -287,7 +287,7 @@
  * @param triggers the activated triggers
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void SetHouseTriggers(TileIndex t, byte triggers)
+static INLINE void SetHouseTriggers(TileIndex t, byte triggers)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	SB(_m[t].m3, 0, 5, triggers);
@@ -300,7 +300,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return triggers
  */
-static inline byte GetHouseTriggers(TileIndex t)
+static INLINE byte GetHouseTriggers(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return GB(_m[t].m3, 0, 5);
@@ -312,7 +312,7 @@
  * @pre IsTileType(t, MP_HOUSE)
  * @return time remaining
  */
-static inline byte GetHouseProcessingTime(TileIndex t)
+static INLINE byte GetHouseProcessingTime(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	return GB(_m[t].m6, 2, 6);
@@ -324,7 +324,7 @@
  * @param time the time to be set
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void SetHouseProcessingTime(TileIndex t, byte time)
+static INLINE void SetHouseProcessingTime(TileIndex t, byte time)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	SB(_m[t].m6, 2, 6, time);
@@ -335,7 +335,7 @@
  * @param t the house tile
  * @pre IsTileType(t, MP_HOUSE)
  */
-static inline void DecHouseProcessingTime(TileIndex t)
+static INLINE void DecHouseProcessingTime(TileIndex t)
 {
 	assert(IsTileType(t, MP_HOUSE));
 	_m[t].m6 -= 1 << 2;
@@ -351,7 +351,7 @@
  * @param random_bits required for newgrf houses
  * @pre IsTileType(t, MP_CLEAR)
  */
-static inline void MakeHouseTile(TileIndex t, TownID tid, byte counter, byte stage, HouseID type, byte random_bits)
+static INLINE void MakeHouseTile(TileIndex t, TownID tid, byte counter, byte stage, HouseID type, byte random_bits)
 {
 	assert(IsTileType(t, MP_CLEAR));
 
diff --git a/src/townname.cpp b/src/townname.cpp
--- a/src/townname.cpp
+++ b/src/townname.cpp
@@ -138,7 +138,7 @@
  * @param seed seed
  * @return seed transformed to a number from given range
  */
-static inline uint32 SeedChance(byte shift_by, int max, uint32 seed)
+static INLINE uint32 SeedChance(byte shift_by, int max, uint32 seed)
 {
 	return (GB(seed, shift_by, 16) * max) >> 16;
 }
@@ -151,7 +151,7 @@
  * @param seed seed
  * @return seed transformed to a number from given range
  */
-static inline uint32 SeedModChance(byte shift_by, int max, uint32 seed)
+static INLINE uint32 SeedModChance(byte shift_by, int max, uint32 seed)
 {
 	/* This actually gives *MUCH* more even distribution of the values
 	 * than SeedChance(), which is absolutely horrible in that. If
@@ -174,7 +174,7 @@
  * @param bias minimum value that can be returned
  * @return seed transformed to a number from given range
  */
-static inline int32 SeedChanceBias(byte shift_by, int max, uint32 seed, int bias)
+static INLINE int32 SeedChanceBias(byte shift_by, int max, uint32 seed, int bias)
 {
 	return SeedChance(shift_by, max + bias, seed) - bias;
 }
diff --git a/src/track_func.h b/src/track_func.h
--- a/src/track_func.h
+++ b/src/track_func.h
@@ -36,7 +36,7 @@
  * @param a the axis to convert
  * @return the track corresponding to the axis
  */
-static inline Track AxisToTrack(Axis a)
+static INLINE Track AxisToTrack(Axis a)
 {
 	return (Track)a;
 }
@@ -46,7 +46,7 @@
  * @param track the track to convert
  * @return the converted TrackBits value of the track
  */
-static inline TrackBits TrackToTrackBits(Track track)
+static INLINE TrackBits TrackToTrackBits(Track track)
 {
 	return (TrackBits)(1 << track);
 }
@@ -56,7 +56,7 @@
  * @param a the axis to convert
  * @return the converted TrackBits value of the axis
  */
-static inline TrackBits AxisToTrackBits(Axis a)
+static INLINE TrackBits AxisToTrackBits(Axis a)
 {
 	return TrackToTrackBits(AxisToTrack(a));
 }
@@ -67,7 +67,7 @@
  * @param corner The corner of a tile.
  * @return The TrackBits of the track in the corner.
  */
-static inline TrackBits CornerToTrackBits(Corner corner)
+static INLINE TrackBits CornerToTrackBits(Corner corner)
 {
 	extern const TrackBits _corner_to_trackbits[];
 	assert(IsValidCorner(corner));
@@ -81,7 +81,7 @@
  * @param trackdir the track direction to convert
  * @return the converted TrackdirBits value
  */
-static inline TrackdirBits TrackdirToTrackdirBits(Trackdir trackdir)
+static INLINE TrackdirBits TrackdirToTrackdirBits(Trackdir trackdir)
 {
 	return (TrackdirBits)(1 << trackdir);
 }
@@ -100,7 +100,7 @@
  * @return The first Track from the TrackBits value
  * @see FindFirstTrack
  */
-static inline Track RemoveFirstTrack(TrackBits *tracks)
+static INLINE Track RemoveFirstTrack(TrackBits *tracks)
 {
 	if (*tracks != TRACK_BIT_NONE && *tracks != INVALID_TRACK_BIT) {
 		Track first = (Track)FIND_FIRST_BIT(*tracks);
@@ -124,7 +124,7 @@
  * @return The first Trackdir from the TrackdirBits value
  * @see FindFirstTrackdir
  */
-static inline Trackdir RemoveFirstTrackdir(TrackdirBits *trackdirs)
+static INLINE Trackdir RemoveFirstTrackdir(TrackdirBits *trackdirs)
 {
 	if (*trackdirs != TRACKDIR_BIT_NONE && *trackdirs != INVALID_TRACKDIR_BIT) {
 		Trackdir first = (Trackdir)FindFirstBit2x64(*trackdirs);
@@ -144,7 +144,7 @@
  * @return The first Track found or INVALID_TRACK
  * @see RemoveFirstTrack
  */
-static inline Track FindFirstTrack(TrackBits tracks)
+static INLINE Track FindFirstTrack(TrackBits tracks)
 {
 	return (tracks != TRACK_BIT_NONE && tracks != INVALID_TRACK_BIT) ? (Track)FIND_FIRST_BIT(tracks) : INVALID_TRACK;
 }
@@ -160,7 +160,7 @@
  * @return The Track from the value or INVALID_TRACK
  * @pre tracks must contains only one Track or be INVALID_TRACK_BIT
  */
-static inline Track TrackBitsToTrack(TrackBits tracks)
+static INLINE Track TrackBitsToTrack(TrackBits tracks)
 {
 	assert(tracks == INVALID_TRACK_BIT || (tracks != TRACK_BIT_NONE && KillFirstBit(tracks & TRACK_BIT_MASK) == TRACK_BIT_NONE));
 	return tracks != INVALID_TRACK_BIT ? (Track)FIND_FIRST_BIT(tracks & TRACK_BIT_MASK) : INVALID_TRACK;
@@ -178,7 +178,7 @@
  * @pre trackdirs must not be INVALID_TRACKDIR_BIT
  * @see RemoveFirstTrackdir
  */
-static inline Trackdir FindFirstTrackdir(TrackdirBits trackdirs)
+static INLINE Trackdir FindFirstTrackdir(TrackdirBits trackdirs)
 {
 	assert((trackdirs & ~TRACKDIR_BIT_MASK) == TRACKDIR_BIT_NONE);
 	return (trackdirs != TRACKDIR_BIT_NONE) ? (Trackdir)FindFirstBit2x64(trackdirs) : INVALID_TRACKDIR;
@@ -191,7 +191,7 @@
  * @return true if the given value is a valid track.
  * @note Use this in an assert()
  */
-static inline bool IsValidTrack(Track track)
+static INLINE bool IsValidTrack(Track track)
 {
 	return track < TRACK_END;
 }
@@ -203,7 +203,7 @@
  * @return true if the given valie is a valid Trackdir
  * @note Use this in an assert()
  */
-static inline bool IsValidTrackdir(Trackdir trackdir)
+static INLINE bool IsValidTrackdir(Trackdir trackdir)
 {
 	return (TrackdirToTrackdirBits(trackdir) & TRACKDIR_BIT_MASK) != 0;
 }
@@ -223,7 +223,7 @@
  * @param t the track to convert
  * @return the opposite track
  */
-static inline Track TrackToOppositeTrack(Track t)
+static INLINE Track TrackToOppositeTrack(Track t)
 {
 	assert(t != INVALID_TRACK);
 	return (Track)(t ^ 1);
@@ -239,7 +239,7 @@
  * @return The reverse trackdir
  * @pre trackdir must not be INVALID_TRACKDIR
  */
-static inline Trackdir ReverseTrackdir(Trackdir trackdir)
+static INLINE Trackdir ReverseTrackdir(Trackdir trackdir)
 {
 	assert(trackdir != INVALID_TRACKDIR);
 	return (Trackdir)(trackdir ^ 8);
@@ -254,7 +254,7 @@
  * @param trackdir The trackdir value
  * @return The Track which is used in the value
  */
-static inline Track TrackdirToTrack(Trackdir trackdir)
+static INLINE Track TrackdirToTrack(Trackdir trackdir)
 {
 	return (Track)(trackdir & 0x7);
 }
@@ -270,7 +270,7 @@
  * @param track The given Track
  * @return The Trackdir from the given Track
  */
-static inline Trackdir TrackToTrackdir(Track track)
+static INLINE Trackdir TrackToTrackdir(Track track)
 {
 	return (Trackdir)track;
 }
@@ -284,7 +284,7 @@
  * @param track The track to get the TrackdirBits from
  * @return The TrackdirBits which the selected tracks
  */
-static inline TrackdirBits TrackToTrackdirBits(Track track)
+static INLINE TrackdirBits TrackToTrackdirBits(Track track)
 {
 	Trackdir td = TrackToTrackdir(track);
 	return (TrackdirBits)(TrackdirToTrackdirBits(td) | TrackdirToTrackdirBits(ReverseTrackdir(td)));
@@ -298,7 +298,7 @@
  * @param bits The TrackdirBits to get the TrackBits from
  * @return The TrackBits
  */
-static inline TrackBits TrackdirBitsToTrackBits(TrackdirBits bits)
+static INLINE TrackBits TrackdirBitsToTrackBits(TrackdirBits bits)
 {
 	return (TrackBits)((bits | (bits >> 8)) & TRACK_BIT_MASK);
 }
@@ -309,7 +309,7 @@
  * @param bits The TrackBits
  * @return The TrackdirBits containing of bits in both directions.
  */
-static inline TrackdirBits TrackBitsToTrackdirBits(TrackBits bits)
+static INLINE TrackdirBits TrackBitsToTrackdirBits(TrackBits bits)
 {
 	return (TrackdirBits)(bits * 0x101);
 }
@@ -320,7 +320,7 @@
  * @param ts The TrackStatus returned by GetTileTrackStatus()
  * @return the present trackdirs
  */
-static inline TrackdirBits TrackStatusToTrackdirBits(TrackStatus ts)
+static INLINE TrackdirBits TrackStatusToTrackdirBits(TrackStatus ts)
 {
 	return (TrackdirBits)(ts & TRACKDIR_BIT_MASK);
 }
@@ -331,7 +331,7 @@
  * @param ts The TrackStatus returned by GetTileTrackStatus()
  * @return the present tracks
  */
-static inline TrackBits TrackStatusToTrackBits(TrackStatus ts)
+static INLINE TrackBits TrackStatusToTrackBits(TrackStatus ts)
 {
 	return TrackdirBitsToTrackBits(TrackStatusToTrackdirBits(ts));
 }
@@ -344,7 +344,7 @@
  * @param ts The TrackStatus returned by GetTileTrackStatus()
  * @return the The trackdirs that are blocked by red-signals
  */
-static inline TrackdirBits TrackStatusToRedSignals(TrackStatus ts)
+static INLINE TrackdirBits TrackStatusToRedSignals(TrackStatus ts)
 {
 	return (TrackdirBits)((ts >> 16) & TRACKDIR_BIT_MASK);
 }
@@ -356,7 +356,7 @@
  * @param red_signals red signals
  * @return the TrackStatus representing the given information
  */
-static inline TrackStatus CombineTrackStatus(TrackdirBits trackdirbits, TrackdirBits red_signals)
+static INLINE TrackStatus CombineTrackStatus(TrackdirBits trackdirbits, TrackdirBits red_signals)
 {
 	return (TrackStatus)(trackdirbits | (red_signals << 16));
 }
@@ -371,7 +371,7 @@
  * @param trackdir The given trackdir
  * @return The next Trackdir value of the next tile.
  */
-static inline Trackdir NextTrackdir(Trackdir trackdir)
+static INLINE Trackdir NextTrackdir(Trackdir trackdir)
 {
 	extern const Trackdir _next_trackdir[TRACKDIR_END];
 	return _next_trackdir[trackdir];
@@ -387,7 +387,7 @@
  * @param track The given track
  * @return The TrackBits with the tracks marked which cross the given track by 90 deg.
  */
-static inline TrackBits TrackCrossesTracks(Track track)
+static INLINE TrackBits TrackCrossesTracks(Track track)
 {
 	extern const TrackBits _track_crosses_tracks[TRACK_END];
 	return _track_crosses_tracks[track];
@@ -405,7 +405,7 @@
  * @param trackdir The given track direction
  * @return The direction which points to the resulting tile if following the Trackdir
  */
-static inline DiagDirection TrackdirToExitdir(Trackdir trackdir)
+static INLINE DiagDirection TrackdirToExitdir(Trackdir trackdir)
 {
 	extern const DiagDirection _trackdir_to_exitdir[TRACKDIR_END];
 	return _trackdir_to_exitdir[trackdir];
@@ -426,7 +426,7 @@
  * @param diagdir The DiagDirection to applie on
  * @return The resulting track direction or INVALID_TRACKDIR if not possible.
  */
-static inline Trackdir TrackExitdirToTrackdir(Track track, DiagDirection diagdir)
+static INLINE Trackdir TrackExitdirToTrackdir(Track track, DiagDirection diagdir)
 {
 	extern const Trackdir _track_exitdir_to_trackdir[TRACK_END][DIAGDIR_END];
 	return _track_exitdir_to_trackdir[track][diagdir];
@@ -449,7 +449,7 @@
  * @param diagdir The direction to "come from"
  * @return the resulting Trackdir or INVALID_TRACKDIR if not possible.
  */
-static inline Trackdir TrackEnterdirToTrackdir(Track track, DiagDirection diagdir)
+static INLINE Trackdir TrackEnterdirToTrackdir(Track track, DiagDirection diagdir)
 {
 	extern const Trackdir _track_enterdir_to_trackdir[TRACK_END][DIAGDIR_END];
 	return _track_enterdir_to_trackdir[track][diagdir];
@@ -459,7 +459,7 @@
  * Maps a track and a full (8-way) direction to the trackdir that represents
  * the track running in the given direction.
  */
-static inline Trackdir TrackDirectionToTrackdir(Track track, Direction dir)
+static INLINE Trackdir TrackDirectionToTrackdir(Track track, Direction dir)
 {
 	extern const Trackdir _track_direction_to_trackdir[TRACK_END][DIR_END];
 	return _track_direction_to_trackdir[track][dir];
@@ -471,7 +471,7 @@
  * @param diagdir The direction
  * @return The resulting Track
  */
-static inline Track DiagDirToDiagTrack(DiagDirection diagdir)
+static INLINE Track DiagDirToDiagTrack(DiagDirection diagdir)
 {
 	return (Track)(diagdir & 1);
 }
@@ -482,7 +482,7 @@
  * @param diagdir The direction
  * @return The resulting TrackBits
  */
-static inline TrackBits DiagDirToDiagTrackBits(DiagDirection diagdir)
+static INLINE TrackBits DiagDirToDiagTrackBits(DiagDirection diagdir)
 {
 	return TrackToTrackBits(DiagDirToDiagTrack(diagdir));
 }
@@ -494,7 +494,7 @@
  * @param diagdir The direction
  * @return The resulting Trackdir direction
  */
-static inline Trackdir DiagDirToDiagTrackdir(DiagDirection diagdir)
+static INLINE Trackdir DiagDirToDiagTrackdir(DiagDirection diagdir)
 {
 	extern const Trackdir _dir_to_diag_trackdir[DIAGDIR_END];
 	return _dir_to_diag_trackdir[diagdir];
@@ -511,7 +511,7 @@
  * @return The TrackdirBits which can be used from the given direction
  * @see DiagdirReachesTracks
  */
-static inline TrackdirBits DiagdirReachesTrackdirs(DiagDirection diagdir)
+static INLINE TrackdirBits DiagdirReachesTrackdirs(DiagDirection diagdir)
 {
 	extern const TrackdirBits _exitdir_reaches_trackdirs[DIAGDIR_END];
 	return _exitdir_reaches_trackdirs[diagdir];
@@ -528,7 +528,7 @@
  * @return The tracks which can be used
  * @see DiagdirReachesTrackdirs
  */
-static inline TrackBits DiagdirReachesTracks(DiagDirection diagdir) { return TrackdirBitsToTrackBits(DiagdirReachesTrackdirs(diagdir)); }
+static INLINE TrackBits DiagdirReachesTracks(DiagDirection diagdir) { return TrackdirBitsToTrackBits(DiagdirReachesTrackdirs(diagdir)); }
 
 /**
  * Maps a trackdir to the trackdirs that can be reached from it (ie, when
@@ -539,7 +539,7 @@
  * @param trackdir The track direction which will be leaved
  * @return The track directions which can be used from this direction (in the next tile)
  */
-static inline TrackdirBits TrackdirReachesTrackdirs(Trackdir trackdir)
+static INLINE TrackdirBits TrackdirReachesTrackdirs(Trackdir trackdir)
 {
 	extern const TrackdirBits _exitdir_reaches_trackdirs[DIAGDIR_END];
 	return _exitdir_reaches_trackdirs[TrackdirToExitdir(trackdir)];
@@ -560,7 +560,7 @@
  * @param trackdir The track direction
  * @return The TrackdirBits which are (more or less) 90 deg turns.
  */
-static inline TrackdirBits TrackdirCrossesTrackdirs(Trackdir trackdir)
+static INLINE TrackdirBits TrackdirCrossesTrackdirs(Trackdir trackdir)
 {
 	extern const TrackdirBits _track_crosses_trackdirs[TRACKDIR_END];
 	return _track_crosses_trackdirs[TrackdirToTrack(trackdir)];
@@ -572,7 +572,7 @@
  * @param track The given track to check
  * @return true if diagonal, else false
  */
-static inline bool IsDiagonalTrack(Track track)
+static INLINE bool IsDiagonalTrack(Track track)
 {
 	return (track == TRACK_X) || (track == TRACK_Y);
 }
@@ -583,7 +583,7 @@
  * @param trackdir The given trackdir
  * @return true if the trackdir use a diagonal track
  */
-static inline bool IsDiagonalTrackdir(Trackdir trackdir)
+static INLINE bool IsDiagonalTrackdir(Trackdir trackdir)
 {
 	return IsDiagonalTrack(TrackdirToTrack(trackdir));
 }
@@ -596,7 +596,7 @@
  * @param  bits The tracks present.
  * @return Whether the tracks present overlap in any way.
  */
-static inline bool TracksOverlap(TrackBits bits)
+static INLINE bool TracksOverlap(TrackBits bits)
 {
 	/* With no, or only one track, there is no overlap */
 	if (bits == TRACK_BIT_NONE || KillFirstBit(bits) == TRACK_BIT_NONE) return false;
@@ -613,7 +613,7 @@
  * @param track The track to test
  * @return true if the track is already in the tracks or overlaps the tracks.
  */
-static inline bool TrackOverlapsTracks(TrackBits tracks, Track track)
+static INLINE bool TrackOverlapsTracks(TrackBits tracks, Track track)
 {
 	if (HasBit(tracks, track)) return true;
 	return TracksOverlap(tracks | TrackToTrackBits(track));
@@ -624,7 +624,7 @@
  * @param dir the trackdir to check
  * @return true if it is a reversing road trackdir
  */
-static inline bool IsReversingRoadTrackdir(Trackdir dir)
+static INLINE bool IsReversingRoadTrackdir(Trackdir dir)
 {
 	return (dir & 0x07) >= 6;
 }
@@ -634,7 +634,7 @@
  * @param dir the trackdir to check
  * @return true if it is a straight road trackdir
  */
-static inline bool IsStraightRoadTrackdir(Trackdir dir)
+static INLINE bool IsStraightRoadTrackdir(Trackdir dir)
 {
 	return (dir & 0x06) == 0;
 }
@@ -649,7 +649,7 @@
  * @param dir The trackdir of interest.
  * @return true iff the track goes upwards.
  */
-static inline bool IsUphillTrackdir(Slope slope, Trackdir dir)
+static INLINE bool IsUphillTrackdir(Slope slope, Trackdir dir)
 {
 	extern const TrackdirBits _uphill_trackdirs[];
 	return HasBit(_uphill_trackdirs[RemoveHalftileSlope(slope)], dir);
diff --git a/src/train.h b/src/train.h
--- a/src/train.h
+++ b/src/train.h
@@ -125,7 +125,7 @@
 	 * Get the next real (non-articulated part and non rear part of dualheaded engine) vehicle in the consist.
 	 * @return Next vehicle in the consist.
 	 */
-	inline Train *GetNextUnit() const
+	INLINE Train *GetNextUnit() const
 	{
 		Train *v = this->GetNextVehicle();
 		if (v != NULL && v->IsRearDualheaded()) v = v->GetNextVehicle();
@@ -137,7 +137,7 @@
 	 * Get the previous real (non-articulated part and non rear part of dualheaded engine) vehicle in the consist.
 	 * @return Previous vehicle in the consist.
 	 */
-	inline Train *GetPrevUnit()
+	INLINE Train *GetPrevUnit()
 	{
 		Train *v = this->GetPrevVehicle();
 		if (v != NULL && v->IsRearDualheaded()) v = v->GetPrevVehicle();
@@ -164,7 +164,7 @@
 	 * Allows to know the power value that this vehicle will use.
 	 * @return Power value from the engine in HP, or zero if the vehicle is not powered.
 	 */
-	inline uint16 GetPower() const
+	INLINE uint16 GetPower() const
 	{
 		/* Power is not added for articulated parts */
 		if (!this->IsArticulatedPart() && HasPowerOnRail(this->railtype, GetRailType(this->tile))) {
@@ -181,7 +181,7 @@
 	 * Returns a value if this articulated part is powered.
 	 * @return Power value from the articulated part in HP, or zero if it is not powered.
 	 */
-	inline uint16 GetPoweredPartPower(const Train *head) const
+	INLINE uint16 GetPoweredPartPower(const Train *head) const
 	{
 		/* For powered wagons the engine defines the type of engine (i.e. railtype) */
 		if (HasBit(this->flags, VRF_POWEREDWAGON) && HasPowerOnRail(head->railtype, GetRailType(this->tile))) {
@@ -195,7 +195,7 @@
 	 * Allows to know the weight value that this vehicle will use.
 	 * @return Weight value from the engine in tonnes.
 	 */
-	inline uint16 GetWeight() const
+	INLINE uint16 GetWeight() const
 	{
 		uint16 weight = (CargoSpec::Get(this->cargo_type)->weight * this->cargo.Count() * FreightWagonMult(this->cargo_type)) / 16;
 
@@ -216,7 +216,7 @@
 	 * Allows to know the tractive effort value that this vehicle will use.
 	 * @return Tractive effort value from the engine.
 	 */
-	inline byte GetTractiveEffort() const
+	INLINE byte GetTractiveEffort() const
 	{
 		return GetVehicleProperty(this, PROP_TRAIN_TRACTIVE_EFFORT, RailVehInfo(this->engine_type)->tractive_effort);
 	}
@@ -225,7 +225,7 @@
 	 * Gets the area used for calculating air drag.
 	 * @return Area of the engine in m^2.
 	 */
-	inline byte GetAirDragArea() const
+	INLINE byte GetAirDragArea() const
 	{
 		/* Air drag is higher in tunnels due to the limited cross-section. */
 		return (this->track == TRACK_BIT_WORMHOLE && this->vehstatus & VS_HIDDEN) ? 28 : 14;
@@ -235,7 +235,7 @@
 	 * Gets the air drag coefficient of this vehicle.
 	 * @return Air drag value from the engine.
 	 */
-	inline byte GetAirDrag() const
+	INLINE byte GetAirDrag() const
 	{
 		return RailVehInfo(this->engine_type)->air_drag;
 	}
@@ -244,7 +244,7 @@
 	 * Checks the current acceleration status of this vehicle.
 	 * @return Acceleration status.
 	 */
-	inline AccelStatus GetAccelerationStatus() const
+	INLINE AccelStatus GetAccelerationStatus() const
 	{
 		return (this->vehstatus & VS_STOPPED) || HasBit(this->flags, VRF_REVERSING) || HasBit(this->flags, VRF_TRAIN_STUCK) ? AS_BRAKE : AS_ACCEL;
 	}
@@ -253,7 +253,7 @@
 	 * Calculates the current speed of this vehicle.
 	 * @return Current speed in km/h-ish.
 	 */
-	inline uint16 GetCurrentSpeed() const
+	INLINE uint16 GetCurrentSpeed() const
 	{
 		return this->cur_speed;
 	}
@@ -262,7 +262,7 @@
 	 * Returns the rolling friction coefficient of this vehicle.
 	 * @return Rolling friction coefficient in [1e-4].
 	 */
-	inline uint32 GetRollingFriction() const
+	INLINE uint32 GetRollingFriction() const
 	{
 		/* Rolling friction for steel on steel is between 0.1% and 0.2%.
 		 * The friction coefficient increases with speed in a way that
@@ -274,7 +274,7 @@
 	 * Allows to know the acceleration type of a vehicle.
 	 * @return Acceleration type of the vehicle.
 	 */
-	inline int GetAccelerationType() const
+	INLINE int GetAccelerationType() const
 	{
 		return GetRailTypeInfo(this->railtype)->acceleration_type;
 	}
@@ -283,7 +283,7 @@
 	 * Returns the slope steepness used by this vehicle.
 	 * @return Slope steepness used by the vehicle.
 	 */
-	inline uint32 GetSlopeSteepness() const
+	INLINE uint32 GetSlopeSteepness() const
 	{
 		return _settings_game.vehicle.train_slope_steepness;
 	}
@@ -292,7 +292,7 @@
 	 * Gets the maximum speed allowed by the track for this vehicle.
 	 * @return Maximum speed allowed.
 	 */
-	inline uint16 GetMaxTrackSpeed() const
+	INLINE uint16 GetMaxTrackSpeed() const
 	{
 		return GetRailTypeInfo(GetRailType(this->tile))->max_speed;
 	}
@@ -301,7 +301,7 @@
 	 * Checks if the vehicle is at a tile that can be sloped.
 	 * @return True if the tile can be sloped.
 	 */
-	inline bool TileMayHaveSlopedTrack() const
+	INLINE bool TileMayHaveSlopedTrack() const
 	{
 		/* Any track that isn't TRACK_BIT_X or TRACK_BIT_Y cannot be sloped. */
 		return this->track == TRACK_BIT_X || this->track == TRACK_BIT_Y;
@@ -312,7 +312,7 @@
 	 * have always the same direction as the track under them.
 	 * @return false
 	 */
-	inline bool HasToUseGetSlopePixelZ()
+	INLINE bool HasToUseGetSlopePixelZ()
 	{
 		return false;
 	}
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -56,7 +56,7 @@
  * @param track vehicle track bits
  * @return side of tile the train will leave
  */
-static inline DiagDirection TrainExitDir(Direction direction, TrackBits track)
+static INLINE DiagDirection TrainExitDir(Direction direction, TrackBits track)
 {
 	static const TrackBits state_dir_table[DIAGDIR_END] = { TRACK_BIT_RIGHT, TRACK_BIT_LOWER, TRACK_BIT_LEFT, TRACK_BIT_UPPER };
 
@@ -1636,7 +1636,7 @@
  * @param tile tile with crossing
  * @pre tile is a rail-road crossing
  */
-static inline void MaybeBarCrossingWithSound(TileIndex tile)
+static INLINE void MaybeBarCrossingWithSound(TileIndex tile)
 {
 	if (!IsCrossingBarred(tile)) {
 		BarCrossing(tile);
@@ -2777,7 +2777,7 @@
 }
 
 /* Check if the vehicle is compatible with the specified tile */
-static inline bool CheckCompatibleRail(const Train *v, TileIndex tile)
+static INLINE bool CheckCompatibleRail(const Train *v, TileIndex tile)
 {
 	return IsTileOwner(tile, v->owner) &&
 			(!v->IsFrontEngine() || HasBit(v->compatible_railtypes, GetRailType(tile)));
@@ -2804,7 +2804,7 @@
  * @param v %Train to update.
  * @param old_z Previous height.
  */
-static inline void AffectSpeedByZChange(Train *v, int old_z)
+static INLINE void AffectSpeedByZChange(Train *v, int old_z)
 {
 	if (old_z == v->z_pos || _settings_game.vehicle.train_acceleration_model != AM_ORIGINAL) return;
 
diff --git a/src/train_gui.cpp b/src/train_gui.cpp
--- a/src/train_gui.cpp
+++ b/src/train_gui.cpp
@@ -164,7 +164,7 @@
 	StationID source; ///< One of the source stations
 
 	/** Used by CargoSummary::Find() and similiar functions */
-	inline bool operator != (const CargoSummaryItem &other) const
+	INLINE bool operator != (const CargoSummaryItem &other) const
 	{
 		return this->cargo != other.cargo || this->subtype != other.subtype;
 	}
diff --git a/src/transparency.h b/src/transparency.h
--- a/src/transparency.h
+++ b/src/transparency.h
@@ -47,7 +47,7 @@
  *
  * @param to the structure which transparency option is ask for
  */
-static inline bool IsTransparencySet(TransparencyOption to)
+static INLINE bool IsTransparencySet(TransparencyOption to)
 {
 	return (HasBit(_transparency_opt, to) && _game_mode != GM_MENU);
 }
@@ -58,7 +58,7 @@
  *
  * @param to the structure which invisibility option is ask for
  */
-static inline bool IsInvisibilitySet(TransparencyOption to)
+static INLINE bool IsInvisibilitySet(TransparencyOption to)
 {
 	return (HasBit(_transparency_opt & _invisibility_opt, to) && _game_mode != GM_MENU);
 }
@@ -68,7 +68,7 @@
  *
  * @param to the transparency option to be toggled
  */
-static inline void ToggleTransparency(TransparencyOption to)
+static INLINE void ToggleTransparency(TransparencyOption to)
 {
 	ToggleBit(_transparency_opt, to);
 }
@@ -78,7 +78,7 @@
  *
  * @param to the structure which invisibility option is toggle
  */
-static inline void ToggleInvisibility(TransparencyOption to)
+static INLINE void ToggleInvisibility(TransparencyOption to)
 {
 	ToggleBit(_invisibility_opt, to);
 }
@@ -90,7 +90,7 @@
  *
  * @param to the object type which invisibility option to toggle
  */
-static inline void ToggleInvisibilityWithTransparency(TransparencyOption to)
+static INLINE void ToggleInvisibilityWithTransparency(TransparencyOption to)
 {
 	if (IsInvisibilitySet(to)) {
 		ClrBit(_invisibility_opt, to);
@@ -106,13 +106,13 @@
  *
  * @param to the transparency option to be locked or unlocked
  */
-static inline void ToggleTransparencyLock(TransparencyOption to)
+static INLINE void ToggleTransparencyLock(TransparencyOption to)
 {
 	ToggleBit(_transparency_lock, to);
 }
 
 /** Set or clear all non-locked transparency options */
-static inline void ResetRestoreAllTransparency()
+static INLINE void ResetRestoreAllTransparency()
 {
 	/* if none of the non-locked options are set */
 	if ((_transparency_opt & ~_transparency_lock) == 0) {
diff --git a/src/tree_map.h b/src/tree_map.h
--- a/src/tree_map.h
+++ b/src/tree_map.h
@@ -71,7 +71,7 @@
  * @return The treetype of the given tile with trees
  * @pre Tile t must be of type MP_TREES
  */
-static inline TreeType GetTreeType(TileIndex t)
+static INLINE TreeType GetTreeType(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return (TreeType)_m[t].m3;
@@ -86,7 +86,7 @@
  * @return The groundtype of the tile
  * @pre Tile must be of type MP_TREES
  */
-static inline TreeGround GetTreeGround(TileIndex t)
+static INLINE TreeGround GetTreeGround(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return (TreeGround)GB(_m[t].m2, 6, 3);
@@ -111,7 +111,7 @@
  * @pre Tile must be of type MP_TREES
  * @see GetTreeCount
  */
-static inline uint GetTreeDensity(TileIndex t)
+static INLINE uint GetTreeDensity(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return GB(_m[t].m2, 4, 2);
@@ -128,7 +128,7 @@
  * @param d The density to save with
  * @pre Tile must be of type MP_TREES
  */
-static inline void SetTreeGroundDensity(TileIndex t, TreeGround g, uint d)
+static INLINE void SetTreeGroundDensity(TileIndex t, TreeGround g, uint d)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	SB(_m[t].m2, 4, 2, d);
@@ -146,7 +146,7 @@
  * @return The number of trees (1-4)
  * @pre Tile must be of type MP_TREES
  */
-static inline uint GetTreeCount(TileIndex t)
+static INLINE uint GetTreeCount(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return GB(_m[t].m5, 6, 2) + 1;
@@ -163,7 +163,7 @@
  * @param c The value to add (or reduce) on the tree-count value
  * @pre Tile must be of type MP_TREES
  */
-static inline void AddTreeCount(TileIndex t, int c)
+static INLINE void AddTreeCount(TileIndex t, int c)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	_m[t].m5 += c << 6;
@@ -178,7 +178,7 @@
  * @return The tree growth status
  * @pre Tile must be of type MP_TREES
  */
-static inline uint GetTreeGrowth(TileIndex t)
+static INLINE uint GetTreeGrowth(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return GB(_m[t].m5, 0, 3);
@@ -193,7 +193,7 @@
  * @param a The value to add on the tree growth status
  * @pre Tile must be of type MP_TREES
  */
-static inline void AddTreeGrowth(TileIndex t, int a)
+static INLINE void AddTreeGrowth(TileIndex t, int a)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	_m[t].m5 += a;
@@ -209,7 +209,7 @@
  * @param g The new value
  * @pre Tile must be of type MP_TREES
  */
-static inline void SetTreeGrowth(TileIndex t, uint g)
+static INLINE void SetTreeGrowth(TileIndex t, uint g)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	SB(_m[t].m5, 0, 3, g);
@@ -223,7 +223,7 @@
  * @param t The tile to get the counter value from
  * @pre Tile must be of type MP_TREES
  */
-static inline uint GetTreeCounter(TileIndex t)
+static INLINE uint GetTreeCounter(TileIndex t)
 {
 	assert(IsTileType(t, MP_TREES));
 	return GB(_m[t].m2, 0, 4);
@@ -238,7 +238,7 @@
  * @param a The value to add on the tick counter
  * @pre Tile must be of type MP_TREES
  */
-static inline void AddTreeCounter(TileIndex t, int a)
+static INLINE void AddTreeCounter(TileIndex t, int a)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	_m[t].m2 += a;
@@ -253,7 +253,7 @@
  * @param c The new tick counter value
  * @pre Tile must be of type MP_TREES
  */
-static inline void SetTreeCounter(TileIndex t, uint c)
+static INLINE void SetTreeCounter(TileIndex t, uint c)
 {
 	assert(IsTileType(t, MP_TREES)); // XXX incomplete
 	SB(_m[t].m2, 0, 4, c);
@@ -271,7 +271,7 @@
  * @param ground the ground type
  * @param density the density (not the number of trees)
  */
-static inline void MakeTree(TileIndex t, TreeType type, uint count, uint growth, TreeGround ground, uint density)
+static INLINE void MakeTree(TileIndex t, TreeType type, uint count, uint growth, TreeGround ground, uint density)
 {
 	SetTileType(t, MP_TREES);
 	SetTileOwner(t, OWNER_NONE);
diff --git a/src/tunnel_map.h b/src/tunnel_map.h
--- a/src/tunnel_map.h
+++ b/src/tunnel_map.h
@@ -21,7 +21,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return true if and only if this tile is a tunnel (entrance)
  */
-static inline bool IsTunnel(TileIndex t)
+static INLINE bool IsTunnel(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return !HasBit(_m[t].m5, 7);
@@ -32,7 +32,7 @@
  * @param t the tile that might be a tunnel
  * @return true if and only if this tile is a tunnel (entrance)
  */
-static inline bool IsTunnelTile(TileIndex t)
+static INLINE bool IsTunnelTile(TileIndex t)
 {
 	return IsTileType(t, MP_TUNNELBRIDGE) && IsTunnel(t);
 }
@@ -48,7 +48,7 @@
  * @param d the direction facing out of the tunnel
  * @param r the road type used in the tunnel
  */
-static inline void MakeRoadTunnel(TileIndex t, Owner o, DiagDirection d, RoadTypes r)
+static INLINE void MakeRoadTunnel(TileIndex t, Owner o, DiagDirection d, RoadTypes r)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
@@ -70,7 +70,7 @@
  * @param d the direction facing out of the tunnel
  * @param r the rail type used in the tunnel
  */
-static inline void MakeRailTunnel(TileIndex t, Owner o, DiagDirection d, RailType r)
+static INLINE void MakeRailTunnel(TileIndex t, Owner o, DiagDirection d, RailType r)
 {
 	SetTileType(t, MP_TUNNELBRIDGE);
 	SetTileOwner(t, o);
diff --git a/src/tunnelbridge.h b/src/tunnelbridge.h
--- a/src/tunnelbridge.h
+++ b/src/tunnelbridge.h
@@ -20,7 +20,7 @@
  * @param end   The end of the tunnel or bridge.
  * @return length of bridge/tunnel middle
  */
-static inline uint GetTunnelBridgeLength(TileIndex begin, TileIndex end)
+static INLINE uint GetTunnelBridgeLength(TileIndex begin, TileIndex end)
 {
 	int x1 = TileX(begin);
 	int y1 = TileY(begin);
diff --git a/src/tunnelbridge_cmd.cpp b/src/tunnelbridge_cmd.cpp
--- a/src/tunnelbridge_cmd.cpp
+++ b/src/tunnelbridge_cmd.cpp
@@ -117,7 +117,7 @@
 	return (tileh != SLOPE_FLAT);
 }
 
-static inline const PalSpriteID *GetBridgeSpriteTable(int index, BridgePieces table)
+static INLINE const PalSpriteID *GetBridgeSpriteTable(int index, BridgePieces table)
 {
 	const BridgeSpec *bridge = GetBridgeSpec(index);
 	assert(table < BRIDGE_PIECE_INVALID);
@@ -696,7 +696,7 @@
  * @param tile End point of the tunnel or bridge.
  * @return A succeeded command if the tunnel or bridge may be removed, a failed command otherwise.
  */
-static inline CommandCost CheckAllowRemoveTunnelBridge(TileIndex tile)
+static INLINE CommandCost CheckAllowRemoveTunnelBridge(TileIndex tile)
 {
 	/* Floods can remove anything as well as the scenario editor */
 	if (_current_company == OWNER_WATER || _game_mode == GM_EDITOR) return CommandCost();
@@ -943,7 +943,7 @@
  * @param h         Bounding box size in Y direction
  * @param subsprite Optional subsprite for drawing halfpillars
  */
-static inline void DrawPillar(const PalSpriteID *psid, int x, int y, int z, int w, int h, const SubSprite *subsprite)
+static INLINE void DrawPillar(const PalSpriteID *psid, int x, int y, int z, int w, int h, const SubSprite *subsprite)
 {
 	static const int PILLAR_Z_OFFSET = TILE_HEIGHT - BRIDGE_Z_START; ///< Start offset of pillar wrt. bridge (downwards)
 	AddSortableSpriteToDraw(psid->sprite, psid->pal, x, y, w, h, BB_HEIGHT_UNDER_BRIDGE - PILLAR_Z_OFFSET, z, IsTransparencySet(TO_BRIDGES), 0, 0, -PILLAR_Z_OFFSET, subsprite);
diff --git a/src/tunnelbridge_map.h b/src/tunnelbridge_map.h
--- a/src/tunnelbridge_map.h
+++ b/src/tunnelbridge_map.h
@@ -25,7 +25,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return the above mentionned direction
  */
-static inline DiagDirection GetTunnelBridgeDirection(TileIndex t)
+static INLINE DiagDirection GetTunnelBridgeDirection(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return (DiagDirection)GB(_m[t].m5, 0, 2);
@@ -38,7 +38,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return the transport type in the tunnel/bridge
  */
-static inline TransportType GetTunnelBridgeTransportType(TileIndex t)
+static INLINE TransportType GetTunnelBridgeTransportType(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return (TransportType)GB(_m[t].m5, 2, 2);
@@ -51,7 +51,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return true if and only if the tile is in a snowy/desert area
  */
-static inline bool HasTunnelBridgeSnowOrDesert(TileIndex t)
+static INLINE bool HasTunnelBridgeSnowOrDesert(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return HasBit(_me[t].m7, 5);
@@ -65,7 +65,7 @@
  *                       not in snow and not in desert false
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  */
-static inline void SetTunnelBridgeSnowOrDesert(TileIndex t, bool snow_or_desert)
+static INLINE void SetTunnelBridgeSnowOrDesert(TileIndex t, bool snow_or_desert)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	SB(_me[t].m7, 5, 1, snow_or_desert);
@@ -77,7 +77,7 @@
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
  * @return other end
  */
-static inline TileIndex GetOtherTunnelBridgeEnd(TileIndex t)
+static INLINE TileIndex GetOtherTunnelBridgeEnd(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	return IsTunnel(t) ? GetOtherTunnelEnd(t) : GetOtherBridgeEnd(t);
@@ -90,7 +90,7 @@
  * @param t the tile
  * @return reservation state
  */
-static inline bool HasTunnelBridgeReservation(TileIndex t)
+static INLINE bool HasTunnelBridgeReservation(TileIndex t)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	assert(GetTunnelBridgeTransportType(t) == TRANSPORT_RAIL);
@@ -103,7 +103,7 @@
  * @param t the tile
  * @param b the reservation state
  */
-static inline void SetTunnelBridgeReservation(TileIndex t, bool b)
+static INLINE void SetTunnelBridgeReservation(TileIndex t, bool b)
 {
 	assert(IsTileType(t, MP_TUNNELBRIDGE));
 	assert(GetTunnelBridgeTransportType(t) == TRANSPORT_RAIL);
@@ -116,7 +116,7 @@
  * @param t the tile
  * @return reserved track bits
  */
-static inline TrackBits GetTunnelBridgeReservationTrackBits(TileIndex t)
+static INLINE TrackBits GetTunnelBridgeReservationTrackBits(TileIndex t)
 {
 	return HasTunnelBridgeReservation(t) ? DiagDirToDiagTrackBits(GetTunnelBridgeDirection(t)) : TRACK_BIT_NONE;
 }
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -284,7 +284,7 @@
 	 * @param speed Direction-independent unscaled speed.
 	 * @return speed scaled by movement direction. 256 units are required for each movement step.
 	 */
-	inline uint GetOldAdvanceSpeed(uint speed)
+	INLINE uint GetOldAdvanceSpeed(uint speed)
 	{
 		return (this->direction & 1) ? speed : speed * 3 / 4;
 	}
@@ -301,7 +301,7 @@
 	 * @param speed Direction-independent unscaled speed.
 	 * @return speed, scaled to match #GetAdvanceDistance().
 	 */
-	static inline uint GetAdvanceSpeed(uint speed)
+	static INLINE uint GetAdvanceSpeed(uint speed)
 	{
 		return speed * 3 / 4;
 	}
@@ -313,7 +313,7 @@
 	 *
 	 * @return distance to drive for a movement step on the map.
 	 */
-	inline uint GetAdvanceDistance()
+	INLINE uint GetAdvanceDistance()
 	{
 		return (this->direction & 1) ? 192 : 256;
 	}
@@ -350,7 +350,7 @@
 	 * Invalidates cached NewGRF variables
 	 * @see InvalidateNewGRFCacheOfChain
 	 */
-	inline void InvalidateNewGRFCache()
+	INLINE void InvalidateNewGRFCache()
 	{
 		this->grf_cache.cache_valid = 0;
 	}
@@ -359,7 +359,7 @@
 	 * Invalidates cached NewGRF variables of all vehicles in the chain (after the current vehicle)
 	 * @see InvalidateNewGRFCache
 	 */
-	inline void InvalidateNewGRFCacheOfChain()
+	INLINE void InvalidateNewGRFCacheOfChain()
 	{
 		for (Vehicle *u = this; u != NULL; u = u->Next()) {
 			u->InvalidateNewGRFCache();
@@ -370,7 +370,7 @@
 	 * Check if the vehicle is a ground vehicle.
 	 * @return True iff the vehicle is a train or a road vehicle.
 	 */
-	inline bool IsGroundVehicle() const
+	INLINE bool IsGroundVehicle() const
 	{
 		return this->type == VEH_TRAIN || this->type == VEH_ROAD;
 	}
@@ -480,26 +480,26 @@
 	 * @note articulated parts are also counted as vehicles.
 	 * @return the next vehicle or NULL when there isn't a next vehicle.
 	 */
-	inline Vehicle *Next() const { return this->next; }
+	INLINE Vehicle *Next() const { return this->next; }
 
 	/**
 	 * Get the previous vehicle of this vehicle.
 	 * @note articulated parts are also counted as vehicles.
 	 * @return the previous vehicle or NULL when there isn't a previous vehicle.
 	 */
-	inline Vehicle *Previous() const { return this->previous; }
+	INLINE Vehicle *Previous() const { return this->previous; }
 
 	/**
 	 * Get the first vehicle of this vehicle chain.
 	 * @return the first vehicle of the chain.
 	 */
-	inline Vehicle *First() const { return this->first; }
+	INLINE Vehicle *First() const { return this->first; }
 
 	/**
 	 * Get the last vehicle of this vehicle chain.
 	 * @return the last vehicle of the chain.
 	 */
-	inline Vehicle *Last()
+	INLINE Vehicle *Last()
 	{
 		Vehicle *v = this;
 		while (v->Next() != NULL) v = v->Next();
@@ -510,7 +510,7 @@
 	 * Get the last vehicle of this vehicle chain.
 	 * @return the last vehicle of the chain.
 	 */
-	inline const Vehicle *Last() const
+	INLINE const Vehicle *Last() const
 	{
 		const Vehicle *v = this;
 		while (v->Next() != NULL) v = v->Next();
@@ -522,7 +522,7 @@
 	 * @param n Offset from the current vehicle.
 	 * @return The new vehicle or NULL if the offset is out-of-bounds.
 	 */
-	inline Vehicle *Move(int n)
+	INLINE Vehicle *Move(int n)
 	{
 		Vehicle *v = this;
 		if (n < 0) {
@@ -538,7 +538,7 @@
 	 * @param n Offset from the current vehicle.
 	 * @return The new vehicle or NULL if the offset is out-of-bounds.
 	 */
-	inline const Vehicle *Move(int n) const
+	INLINE const Vehicle *Move(int n) const
 	{
 		const Vehicle *v = this;
 		if (n < 0) {
@@ -553,7 +553,7 @@
 	 * Get the first order of the vehicles order list.
 	 * @return first order of order list.
 	 */
-	inline Order *GetFirstOrder() const { return (this->orders.list == NULL) ? NULL : this->orders.list->GetFirstOrder(); }
+	INLINE Order *GetFirstOrder() const { return (this->orders.list == NULL) ? NULL : this->orders.list->GetFirstOrder(); }
 
 	void AddToShared(Vehicle *shared_chain);
 	void RemoveFromShared();
@@ -562,37 +562,37 @@
 	 * Get the next vehicle of the shared vehicle chain.
 	 * @return the next shared vehicle or NULL when there isn't a next vehicle.
 	 */
-	inline Vehicle *NextShared() const { return this->next_shared; }
+	INLINE Vehicle *NextShared() const { return this->next_shared; }
 
 	/**
 	 * Get the previous vehicle of the shared vehicle chain
 	 * @return the previous shared vehicle or NULL when there isn't a previous vehicle.
 	 */
-	inline Vehicle *PreviousShared() const { return this->previous_shared; }
+	INLINE Vehicle *PreviousShared() const { return this->previous_shared; }
 
 	/**
 	 * Get the first vehicle of this vehicle chain.
 	 * @return the first vehicle of the chain.
 	 */
-	inline Vehicle *FirstShared() const { return (this->orders.list == NULL) ? this->First() : this->orders.list->GetFirstSharedVehicle(); }
+	INLINE Vehicle *FirstShared() const { return (this->orders.list == NULL) ? this->First() : this->orders.list->GetFirstSharedVehicle(); }
 
 	/**
 	 * Check if we share our orders with another vehicle.
 	 * @return true if there are other vehicles sharing the same order
 	 */
-	inline bool IsOrderListShared() const { return this->orders.list != NULL && this->orders.list->IsShared(); }
+	INLINE bool IsOrderListShared() const { return this->orders.list != NULL && this->orders.list->IsShared(); }
 
 	/**
 	 * Get the number of orders this vehicle has.
 	 * @return the number of orders this vehicle has.
 	 */
-	inline VehicleOrderID GetNumOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumOrders(); }
+	INLINE VehicleOrderID GetNumOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumOrders(); }
 
 	/**
 	 * Get the number of manually added orders this vehicle has.
 	 * @return the number of manually added orders this vehicle has.
 	 */
-	inline VehicleOrderID GetNumManualOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumManualOrders(); }
+	INLINE VehicleOrderID GetNumManualOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumManualOrders(); }
 
 	/**
 	 * Copy certain configurations and statistics of a vehicle after successful autoreplace/renew
@@ -600,7 +600,7 @@
 	 * and that shall not be resetted for the new vehicle.
 	 * @param src The old vehicle
 	 */
-	inline void CopyVehicleConfigAndStatistics(const Vehicle *src)
+	INLINE void CopyVehicleConfigAndStatistics(const Vehicle *src)
 	{
 		this->CopyConsistPropertiesFrom(src);
 
@@ -729,7 +729,7 @@
 	 * @param index the order to fetch
 	 * @return the found (or not) order
 	 */
-	inline Order *GetOrder(int index) const
+	INLINE Order *GetOrder(int index) const
 	{
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetOrderAt(index);
 	}
@@ -738,7 +738,7 @@
 	 * Returns the last order of a vehicle, or NULL if it doesn't exists
 	 * @return last order of a vehicle, if available
 	 */
-	inline Order *GetLastOrder() const
+	INLINE Order *GetLastOrder() const
 	{
 		return (this->orders.list == NULL) ? NULL : this->orders.list->GetLastOrder();
 	}
@@ -752,7 +752,7 @@
 	 * Check if the vehicle is a front engine.
 	 * @return Returns true if the vehicle is a front engine.
 	 */
-	inline bool IsFrontEngine() const
+	INLINE bool IsFrontEngine() const
 	{
 		return this->IsGroundVehicle() && HasBit(this->subtype, GVSF_FRONT);
 	}
@@ -761,7 +761,7 @@
 	 * Check if the vehicle is an articulated part of an engine.
 	 * @return Returns true if the vehicle is an articulated part.
 	 */
-	inline bool IsArticulatedPart() const
+	INLINE bool IsArticulatedPart() const
 	{
 		return this->IsGroundVehicle() && HasBit(this->subtype, GVSF_ARTICULATED_PART);
 	}
@@ -770,7 +770,7 @@
 	 * Check if an engine has an articulated part.
 	 * @return True if the engine has an articulated part.
 	 */
-	inline bool HasArticulatedPart() const
+	INLINE bool HasArticulatedPart() const
 	{
 		return this->Next() != NULL && this->Next()->IsArticulatedPart();
 	}
@@ -780,7 +780,7 @@
 	 * @return Next part of the articulated engine.
 	 * @pre The vehicle is an articulated engine.
 	 */
-	inline Vehicle *GetNextArticulatedPart() const
+	INLINE Vehicle *GetNextArticulatedPart() const
 	{
 		assert(this->HasArticulatedPart());
 		return this->Next();
@@ -790,7 +790,7 @@
 	 * Get the first part of an articulated engine.
 	 * @return First part of the engine.
 	 */
-	inline Vehicle *GetFirstEnginePart()
+	INLINE Vehicle *GetFirstEnginePart()
 	{
 		Vehicle *v = this;
 		while (v->IsArticulatedPart()) v = v->Previous();
@@ -801,7 +801,7 @@
 	 * Get the first part of an articulated engine.
 	 * @return First part of the engine.
 	 */
-	inline const Vehicle *GetFirstEnginePart() const
+	INLINE const Vehicle *GetFirstEnginePart() const
 	{
 		const Vehicle *v = this;
 		while (v->IsArticulatedPart()) v = v->Previous();
@@ -812,7 +812,7 @@
 	 * Get the last part of an articulated engine.
 	 * @return Last part of the engine.
 	 */
-	inline Vehicle *GetLastEnginePart()
+	INLINE Vehicle *GetLastEnginePart()
 	{
 		Vehicle *v = this;
 		while (v->HasArticulatedPart()) v = v->GetNextArticulatedPart();
@@ -823,7 +823,7 @@
 	 * Get the next real (non-articulated part) vehicle in the consist.
 	 * @return Next vehicle in the consist.
 	 */
-	inline Vehicle *GetNextVehicle() const
+	INLINE Vehicle *GetNextVehicle() const
 	{
 		const Vehicle *v = this;
 		while (v->HasArticulatedPart()) v = v->GetNextArticulatedPart();
@@ -836,7 +836,7 @@
 	 * Get the previous real (non-articulated part) vehicle in the consist.
 	 * @return Previous vehicle in the consist.
 	 */
-	inline Vehicle *GetPrevVehicle() const
+	INLINE Vehicle *GetPrevVehicle() const
 	{
 		Vehicle *v = this->Previous();
 		while (v != NULL && v->IsArticulatedPart()) v = v->Previous();
@@ -871,88 +871,88 @@
 	/**
 	 * Set vehicle type correctly
 	 */
-	inline SpecializedVehicle<T, Type>() : Vehicle(Type) { }
+	INLINE SpecializedVehicle<T, Type>() : Vehicle(Type) { }
 
 	/**
 	 * Get the first vehicle in the chain
 	 * @return first vehicle in the chain
 	 */
-	inline T *First() const { return (T *)this->Vehicle::First(); }
+	INLINE T *First() const { return (T *)this->Vehicle::First(); }
 
 	/**
 	 * Get the last vehicle in the chain
 	 * @return last vehicle in the chain
 	 */
-	inline T *Last() { return (T *)this->Vehicle::Last(); }
+	INLINE T *Last() { return (T *)this->Vehicle::Last(); }
 
 	/**
 	 * Get the last vehicle in the chain
 	 * @return last vehicle in the chain
 	 */
-	inline const T *Last() const { return (const T *)this->Vehicle::Last(); }
+	INLINE const T *Last() const { return (const T *)this->Vehicle::Last(); }
 
 	/**
 	 * Get next vehicle in the chain
 	 * @return next vehicle in the chain
 	 */
-	inline T *Next() const { return (T *)this->Vehicle::Next(); }
+	INLINE T *Next() const { return (T *)this->Vehicle::Next(); }
 
 	/**
 	 * Get previous vehicle in the chain
 	 * @return previous vehicle in the chain
 	 */
-	inline T *Previous() const { return (T *)this->Vehicle::Previous(); }
+	INLINE T *Previous() const { return (T *)this->Vehicle::Previous(); }
 
 	/**
 	 * Get the next part of an articulated engine.
 	 * @return Next part of the articulated engine.
 	 * @pre The vehicle is an articulated engine.
 	 */
-	inline T *GetNextArticulatedPart() { return (T *)this->Vehicle::GetNextArticulatedPart(); }
+	INLINE T *GetNextArticulatedPart() { return (T *)this->Vehicle::GetNextArticulatedPart(); }
 
 	/**
 	 * Get the next part of an articulated engine.
 	 * @return Next part of the articulated engine.
 	 * @pre The vehicle is an articulated engine.
 	 */
-	inline T *GetNextArticulatedPart() const { return (T *)this->Vehicle::GetNextArticulatedPart(); }
+	INLINE T *GetNextArticulatedPart() const { return (T *)this->Vehicle::GetNextArticulatedPart(); }
 
 	/**
 	 * Get the first part of an articulated engine.
 	 * @return First part of the engine.
 	 */
-	inline T *GetFirstEnginePart() { return (T *)this->Vehicle::GetFirstEnginePart(); }
+	INLINE T *GetFirstEnginePart() { return (T *)this->Vehicle::GetFirstEnginePart(); }
 
 	/**
 	 * Get the first part of an articulated engine.
 	 * @return First part of the engine.
 	 */
-	inline const T *GetFirstEnginePart() const { return (const T *)this->Vehicle::GetFirstEnginePart(); }
+	INLINE const T *GetFirstEnginePart() const { return (const T *)this->Vehicle::GetFirstEnginePart(); }
 
 	/**
 	 * Get the last part of an articulated engine.
 	 * @return Last part of the engine.
 	 */
-	inline T *GetLastEnginePart() { return (T *)this->Vehicle::GetLastEnginePart(); }
+	INLINE T *GetLastEnginePart() { return (T *)this->Vehicle::GetLastEnginePart(); }
 
 	/**
 	 * Get the next real (non-articulated part) vehicle in the consist.
 	 * @return Next vehicle in the consist.
 	 */
-	inline T *GetNextVehicle() const { return (T *)this->Vehicle::GetNextVehicle(); }
+	INLINE T *GetNextVehicle() const { return (T *)this->Vehicle::GetNextVehicle(); }
 
 	/**
 	 * Get the previous real (non-articulated part) vehicle in the consist.
 	 * @return Previous vehicle in the consist.
 	 */
-	inline T *GetPrevVehicle() const { return (T *)this->Vehicle::GetPrevVehicle(); }
+	INLINE T *GetPrevVehicle() const { return (T *)this->Vehicle::GetPrevVehicle(); }
 
 	/**
 	 * Tests whether given index is a valid index for vehicle of this type
 	 * @param index tested index
 	 * @return is this index valid index of T?
 	 */
-	static inline bool IsValidID(size_t index)
+	static INLINE bool IsValidID(size_t index)
 	{
 		return Vehicle::IsValidID(index) && Vehicle::Get(index)->type == Type;
 	}
@@ -961,7 +961,7 @@
 	 * Gets vehicle with given index
 	 * @return pointer to vehicle with given index casted to T *
 	 */
-	static inline T *Get(size_t index)
+	static INLINE T *Get(size_t index)
 	{
 		return (T *)Vehicle::Get(index);
 	}
@@ -970,7 +970,7 @@
 	 * Returns vehicle if the index is a valid index for this vehicle type
 	 * @return pointer to vehicle with given index if it's a vehicle of this type
 	 */
-	static inline T *GetIfValid(size_t index)
+	static INLINE T *GetIfValid(size_t index)
 	{
 		return IsValidID(index) ? Get(index) : NULL;
 	}
@@ -980,7 +980,7 @@
 	 * @param v Vehicle pointer
 	 * @return pointer to SpecializedVehicle
 	 */
-	static inline T *From(Vehicle *v)
+	static INLINE T *From(Vehicle *v)
 	{
 		assert(v->type == Type);
 		return (T *)v;
@@ -991,7 +991,7 @@
 	 * @param v Vehicle pointer
 	 * @return pointer to SpecializedVehicle
 	 */
-	static inline const T *From(const Vehicle *v)
+	static INLINE const T *From(const Vehicle *v)
 	{
 		assert(v->type == Type);
 		return (const T *)v;
@@ -1002,7 +1002,7 @@
 	 * @param force_update Force updating the vehicle on the viewport.
 	 * @param update_delta Also update the delta?
 	 */
-	inline void UpdateViewport(bool force_update, bool update_delta)
+	INLINE void UpdateViewport(bool force_update, bool update_delta)
 	{
 		extern void VehicleUpdateViewport(Vehicle *v, bool dirty);
 
diff --git a/src/vehicle_func.h b/src/vehicle_func.h
--- a/src/vehicle_func.h
+++ b/src/vehicle_func.h
@@ -84,7 +84,7 @@
  * @param type Vehicle type being queried.
  * @return Vehicle type is buildable by a company.
  */
-static inline bool IsCompanyBuildableVehicleType(VehicleType type)
+static INLINE bool IsCompanyBuildableVehicleType(VehicleType type)
 {
 	switch (type) {
 		case VEH_TRAIN:
@@ -102,7 +102,7 @@
  * @param v Vehicle being queried.
  * @return Vehicle is buildable by a company.
  */
-static inline bool IsCompanyBuildableVehicleType(const BaseVehicle *v)
+static INLINE bool IsCompanyBuildableVehicleType(const BaseVehicle *v)
 {
 	return IsCompanyBuildableVehicleType(v->type);
 }
@@ -119,42 +119,42 @@
 extern const uint32 _send_to_depot_proc_table[];
 
 /* Functions to find the right command for certain vehicle type */
-static inline uint32 GetCmdBuildVeh(VehicleType type)
+static INLINE uint32 GetCmdBuildVeh(VehicleType type)
 {
 	return _veh_build_proc_table[type];
 }
 
-static inline uint32 GetCmdBuildVeh(const BaseVehicle *v)
+static INLINE uint32 GetCmdBuildVeh(const BaseVehicle *v)
 {
 	return GetCmdBuildVeh(v->type);
 }
 
-static inline uint32 GetCmdSellVeh(VehicleType type)
+static INLINE uint32 GetCmdSellVeh(VehicleType type)
 {
 	return _veh_sell_proc_table[type];
 }
 
-static inline uint32 GetCmdSellVeh(const BaseVehicle *v)
+static INLINE uint32 GetCmdSellVeh(const BaseVehicle *v)
 {
 	return GetCmdSellVeh(v->type);
 }
 
-static inline uint32 GetCmdRefitVeh(VehicleType type)
+static INLINE uint32 GetCmdRefitVeh(VehicleType type)
 {
 	return _veh_refit_proc_table[type];
 }
 
-static inline uint32 GetCmdRefitVeh(const BaseVehicle *v)
+static INLINE uint32 GetCmdRefitVeh(const BaseVehicle *v)
 {
 	return GetCmdRefitVeh(v->type);
 }
 
-static inline uint32 GetCmdSendToDepot(VehicleType type)
+static INLINE uint32 GetCmdSendToDepot(VehicleType type)
 {
 	return _send_to_depot_proc_table[type];
 }
 
-static inline uint32 GetCmdSendToDepot(const BaseVehicle *v)
+static INLINE uint32 GetCmdSendToDepot(const BaseVehicle *v)
 {
 	return GetCmdSendToDepot(v->type);
 }
diff --git a/src/vehicle_gui.cpp b/src/vehicle_gui.cpp
--- a/src/vehicle_gui.cpp
+++ b/src/vehicle_gui.cpp
@@ -294,7 +294,7 @@
 	 * @param other Compare to this #RefitOption.
 	 * @return True if both #RefitOption are different.
 	 */
-	inline bool operator != (const RefitOption &other) const
+	INLINE bool operator != (const RefitOption &other) const
 	{
 		return other.cargo != this->cargo || other.value != this->value;
 	}
@@ -304,7 +304,7 @@
 	 * @param other Compare to this #RefitOption.
 	 * @return True if both #RefitOption are equal.
 	 */
-	inline bool operator == (const RefitOption &other) const
+	INLINE bool operator == (const RefitOption &other) const
 	{
 		return other.cargo == this->cargo && other.value == this->value;
 	}
@@ -1113,7 +1113,7 @@
  * @param from_index the old vehicle ID
  * @param to_index the new vehicle ID
  */
-static inline void ChangeVehicleWindow(WindowClass window_class, VehicleID from_index, VehicleID to_index)
+static INLINE void ChangeVehicleWindow(WindowClass window_class, VehicleID from_index, VehicleID to_index)
 {
 	Window *w = FindWindowById(window_class, from_index);
 	if (w != NULL) {
diff --git a/src/vehicle_gui.h b/src/vehicle_gui.h
--- a/src/vehicle_gui.h
+++ b/src/vehicle_gui.h
@@ -51,7 +51,7 @@
  * @param type the vehicle type to look at
  * @return the height
  */
-static inline uint GetVehicleHeight(VehicleType type)
+static INLINE uint GetVehicleHeight(VehicleType type)
 {
 	return (type == VEH_TRAIN || type == VEH_ROAD) ? 14 : 24;
 }
@@ -64,7 +64,7 @@
  * @return corresponding window class
  * @note works only for company buildable vehicle types
  */
-static inline WindowClass GetWindowClassForVehicleType(VehicleType vt)
+static INLINE WindowClass GetWindowClassForVehicleType(VehicleType vt)
 {
 	switch (vt) {
 		default: NOT_REACHED();
diff --git a/src/viewport.cpp b/src/viewport.cpp
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -1534,7 +1534,7 @@
 	}
 }
 
-static inline void ViewportDraw(const ViewPort *vp, int left, int top, int right, int bottom)
+static INLINE void ViewportDraw(const ViewPort *vp, int left, int top, int right, int bottom)
 {
 	if (right <= vp->left || bottom <= vp->top) return;
 
@@ -1567,7 +1567,7 @@
 	dpi->top -= this->top;
 }
 
-static inline void ClampViewportToMap(const ViewPort *vp, int &x, int &y)
+static INLINE void ClampViewportToMap(const ViewPort *vp, int &x, int &y)
 {
 	/* Centre of the viewport is hot spot */
 	x += vp->virtual_width / 2;
@@ -2231,7 +2231,7 @@
  * @param params (optional) up to 5 pieces of additional information that may be added to a tooltip
  * @param close_cond Condition for closing this tooltip.
  */
-static inline void ShowMeasurementTooltips(StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_cond = TCC_LEFT_CLICK)
+static INLINE void ShowMeasurementTooltips(StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_cond = TCC_LEFT_CLICK)
 {
 	if (!_settings_client.gui.measure_tooltip) return;
 	GuiShowTooltips(_thd.GetCallbackWnd(), str, paramcount, params, close_cond);
diff --git a/src/viewport_func.h b/src/viewport_func.h
--- a/src/viewport_func.h
+++ b/src/viewport_func.h
@@ -40,7 +40,7 @@
  * @param w   Window owning the viewport.
  * @pre \a how should not be #ZOOM_NONE.
  */
-static inline void MaxZoomInOut(ZoomStateChange how, Window *w)
+static INLINE void MaxZoomInOut(ZoomStateChange how, Window *w)
 {
 	while (DoZoomInOutWindow(how, w)) {};
 }
diff --git a/src/void_map.h b/src/void_map.h
--- a/src/void_map.h
+++ b/src/void_map.h
@@ -18,7 +18,7 @@
  * Make a nice void tile ;)
  * @param t the tile to make void
  */
-static inline void MakeVoid(TileIndex t)
+static INLINE void MakeVoid(TileIndex t)
 {
 	SetTileType(t, MP_VOID);
 	SetTileHeight(t, 0);
diff --git a/src/water.h b/src/water.h
--- a/src/water.h
+++ b/src/water.h
@@ -46,7 +46,7 @@
  * @param num Number of canal tiles.
  * @return Total cost.
  */
-static inline Money CanalMaintenanceCost(uint32 num)
+static INLINE Money CanalMaintenanceCost(uint32 num)
 {
 	return (_price[PR_INFRASTRUCTURE_WATER] * num * (1 + IntSqrt(num))) >> 6; // 6 bits scaling.
 }
diff --git a/src/water_cmd.cpp b/src/water_cmd.cpp
--- a/src/water_cmd.cpp
+++ b/src/water_cmd.cpp
@@ -69,7 +69,7 @@
  *
  * @param tile tile to check
  */
-static inline void MarkTileDirtyIfCanalOrRiver(TileIndex tile)
+static INLINE void MarkTileDirtyIfCanalOrRiver(TileIndex tile)
 {
 	if (IsTileType(tile, MP_WATER) && (IsCanal(tile) || IsRiver(tile))) MarkTileDirtyByTile(tile);
 }
diff --git a/src/water_map.h b/src/water_map.h
--- a/src/water_map.h
+++ b/src/water_map.h
@@ -74,7 +74,7 @@
  * @param t Water tile to query.
  * @return Water tile type at the tile.
  */
-static inline WaterTileType GetWaterTileType(TileIndex t)
+static INLINE WaterTileType GetWaterTileType(TileIndex t)
 {
 	assert(IsTileType(t, MP_WATER));
 
@@ -92,7 +92,7 @@
  * @param t Tile to query.
  * @return True if the tiletype has a waterclass.
  */
-static inline bool HasTileWaterClass(TileIndex t)
+static INLINE bool HasTileWaterClass(TileIndex t)
 {
 	return IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT);
 }
@@ -103,7 +103,7 @@
  * @pre IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT)
  * @return Water class at the tile.
  */
-static inline WaterClass GetWaterClass(TileIndex t)
+static INLINE WaterClass GetWaterClass(TileIndex t)
 {
 	assert(HasTileWaterClass(t));
 	return (WaterClass)GB(_m[t].m1, 5, 2);
@@ -115,7 +115,7 @@
  * @param wc New water class.
  * @pre IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT)
  */
-static inline void SetWaterClass(TileIndex t, WaterClass wc)
+static INLINE void SetWaterClass(TileIndex t, WaterClass wc)
 {
 	assert(HasTileWaterClass(t));
 	SB(_m[t].m1, 5, 2, wc);
@@ -127,7 +127,7 @@
  * @pre IsTileType(t, MP_WATER) || IsTileType(t, MP_STATION) || IsTileType(t, MP_INDUSTRY) || IsTileType(t, MP_OBJECT)
  * @return true iff on water
  */
-static inline bool IsTileOnWater(TileIndex t)
+static INLINE bool IsTileOnWater(TileIndex t)
 {
 	return (GetWaterClass(t) != WATER_CLASS_INVALID);
 }
@@ -138,7 +138,7 @@
  * @return \c true if any type of clear water like ocean, river, or canal.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsWater(TileIndex t)
+static INLINE bool IsWater(TileIndex t)
 {
 	return GetWaterTileType(t) == WATER_TILE_CLEAR;
 }
@@ -149,7 +149,7 @@
  * @return \c true if it is a sea water tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsSea(TileIndex t)
+static INLINE bool IsSea(TileIndex t)
 {
 	return IsWater(t) && GetWaterClass(t) == WATER_CLASS_SEA;
 }
@@ -160,7 +160,7 @@
  * @return \c true if it is a canal tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsCanal(TileIndex t)
+static INLINE bool IsCanal(TileIndex t)
 {
 	return IsWater(t) && GetWaterClass(t) == WATER_CLASS_CANAL;
 }
@@ -171,7 +171,7 @@
  * @return \c true if it is a river water tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsRiver(TileIndex t)
+static INLINE bool IsRiver(TileIndex t)
 {
 	return IsWater(t) && GetWaterClass(t) == WATER_CLASS_RIVER;
 }
@@ -181,7 +181,7 @@
  * @param t Tile to query.
  * @return \c true if it is a plain water tile.
  */
-static inline bool IsWaterTile(TileIndex t)
+static INLINE bool IsWaterTile(TileIndex t)
 {
 	return IsTileType(t, MP_WATER) && IsWater(t);
 }
@@ -192,7 +192,7 @@
  * @return \c true if it is a sea water tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsCoast(TileIndex t)
+static INLINE bool IsCoast(TileIndex t)
 {
 	return GetWaterTileType(t) == WATER_TILE_COAST;
 }
@@ -202,7 +202,7 @@
  * @param t Tile to query.
  * @return \c true if it is a coast.
  */
-static inline bool IsCoastTile(TileIndex t)
+static INLINE bool IsCoastTile(TileIndex t)
 {
 	return IsTileType(t, MP_WATER) && IsCoast(t);
 }
@@ -213,7 +213,7 @@
  * @return \c true if it is a ship depot tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsShipDepot(TileIndex t)
+static INLINE bool IsShipDepot(TileIndex t)
 {
 	return GetWaterTileType(t) == WATER_TILE_DEPOT;
 }
@@ -223,7 +223,7 @@
  * @param t Tile to query.
  * @return \c true if it is a ship depot tile.
  */
-static inline bool IsShipDepotTile(TileIndex t)
+static INLINE bool IsShipDepotTile(TileIndex t)
 {
 	return IsTileType(t, MP_WATER) && IsShipDepot(t);
 }
@@ -234,7 +234,7 @@
  * @return Axis of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline Axis GetShipDepotAxis(TileIndex t)
+static INLINE Axis GetShipDepotAxis(TileIndex t)
 {
 	assert(IsShipDepotTile(t));
 	return (Axis)GB(_m[t].m5, WBL_DEPOT_AXIS, 1);
@@ -246,7 +246,7 @@
  * @return Part of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline DepotPart GetShipDepotPart(TileIndex t)
+static INLINE DepotPart GetShipDepotPart(TileIndex t)
 {
 	assert(IsShipDepotTile(t));
 	return (DepotPart)GB(_m[t].m5, WBL_DEPOT_PART, 1);
@@ -258,7 +258,7 @@
  * @return Direction of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline DiagDirection GetShipDepotDirection(TileIndex t)
+static INLINE DiagDirection GetShipDepotDirection(TileIndex t)
 {
 	return XYNSToDiagDir(GetShipDepotAxis(t), GetShipDepotPart(t));
 }
@@ -269,7 +269,7 @@
  * @return Tile containing the other section of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline TileIndex GetOtherShipDepotTile(TileIndex t)
+static INLINE TileIndex GetOtherShipDepotTile(TileIndex t)
 {
 	return t + (GetShipDepotPart(t) != DEPOT_PART_NORTH ? -1 : 1) * (GetShipDepotAxis(t) != AXIS_X ? TileDiffXY(0, 1) : TileDiffXY(1, 0));
 }
@@ -280,7 +280,7 @@
  * @return The northern tile of the depot.
  * @pre IsShipDepotTile(t)
  */
-static inline TileIndex GetShipDepotNorthTile(TileIndex t)
+static INLINE TileIndex GetShipDepotNorthTile(TileIndex t)
 {
 	assert(IsShipDepot(t));
 	TileIndex tile2 = GetOtherShipDepotTile(t);
@@ -294,7 +294,7 @@
  * @return \c true if it is a water lock tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline bool IsLock(TileIndex t)
+static INLINE bool IsLock(TileIndex t)
 {
 	return GetWaterTileType(t) == WATER_TILE_LOCK;
 }
@@ -305,7 +305,7 @@
  * @return Direction of the lock.
  * @pre IsTileType(t, MP_WATER) && IsLock(t)
  */
-static inline DiagDirection GetLockDirection(TileIndex t)
+static INLINE DiagDirection GetLockDirection(TileIndex t)
 {
 	assert(IsLock(t));
 	return (DiagDirection)GB(_m[t].m5, WBL_LOCK_ORIENT_BEGIN, WBL_LOCK_ORIENT_COUNT);
@@ -317,7 +317,7 @@
  * @return The part.
  * @pre IsTileType(t, MP_WATER) && IsLock(t)
  */
-static inline byte GetLockPart(TileIndex t)
+static INLINE byte GetLockPart(TileIndex t)
 {
 	assert(IsLock(t));
 	return GB(_m[t].m5, WBL_LOCK_PART_BEGIN, WBL_LOCK_PART_COUNT);
@@ -329,7 +329,7 @@
  * @return Random bits of the tile.
  * @pre IsTileType(t, MP_WATER)
  */
-static inline byte GetWaterTileRandomBits(TileIndex t)
+static INLINE byte GetWaterTileRandomBits(TileIndex t)
 {
 	assert(IsTileType(t, MP_WATER));
 	return _m[t].m4;
@@ -341,7 +341,7 @@
  * @return true iff the tile has water at the ground.
  * @note Coast tiles are not considered waterish, even if there is water on a halftile.
  */
-static inline bool HasTileWaterGround(TileIndex t)
+static INLINE bool HasTileWaterGround(TileIndex t)
 {
 	return HasTileWaterClass(t) && IsTileOnWater(t) && !IsCoastTile(t);
 }
@@ -351,7 +351,7 @@
  * Helper function to make a coast tile.
  * @param t The tile to change into water
  */
-static inline void MakeShore(TileIndex t)
+static INLINE void MakeShore(TileIndex t)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, OWNER_WATER);
@@ -371,7 +371,7 @@
  * @param wc The class of water the tile has to be
  * @param random_bits Eventual random bits to be set for this tile
  */
-static inline void MakeWater(TileIndex t, Owner o, WaterClass wc, uint8 random_bits)
+static INLINE void MakeWater(TileIndex t, Owner o, WaterClass wc, uint8 random_bits)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
@@ -388,7 +388,7 @@
  * Make a sea tile.
  * @param t The tile to change into sea
  */
-static inline void MakeSea(TileIndex t)
+static INLINE void MakeSea(TileIndex t)
 {
 	MakeWater(t, OWNER_WATER, WATER_CLASS_SEA, 0);
 }
@@ -398,7 +398,7 @@
  * @param t The tile to change into river
  * @param random_bits Random bits to be set for this tile
  */
-static inline void MakeRiver(TileIndex t, uint8 random_bits)
+static INLINE void MakeRiver(TileIndex t, uint8 random_bits)
 {
 	MakeWater(t, OWNER_WATER, WATER_CLASS_RIVER, random_bits);
 }
@@ -409,7 +409,7 @@
  * @param o The owner of the canal
  * @param random_bits Random bits to be set for this tile
  */
-static inline void MakeCanal(TileIndex t, Owner o, uint8 random_bits)
+static INLINE void MakeCanal(TileIndex t, Owner o, uint8 random_bits)
 {
 	assert(o != OWNER_WATER);
 	MakeWater(t, o, WATER_CLASS_CANAL, random_bits);
@@ -424,7 +424,7 @@
  * @param a    Axis of the depot.
  * @param original_water_class Original water class.
  */
-static inline void MakeShipDepot(TileIndex t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class)
+static INLINE void MakeShipDepot(TileIndex t, Owner o, DepotID did, DepotPart part, Axis a, WaterClass original_water_class)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
@@ -446,7 +446,7 @@
  * @param original_water_class Original water class.
  * @see MakeLock
  */
-static inline void MakeLockTile(TileIndex t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class)
+static INLINE void MakeLockTile(TileIndex t, Owner o, LockPart part, DiagDirection dir, WaterClass original_water_class)
 {
 	SetTileType(t, MP_WATER);
 	SetTileOwner(t, o);
@@ -468,7 +468,7 @@
  * @param wc_upper Original water class of the upper part.
  * @param wc_middle Original water class of the middle part.
  */
-static inline void MakeLock(TileIndex t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle)
+static INLINE void MakeLock(TileIndex t, Owner o, DiagDirection d, WaterClass wc_lower, WaterClass wc_upper, WaterClass wc_middle)
 {
 	TileIndexDiff delta = TileOffsByDiagDir(d);
 
diff --git a/src/waypoint_base.h b/src/waypoint_base.h
--- a/src/waypoint_base.h
+++ b/src/waypoint_base.h
@@ -27,7 +27,7 @@
 
 	void UpdateVirtCoord();
 
-	/* virtual */ inline bool TileBelongsToRailStation(TileIndex tile) const
+	/* virtual */ INLINE bool TileBelongsToRailStation(TileIndex tile) const
 	{
 		return IsRailWaypointTile(tile) && GetStationIndex(tile) == this->index;
 	}
@@ -50,7 +50,7 @@
 	 * Is this a single tile waypoint?
 	 * @return true if it is.
 	 */
-	inline bool IsSingleTile() const
+	INLINE bool IsSingleTile() const
 	{
 		return (this->facilities & FACIL_TRAIN) != 0 && this->train_station.w == 1 && this->train_station.h == 1;
 	}
@@ -61,7 +61,7 @@
 	 * @param wp The waypoint to compare to.
 	 * @return true iff their types are equal.
 	 */
-	inline bool IsOfType(const Waypoint *wp) const
+	INLINE bool IsOfType(const Waypoint *wp) const
 	{
 		return this->string_id == wp->string_id;
 	}
diff --git a/src/widget.cpp b/src/widget.cpp
--- a/src/widget.cpp
+++ b/src/widget.cpp
@@ -212,7 +212,7 @@
  * @param clicked Button is lowered.
  * @param img     Sprite to draw.
  */
-static inline void DrawImageButtons(const Rect &r, WidgetType type, Colours colour, bool clicked, SpriteID img)
+static INLINE void DrawImageButtons(const Rect &r, WidgetType type, Colours colour, bool clicked, SpriteID img)
 {
 	assert(img != 0);
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
@@ -228,7 +228,7 @@
  * @param clicked Label is rendered lowered.
  * @param str     Text to draw.
  */
-static inline void DrawLabel(const Rect &r, WidgetType type, bool clicked, StringID str)
+static INLINE void DrawLabel(const Rect &r, WidgetType type, bool clicked, StringID str)
 {
 	if (str == STR_NULL) return;
 	if ((type & WWT_MASK) == WWT_TEXTBTN_2 && clicked) str++;
@@ -243,7 +243,7 @@
  * @param colour Colour of the text.
  * @param str    Text to draw.
  */
-static inline void DrawText(const Rect &r, TextColour colour, StringID str)
+static INLINE void DrawText(const Rect &r, TextColour colour, StringID str)
 {
 	Dimension d = GetStringBoundingBox(str);
 	int offset = max(0, ((int)(r.bottom - r.top + 1) - (int)d.height) / 2); // Offset for rendering the text vertically centered
@@ -256,7 +256,7 @@
  * @param colour Colour of the inset.
  * @param str    Text to draw.
  */
-static inline void DrawInset(const Rect &r, Colours colour, StringID str)
+static INLINE void DrawInset(const Rect &r, Colours colour, StringID str)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, FR_LOWERED | FR_DARKENED);
 	if (str != STR_NULL) DrawString(r.left + WD_INSET_LEFT, r.right - WD_INSET_RIGHT, r.top + WD_INSET_TOP, str);
@@ -269,7 +269,7 @@
  * @param clicked Matrix is rendered lowered.
  * @param data    Data of the widget, number of rows and columns of the widget.
  */
-static inline void DrawMatrix(const Rect &r, Colours colour, bool clicked, uint16 data)
+static INLINE void DrawMatrix(const Rect &r, Colours colour, bool clicked, uint16 data)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
 
@@ -317,7 +317,7 @@
  * @param down_clicked Down-arrow is clicked.
  * @param scrollbar    Scrollbar size, offset, and capacity information.
  */
-static inline void DrawVerticalScrollbar(const Rect &r, Colours colour, bool up_clicked, bool bar_dragged, bool down_clicked, const Scrollbar *scrollbar)
+static INLINE void DrawVerticalScrollbar(const Rect &r, Colours colour, bool up_clicked, bool bar_dragged, bool down_clicked, const Scrollbar *scrollbar)
 {
 	int centre = (r.right - r.left) / 2;
 	int height = NWidgetScrollbar::GetVerticalDimension().height;
@@ -355,7 +355,7 @@
  * @param right_clicked Right-arrow is clicked.
  * @param scrollbar     Scrollbar size, offset, and capacity information.
  */
-static inline void DrawHorizontalScrollbar(const Rect &r, Colours colour, bool left_clicked, bool bar_dragged, bool right_clicked, const Scrollbar *scrollbar)
+static INLINE void DrawHorizontalScrollbar(const Rect &r, Colours colour, bool left_clicked, bool bar_dragged, bool right_clicked, const Scrollbar *scrollbar)
 {
 	int centre = (r.bottom - r.top) / 2;
 	int width = NWidgetScrollbar::GetHorizontalDimension().width;
@@ -390,7 +390,7 @@
  * @param colour Colour of the frame.
  * @param str    Text of the frame.
  */
-static inline void DrawFrame(const Rect &r, Colours colour, StringID str)
+static INLINE void DrawFrame(const Rect &r, Colours colour, StringID str)
 {
 	int x2 = r.left; // by default the left side is the left side of the widget
 
@@ -440,7 +440,7 @@
  * @param colour  Colour of the shade box.
  * @param clicked Box is lowered.
  */
-static inline void DrawShadeBox(const Rect &r, Colours colour, bool clicked)
+static INLINE void DrawShadeBox(const Rect &r, Colours colour, bool clicked)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
 	DrawSprite((clicked) ? SPR_WINDOW_SHADE : SPR_WINDOW_UNSHADE, PAL_NONE, r.left + WD_SHADEBOX_LEFT + clicked, r.top + WD_SHADEBOX_TOP + clicked);
@@ -452,7 +452,7 @@
  * @param colour  Colour of the sticky box.
  * @param clicked Box is lowered.
  */
-static inline void DrawStickyBox(const Rect &r, Colours colour, bool clicked)
+static INLINE void DrawStickyBox(const Rect &r, Colours colour, bool clicked)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
 	DrawSprite((clicked) ? SPR_PIN_UP : SPR_PIN_DOWN, PAL_NONE, r.left + WD_STICKYBOX_LEFT + clicked, r.top + WD_STICKYBOX_TOP + clicked);
@@ -464,7 +464,7 @@
  * @param colour  Colour of the debug box.
  * @param clicked Box is lowered.
  */
-static inline void DrawDebugBox(const Rect &r, Colours colour, bool clicked)
+static INLINE void DrawDebugBox(const Rect &r, Colours colour, bool clicked)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
 	DrawSprite(SPR_WINDOW_DEBUG, PAL_NONE, r.left + WD_DEBUGBOX_LEFT + clicked, r.top + WD_DEBUGBOX_TOP + clicked);
@@ -477,7 +477,7 @@
  * @param at_left Resize box is at left-side of the window,
  * @param clicked Box is lowered.
  */
-static inline void DrawResizeBox(const Rect &r, Colours colour, bool at_left, bool clicked)
+static INLINE void DrawResizeBox(const Rect &r, Colours colour, bool at_left, bool clicked)
 {
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, (clicked) ? FR_LOWERED : FR_NONE);
 	if (at_left) {
@@ -495,7 +495,7 @@
  * @param colour Colour of the close box.
  * @param str    Cross to draw (#STR_BLACK_CROSS or #STR_SILVER_CROSS).
  */
-static inline void DrawCloseBox(const Rect &r, Colours colour, StringID str)
+static INLINE void DrawCloseBox(const Rect &r, Colours colour, StringID str)
 {
 	assert(str == STR_BLACK_CROSS || str == STR_SILVER_CROSS); // black or silver cross
 	DrawFrameRect(r.left, r.top, r.right, r.bottom, colour, FR_NONE);
@@ -535,7 +535,7 @@
  *
  * @note Magic constants are also used in #NWidgetLeaf::ButtonHit.
  */
-static inline void DrawButtonDropdown(const Rect &r, Colours colour, bool clicked_button, bool clicked_dropdown, StringID str)
+static INLINE void DrawButtonDropdown(const Rect &r, Colours colour, bool clicked_button, bool clicked_dropdown, StringID str)
 {
 	int text_offset = max(0, ((int)(r.bottom - r.top + 1) - FONT_HEIGHT_NORMAL) / 2); // Offset for rendering the text vertically centered
 
@@ -559,7 +559,7 @@
  * @param clicked The widget is lowered.
  * @param str     Text of the button.
  */
-static inline void DrawDropdown(const Rect &r, Colours colour, bool clicked, StringID str)
+static INLINE void DrawDropdown(const Rect &r, Colours colour, bool clicked, StringID str)
 {
 	DrawButtonDropdown(r, colour, false, clicked, str);
 }
diff --git a/src/widget_type.h b/src/widget_type.h
--- a/src/widget_type.h
+++ b/src/widget_type.h
@@ -144,7 +144,7 @@
 	 * @param bottom Amount of additional space below the widget.
 	 * @param left   Amount of additional space left of the widget.
 	 */
-	inline void SetPadding(uint8 top, uint8 right, uint8 bottom, uint8 left)
+	INLINE void SetPadding(uint8 top, uint8 right, uint8 bottom, uint8 left)
 	{
 		this->padding_top = top;
 		this->padding_right = right;
@@ -152,8 +152,8 @@
 		this->padding_left = left;
 	}
 
-	inline uint GetHorizontalStepSize(SizingType sizing) const;
-	inline uint GetVerticalStepSize(SizingType sizing) const;
+	INLINE uint GetHorizontalStepSize(SizingType sizing) const;
+	INLINE uint GetVerticalStepSize(SizingType sizing) const;
 
 	virtual void Draw(const Window *w) = 0;
 	virtual void SetDirty(const Window *w) const;
@@ -184,14 +184,14 @@
 	uint8 padding_left;   ///< Paddings added to the left of the widget. Managed by parent container widget.
 
 protected:
-	inline void StoreSizePosition(SizingType sizing, uint x, uint y, uint given_width, uint given_height);
+	INLINE void StoreSizePosition(SizingType sizing, uint x, uint y, uint given_width, uint given_height);
 };
 
 /**
  * Get the horizontal sizing step.
  * @param sizing Type of resize being performed.
  */
-inline uint NWidgetBase::GetHorizontalStepSize(SizingType sizing) const
+INLINE uint NWidgetBase::GetHorizontalStepSize(SizingType sizing) const
 {
 	return (sizing == ST_RESIZE) ? this->resize_x : this->fill_x;
 }
@@ -200,7 +200,7 @@
  * Get the vertical sizing step.
  * @param sizing Type of resize being performed.
  */
-inline uint NWidgetBase::GetVerticalStepSize(SizingType sizing) const
+INLINE uint NWidgetBase::GetVerticalStepSize(SizingType sizing) const
 {
 	return (sizing == ST_RESIZE) ? this->resize_y : this->fill_y;
 }
@@ -213,7 +213,7 @@
  * @param given_width  Width allocated to the widget.
  * @param given_height Height allocated to the widget.
  */
-inline void NWidgetBase::StoreSizePosition(SizingType sizing, uint x, uint y, uint given_width, uint given_height)
+INLINE void NWidgetBase::StoreSizePosition(SizingType sizing, uint x, uint y, uint given_width, uint given_height)
 {
 	this->pos_x = x;
 	this->pos_y = y;
@@ -286,10 +286,10 @@
 	void SetIndex(int index);
 	void SetDataTip(uint16 widget_data, StringID tool_tip);
 
-	inline void SetLowered(bool lowered);
-	inline bool IsLowered() const;
-	inline void SetDisabled(bool disabled);
-	inline bool IsDisabled() const;
+	INLINE void SetLowered(bool lowered);
+	INLINE bool IsLowered() const;
+	INLINE void SetDisabled(bool disabled);
+	INLINE bool IsDisabled() const;
 
 	/* virtual */ void FillNestedArray(NWidgetBase **array, uint length);
 	/* virtual */ NWidgetCore *GetWidgetFromPos(int x, int y);
@@ -310,20 +310,20 @@
  * Highlight the widget or not.
  * @param higlighted Widget must be highlighted (blink).
  */
-inline void NWidgetCore::SetHighlighted(TextColour highlight_colour)
+INLINE void NWidgetCore::SetHighlighted(TextColour highlight_colour)
 {
 	this->disp_flags = highlight_colour != TC_INVALID ? SETBITS(this->disp_flags, ND_HIGHLIGHT) : CLRBITS(this->disp_flags, ND_HIGHLIGHT);
 	this->highlight_colour = highlight_colour;
 }
 
 /** Return whether the widget is highlighted. */
-inline bool NWidgetCore::IsHighlighted() const
+INLINE bool NWidgetCore::IsHighlighted() const
 {
 	return HasBit(this->disp_flags, NDB_HIGHLIGHT);
 }
 
 /** Return the colour of the highlight. */
-inline TextColour NWidgetCore::GetHighlightColour() const
+INLINE TextColour NWidgetCore::GetHighlightColour() const
 {
 	return this->highlight_colour;
 }
@@ -332,13 +332,13 @@
  * Lower or raise the widget.
  * @param lowered Widget must be lowered (drawn pressed down).
  */
-inline void NWidgetCore::SetLowered(bool lowered)
+INLINE void NWidgetCore::SetLowered(bool lowered)
 {
 	this->disp_flags = lowered ? SETBITS(this->disp_flags, ND_LOWERED) : CLRBITS(this->disp_flags, ND_LOWERED);
 }
 
 /** Return whether the widget is lowered. */
-inline bool NWidgetCore::IsLowered() const
+INLINE bool NWidgetCore::IsLowered() const
 {
 	return HasBit(this->disp_flags, NDB_LOWERED);
 }
@@ -347,13 +347,13 @@
  * Disable (grey-out) or enable the widget.
  * @param disabled Widget must be disabled.
  */
-inline void NWidgetCore::SetDisabled(bool disabled)
+INLINE void NWidgetCore::SetDisabled(bool disabled)
 {
 	this->disp_flags = disabled ? SETBITS(this->disp_flags, ND_DISABLED) : CLRBITS(this->disp_flags, ND_DISABLED);
 }
 
 /** Return whether the widget is disabled. */
-inline bool NWidgetCore::IsDisabled() const
+INLINE bool NWidgetCore::IsDisabled() const
 {
 	return HasBit(this->disp_flags, NDB_DISABLED);
 }
@@ -372,7 +372,7 @@
 	/* virtual */ void FillNestedArray(NWidgetBase **array, uint length);
 
 	/** Return whether the container is empty. */
-	inline bool IsEmpty() { return head == NULL; }
+	INLINE bool IsEmpty() { return head == NULL; }
 
 	/* virtual */ NWidgetBase *GetWidgetOfType(WidgetType tp);
 
@@ -608,7 +608,7 @@
 	 * Gets the number of elements in the list
 	 * @return the number of elements
 	 */
-	inline uint16 GetCount() const
+	INLINE uint16 GetCount() const
 	{
 		return this->count;
 	}
@@ -617,7 +617,7 @@
 	 * Gets the number of visible elements of the scrollbar
 	 * @return the number of visible elements
 	 */
-	inline uint16 GetCapacity() const
+	INLINE uint16 GetCapacity() const
 	{
 		return this->cap;
 	}
@@ -626,7 +626,7 @@
 	 * Gets the position of the first visible element in the list
 	 * @return the position of the element
 	 */
-	inline uint16 GetPosition() const
+	INLINE uint16 GetPosition() const
 	{
 		return this->pos;
 	}
@@ -636,7 +636,7 @@
 	 * @param item to check
 	 * @return true iff the item is visible
 	 */
-	inline bool IsVisible(uint16 item) const
+	INLINE bool IsVisible(uint16 item) const
 	{
 		return IsInsideBS(item, this->GetPosition(), this->GetCapacity());
 	}
@@ -645,7 +645,7 @@
 	 * Is the scrollbar vertical or not?
 	 * @return True iff the scrollbar is vertical.
 	 */
-	inline bool IsVertical() const
+	INLINE bool IsVertical() const
 	{
 		return this->is_vertical;
 	}
@@ -790,7 +790,7 @@
  * @param step      Stepsize of the widget.
  * @return Biggest possible size of the widget, assuming that \a base may only be incremented by \a step size steps.
  */
-static inline uint ComputeMaxSize(uint base, uint max_space, uint step)
+static INLINE uint ComputeMaxSize(uint base, uint max_space, uint step)
 {
 	if (base >= max_space || step == 0) return base;
 	if (step == 1) return max_space;
@@ -922,7 +922,7 @@
  * @param dy Vertical resize step. 0 means no vertical resizing.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetResize(int16 dx, int16 dy)
+static INLINE NWidgetPart SetResize(int16 dx, int16 dy)
 {
 	NWidgetPart part;
 
@@ -939,7 +939,7 @@
  * @param y Vertical minimal size.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetMinimalSize(int16 x, int16 y)
+static INLINE NWidgetPart SetMinimalSize(int16 x, int16 y)
 {
 	NWidgetPart part;
 
@@ -957,7 +957,7 @@
  * @param size    Font size of text.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetMinimalTextLines(uint8 lines, uint8 spacing, FontSize size = FS_NORMAL)
+static INLINE NWidgetPart SetMinimalTextLines(uint8 lines, uint8 spacing, FontSize size = FS_NORMAL)
 {
 	NWidgetPart part;
 
@@ -975,7 +975,7 @@
  * @param fill_y Vertical filling step from minimal size.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetFill(uint fill_x, uint fill_y)
+static INLINE NWidgetPart SetFill(uint fill_x, uint fill_y)
 {
 	NWidgetPart part;
 
@@ -991,7 +991,7 @@
  * (horizontal, vertical, WWT_FRAME, WWT_INSET, or WWT_PANEL).
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart EndContainer()
+static INLINE NWidgetPart EndContainer()
 {
 	NWidgetPart part;
 
@@ -1006,7 +1006,7 @@
  * @param tip  Tooltip of the widget.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetDataTip(uint16 data, StringID tip)
+static INLINE NWidgetPart SetDataTip(uint16 data, StringID tip)
 {
 	NWidgetPart part;
 
@@ -1026,7 +1026,7 @@
  * @param left The padding left of the widget.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetPadding(uint8 top, uint8 right, uint8 bottom, uint8 left)
+static INLINE NWidgetPart SetPadding(uint8 top, uint8 right, uint8 bottom, uint8 left)
 {
 	NWidgetPart part;
 
@@ -1044,7 +1044,7 @@
  * @param padding The padding to use for all directions.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetPadding(uint8 padding)
+static INLINE NWidgetPart SetPadding(uint8 padding)
 {
 	return SetPadding(padding, padding, padding, padding);
 }
@@ -1056,7 +1056,7 @@
  * @param post The amount of space after the last widget.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetPIP(uint8 pre, uint8 inter, uint8 post)
+static INLINE NWidgetPart SetPIP(uint8 pre, uint8 inter, uint8 post)
 {
 	NWidgetPart part;
 
@@ -1075,7 +1075,7 @@
  * @param index Widget index of the scrollbar.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart SetScrollbar(int index)
+static INLINE NWidgetPart SetScrollbar(int index)
 {
 	NWidgetPart part;
 
@@ -1094,7 +1094,7 @@
  *       Child widgets must have a index bigger than the parent index.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart NWidget(WidgetType tp, Colours col, int16 idx = -1)
+static INLINE NWidgetPart NWidget(WidgetType tp, Colours col, int16 idx = -1)
 {
 	NWidgetPart part;
 
@@ -1111,7 +1111,7 @@
  * @param cont_flags Flags for the containers (#NWID_HORIZONTAL(_LTR) and #NWID_VERTICAL).
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart NWidget(WidgetType tp, NWidContainerFlags cont_flags = NC_NONE)
+static INLINE NWidgetPart NWidget(WidgetType tp, NWidContainerFlags cont_flags = NC_NONE)
 {
 	NWidgetPart part;
 
@@ -1126,7 +1126,7 @@
  * @param func_ptr Pointer to function that returns the tree.
  * @ingroup NestedWidgetParts
  */
-static inline NWidgetPart NWidgetFunction(NWidgetFunctionType *func_ptr)
+static INLINE NWidgetPart NWidgetFunction(NWidgetFunctionType *func_ptr)
 {
 	NWidgetPart part;
 
diff --git a/src/window.cpp b/src/window.cpp
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -996,7 +996,7 @@
 	return w;
 }
 
-static inline bool IsVitalWindow(const Window *w)
+static INLINE bool IsVitalWindow(const Window *w)
 {
 	switch (w->window_class) {
 		case WC_MAIN_TOOLBAR:
diff --git a/src/window_gui.h b/src/window_gui.h
--- a/src/window_gui.h
+++ b/src/window_gui.h
@@ -265,7 +265,7 @@
 	 * to destruct them all at the same time too, which is kinda hard.
 	 * @param size the amount of space not to allocate
 	 */
-	inline void *operator new[](size_t size)
+	INLINE void *operator new[](size_t size)
 	{
 		NOT_REACHED();
 	}
@@ -275,7 +275,7 @@
 	 * Don't free the window directly; it corrupts the linked list when iterating
 	 * @param ptr the pointer not to free
 	 */
-	inline void operator delete(void *ptr)
+	INLINE void operator delete(void *ptr)
 	{
 	}
 
@@ -312,9 +312,9 @@
 	Window *z_back;                  ///< The window behind us in z-order.
 
 	template <class NWID>
-	inline const NWID *GetWidget(uint widnum) const;
+	INLINE const NWID *GetWidget(uint widnum) const;
 	template <class NWID>
-	inline NWID *GetWidget(uint widnum);
+	INLINE NWID *GetWidget(uint widnum);
 
 	const Scrollbar *GetScrollbar(uint widnum) const;
 	Scrollbar *GetScrollbar(uint widnum);
@@ -329,7 +329,7 @@
 	/**
 	 * Set the timeout flag of the window and initiate the timer.
 	 */
-	inline void SetTimeout()
+	INLINE void SetTimeout()
 	{
 		this->flags |= WF_TIMEOUT;
 		this->timeout_timer = TIMEOUT_DURATION;
@@ -338,7 +338,7 @@
 	/**
 	 * Set the timeout flag of the window and initiate the timer.
 	 */
-	inline void SetWhiteBorder()
+	INLINE void SetWhiteBorder()
 	{
 		this->flags |= WF_WHITE_BORDER;
 		this->white_border_timer = WHITE_BORDER_DURATION;
@@ -355,7 +355,7 @@
 	 * @param widget_index index of this widget in the window
 	 * @param disab_stat status to use ie: disabled = true, enabled = false
 	 */
-	inline void SetWidgetDisabledState(byte widget_index, bool disab_stat)
+	INLINE void SetWidgetDisabledState(byte widget_index, bool disab_stat)
 	{
 		assert(widget_index < this->nested_array_size);
 		if (this->nested_array[widget_index] != NULL) this->GetWidget<NWidgetCore>(widget_index)->SetDisabled(disab_stat);
@@ -365,7 +365,7 @@
 	 * Sets a widget to disabled.
 	 * @param widget_index index of this widget in the window
 	 */
-	inline void DisableWidget(byte widget_index)
+	INLINE void DisableWidget(byte widget_index)
 	{
 		SetWidgetDisabledState(widget_index, true);
 	}
@@ -374,7 +374,7 @@
 	 * Sets a widget to Enabled.
 	 * @param widget_index index of this widget in the window
 	 */
-	inline void EnableWidget(byte widget_index)
+	INLINE void EnableWidget(byte widget_index)
 	{
 		SetWidgetDisabledState(widget_index, false);
 	}
@@ -384,7 +384,7 @@
 	 * @param widget_index index of this widget in the window
 	 * @return status of the widget ie: disabled = true, enabled = false
 	 */
-	inline bool IsWidgetDisabled(byte widget_index) const
+	INLINE bool IsWidgetDisabled(byte widget_index) const
 	{
 		assert(widget_index < this->nested_array_size);
 		return this->GetWidget<NWidgetCore>(widget_index)->IsDisabled();
@@ -395,7 +395,7 @@
 	 * @param widget_index : index of the widget in the window to check
 	 * @return true if given widget is the focused window in this window
 	 */
-	inline bool IsWidgetFocused(byte widget_index) const
+	INLINE bool IsWidgetFocused(byte widget_index) const
 	{
 		return this->nested_focus != NULL && this->nested_focus->index == widget_index;
 	}
@@ -406,7 +406,7 @@
 	 * @param widget_index : index of the widget in the window to check
 	 * @return true if given widget is the focused window in this window and this window has focus
 	 */
-	inline bool IsWidgetGloballyFocused(byte widget_index) const
+	INLINE bool IsWidgetGloballyFocused(byte widget_index) const
 	{
 		return _focused_window == this && IsWidgetFocused(widget_index);
 	}
@@ -416,7 +416,7 @@
 	 * @param widget_index index of this widget in the window
 	 * @param lowered_stat status to use ie: lowered = true, raised = false
 	 */
-	inline void SetWidgetLoweredState(byte widget_index, bool lowered_stat)
+	INLINE void SetWidgetLoweredState(byte widget_index, bool lowered_stat)
 	{
 		assert(widget_index < this->nested_array_size);
 		this->GetWidget<NWidgetCore>(widget_index)->SetLowered(lowered_stat);
@@ -426,7 +426,7 @@
 	 * Invert the lowered/raised  status of a widget.
 	 * @param widget_index index of this widget in the window
 	 */
-	inline void ToggleWidgetLoweredState(byte widget_index)
+	INLINE void ToggleWidgetLoweredState(byte widget_index)
 	{
 		assert(widget_index < this->nested_array_size);
 		bool lowered_state = this->GetWidget<NWidgetCore>(widget_index)->IsLowered();
@@ -437,7 +437,7 @@
 	 * Marks a widget as lowered.
 	 * @param widget_index index of this widget in the window
 	 */
-	inline void LowerWidget(byte widget_index)
+	INLINE void LowerWidget(byte widget_index)
 	{
 		SetWidgetLoweredState(widget_index, true);
 	}
@@ -446,7 +446,7 @@
 	 * Marks a widget as raised.
 	 * @param widget_index index of this widget in the window
 	 */
-	inline void RaiseWidget(byte widget_index)
+	INLINE void RaiseWidget(byte widget_index)
 	{
 		SetWidgetLoweredState(widget_index, false);
 	}
@@ -456,7 +456,7 @@
 	 * @param widget_index index of this widget in the window
 	 * @return status of the widget ie: lowered = true, raised= false
 	 */
-	inline bool IsWidgetLowered(byte widget_index) const
+	INLINE bool IsWidgetLowered(byte widget_index) const
 	{
 		assert(widget_index < this->nested_array_size);
 		return this->GetWidget<NWidgetCore>(widget_index)->IsLowered();
@@ -485,7 +485,7 @@
 	void ReInit(int rx = 0, int ry = 0);
 
 	/** Is window shaded currently? */
-	inline bool IsShaded() const
+	INLINE bool IsShaded() const
 	{
 		return this->shade_select != NULL && this->shade_select->shown_plane == SZSP_HORIZONTAL;
 	}
@@ -770,7 +770,7 @@
  * @return The requested widget if it is instantiated, \c NULL otherwise.
  */
 template <class NWID>
-inline NWID *Window::GetWidget(uint widnum)
+INLINE NWID *Window::GetWidget(uint widnum)
 {
 	if (widnum >= this->nested_array_size || this->nested_array[widnum] == NULL) return NULL;
 	NWID *nwid = dynamic_cast<NWID *>(this->nested_array[widnum]);
@@ -780,7 +780,7 @@
 
 /** Specialized case of #Window::GetWidget for the nested widget base class. */
 template <>
-inline const NWidgetBase *Window::GetWidget<NWidgetBase>(uint widnum) const
+INLINE const NWidgetBase *Window::GetWidget<NWidgetBase>(uint widnum) const
 {
 	if (widnum >= this->nested_array_size) return NULL;
 	return this->nested_array[widnum];
@@ -793,7 +793,7 @@
  * @return The requested widget if it is instantiated, \c NULL otherwise.
  */
 template <class NWID>
-inline const NWID *Window::GetWidget(uint widnum) const
+INLINE const NWID *Window::GetWidget(uint widnum) const
 {
 	return const_cast<Window *>(this)->GetWidget<NWID>(widnum);
 }
diff --git a/src/zoom_func.h b/src/zoom_func.h
--- a/src/zoom_func.h
+++ b/src/zoom_func.h
@@ -21,7 +21,7 @@
  * @param zoom  zoom level to shift to
  * @return shifted value
  */
-static inline int ScaleByZoom(int value, ZoomLevel zoom)
+static INLINE int ScaleByZoom(int value, ZoomLevel zoom)
 {
 	if (zoom == ZOOM_LVL_NORMAL) return value;
 	int izoom = zoom - ZOOM_LVL_NORMAL;
@@ -35,7 +35,7 @@
  * @param zoom  zoom level to shift to
  * @return shifted value
  */
-static inline int UnScaleByZoom(int value, ZoomLevel zoom)
+static INLINE int UnScaleByZoom(int value, ZoomLevel zoom)
 {
 	if (zoom == ZOOM_LVL_NORMAL) return value;
 	int izoom = zoom - ZOOM_LVL_NORMAL;
@@ -48,7 +48,7 @@
  * @param zoom  zoom level to shift to
  * @return shifted value
  */
-static inline int ScaleByZoomLower(int value, ZoomLevel zoom)
+static INLINE int ScaleByZoomLower(int value, ZoomLevel zoom)
 {
 	if (zoom == ZOOM_LVL_NORMAL) return value;
 	int izoom = zoom - ZOOM_LVL_NORMAL;
@@ -61,7 +61,7 @@
  * @param zoom  zoom level to shift to
  * @return shifted value
  */
-static inline int UnScaleByZoomLower(int value, ZoomLevel zoom)
+static INLINE int UnScaleByZoomLower(int value, ZoomLevel zoom)
 {
 	if (zoom == ZOOM_LVL_NORMAL) return value;
 	int izoom = zoom - ZOOM_LVL_NORMAL;
