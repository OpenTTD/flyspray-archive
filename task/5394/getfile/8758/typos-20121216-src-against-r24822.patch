diff --git a/src/aircraft_cmd.cpp b/src/aircraft_cmd.cpp
index 6a628cc..dd72a68 100644
--- a/src/aircraft_cmd.cpp
+++ b/src/aircraft_cmd.cpp
@@ -625,7 +625,7 @@ static int UpdateAircraftSpeed(Aircraft *v, uint speed_limit = SPEED_LIMIT_NONE,
 	/* Adjust distance moved by plane speed setting */
 	if (_settings_game.vehicle.plane_speed > 1) spd /= _settings_game.vehicle.plane_speed;
 
-	/* Convert direction-indepenent speed into direction-dependent speed. (old movement method) */
+	/* Convert direction-independent speed into direction-dependent speed. (old movement method) */
 	spd = v->GetOldAdvanceSpeed(spd);
 
 	spd += v->progress;
@@ -650,7 +650,7 @@ int GetAircraftFlyingAltitude(const Aircraft *v)
 	int base_altitude = PLANE_HOLDING_ALTITUDE;
 
 	/* Make sure eastbound and westbound planes do not "crash" into each
-	 * other by providing them with vertical seperation
+	 * other by providing them with vertical separation
 	 */
 	switch (v->direction) {
 		case DIR_N:
@@ -1370,7 +1370,7 @@ static void AircraftEventHandler_AtTerminal(Aircraft *v, const AirportFTAClass *
 		 * and get serviced at the same time - setting */
 		if (_settings_game.order.serviceathelipad) {
 			if (v->subtype == AIR_HELICOPTER && apc->num_helipads > 0) {
-				/* an exerpt of ServiceAircraft, without the invisibility stuff */
+				/* an excerpt of ServiceAircraft, without the invisibility stuff */
 				v->date_of_last_service = _date;
 				v->breakdowns_since_last_service = 0;
 				v->reliability = v->GetEngine()->reliability;
@@ -1392,7 +1392,7 @@ static void AircraftEventHandler_AtTerminal(Aircraft *v, const AirportFTAClass *
 	switch (v->current_order.GetType()) {
 		case OT_GOTO_STATION: // ready to fly to another airport
 			break;
-		case OT_GOTO_DEPOT:   // visit hangar for serivicing, sale, etc.
+		case OT_GOTO_DEPOT:   // visit hangar for servicing, sale, etc.
 			go_to_hangar = v->current_order.GetDestination() == v->targetairport;
 			break;
 		case OT_CONDITIONAL:
diff --git a/src/airport.cpp b/src/airport.cpp
index 1a58be4..c3c67ef 100644
--- a/src/airport.cpp
+++ b/src/airport.cpp
@@ -22,7 +22,7 @@
  * @param terminals The terminals.
  * @param num_helipads Number of heli pads.
  * @param flags Information about the class of FTA.
- * @param delta_z Height of the arport above the land.
+ * @param delta_z Height of the airport above the land.
  */
 #define AIRPORT_GENERIC(name, terminals, num_helipads, flags, delta_z) \
 	static AirportFTAClass _airportfta_ ## name(_airport_moving_data_ ## name, terminals, \
@@ -41,7 +41,7 @@
  * Define a heliport.
  * @param name Suffix of the names of the helipad data.
  * @param num_helipads Number of heli pads.
- * @param delta_z Height of the arport above the land.
+ * @param delta_z Height of the airport above the land.
  */
 #define HELIPORT(name, num_helipads, delta_z) \
 	AIRPORT_GENERIC(name, NULL, num_helipads, AirportFTAClass::HELICOPTERS, delta_z)
diff --git a/src/articulated_vehicles.cpp b/src/articulated_vehicles.cpp
index a889ab3..9c9a1ba 100644
--- a/src/articulated_vehicles.cpp
+++ b/src/articulated_vehicles.cpp
@@ -68,7 +68,7 @@ bool IsArticulatedEngine(EngineID engine_type)
  * Count the number of articulated parts of an engine.
  * @param engine_type The engine to get the number of parts of.
  * @param purchase_window Whether we are in the scope of the purchase window or not, i.e. whether we cannot allocate vehicles.
- * @return The nmumber of parts.
+ * @return The number of parts.
  */
 uint CountArticulatedParts(EngineID engine_type, bool purchase_window)
 {
@@ -98,7 +98,7 @@ uint CountArticulatedParts(EngineID engine_type, bool purchase_window)
 
 /**
  * Returns the default (non-refitted) capacity of a specific EngineID.
- * @param engine the EngineID of iterest
+ * @param engine the EngineID of interest
  * @param cargo_type returns the default cargo type, if needed
  * @return capacity
  */
@@ -113,7 +113,7 @@ static inline uint16 GetVehicleDefaultCapacity(EngineID engine, CargoID *cargo_t
 
 /**
  * Returns all cargoes a vehicle can carry.
- * @param engine the EngineID of iterest
+ * @param engine the EngineID of interest
  * @param include_initial_cargo_type if true the default cargo type of the vehicle is included; if false only the refit_mask
  * @return bit set of CargoIDs
  */
diff --git a/src/autoreplace_cmd.cpp b/src/autoreplace_cmd.cpp
index de4bcb0..8d981c5 100644
--- a/src/autoreplace_cmd.cpp
+++ b/src/autoreplace_cmd.cpp
@@ -66,18 +66,18 @@ bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company)
 			/* make sure the railtypes are compatible */
 			if ((GetRailTypeInfo(e_from->u.rail.railtype)->compatible_railtypes & GetRailTypeInfo(e_to->u.rail.railtype)->compatible_railtypes) == 0) return false;
 
-			/* make sure we do not replace wagons with engines or vise versa */
+			/* make sure we do not replace wagons with engines or vice versa */
 			if ((e_from->u.rail.railveh_type == RAILVEH_WAGON) != (e_to->u.rail.railveh_type == RAILVEH_WAGON)) return false;
 			break;
 		}
 
 		case VEH_ROAD:
-			/* make sure that we do not replace a tram with a normal road vehicles or vise versa */
+			/* make sure that we do not replace a tram with a normal road vehicles or vice versa */
 			if (HasBit(e_from->info.misc_flags, EF_ROAD_TRAM) != HasBit(e_to->info.misc_flags, EF_ROAD_TRAM)) return false;
 			break;
 
 		case VEH_AIRCRAFT:
-			/* make sure that we do not replace a plane with a helicopter or vise versa */
+			/* make sure that we do not replace a plane with a helicopter or vice versa */
 			if ((e_from->u.air.subtype & AIR_CTOL) != (e_to->u.air.subtype & AIR_CTOL)) return false;
 			break;
 
@@ -263,7 +263,7 @@ static CommandCost GetNewEngineType(const Vehicle *v, const Company *c, bool alw
  * Builds and refits a replacement vehicle
  * Important: The old vehicle is still in the original vehicle chain (used for determining the cargo when the old vehicle did not carry anything, but the new one does)
  * @param old_veh A single (articulated/multiheaded) vehicle that shall be replaced.
- * @param new_vehicle Returns the newly build and refittet vehicle
+ * @param new_vehicle Returns the newly build and refitted vehicle
  * @param part_of_chain The vehicle is part of a train
  * @return cost or error
  */
diff --git a/src/autoreplace_gui.cpp b/src/autoreplace_gui.cpp
index 6477797..a1b663c 100644
--- a/src/autoreplace_gui.cpp
+++ b/src/autoreplace_gui.cpp
@@ -45,7 +45,7 @@ static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
  * @param id_g The group the engine belongs to
  *  Note: this function only works if it is called either
  *   - when a new vehicle is build, but before it's counted in num_engines
- *   - when a vehicle is deleted and after it's substracted from num_engines
+ *   - when a vehicle is deleted and after it's subtracted from num_engines
  *   - when not changing the count (used when changing replace orders)
  */
 void InvalidateAutoreplaceWindow(EngineID e, GroupID id_g)
diff --git a/src/base_media_func.h b/src/base_media_func.h
index 0bea235..b66ff12 100644
--- a/src/base_media_func.h
+++ b/src/base_media_func.h
@@ -263,7 +263,7 @@ template <class Tbase_set>
 			if (missing == 0) {
 				p += seprintf(p, last, " (%i corrupt file%s)\n", invalid, invalid == 1 ? "" : "s");
 			} else {
-				p += seprintf(p, last, " (unuseable: %i missing file%s)\n", missing, missing == 1 ? "" : "s");
+				p += seprintf(p, last, " (unusable: %i missing file%s)\n", missing, missing == 1 ? "" : "s");
 			}
 		} else {
 			p += seprintf(p, last, "\n");
diff --git a/src/bootstrap_gui.cpp b/src/bootstrap_gui.cpp
index 89b7430..c71ef2e 100644
--- a/src/bootstrap_gui.cpp
+++ b/src/bootstrap_gui.cpp
@@ -205,7 +205,7 @@ public:
 #endif /* defined(ENABLE_NETWORK) && defined(WITH_FREETYPE) */
 
 /**
- * Handle all procedures for bootstrapping OpenTTD without a base grapics set.
+ * Handle all procedures for bootstrapping OpenTTD without a base graphics set.
  * This requires all kinds of trickery that is needed to avoid the use of
  * sprites from the base graphics set which are pretty interwoven.
  * @return True if a base set exists, otherwise false.
diff --git a/src/bridge_gui.cpp b/src/bridge_gui.cpp
index 88473b7..aa04aed 100644
--- a/src/bridge_gui.cpp
+++ b/src/bridge_gui.cpp
@@ -381,7 +381,7 @@ void ShowBuildBridgeWindow(TileIndex start, TileIndex end, TransportType transpo
 	/* The bridge length without ramps. */
 	const uint bridge_len = GetTunnelBridgeLength(start, end);
 
-	/* If Ctrl is being pressed, check wether the last bridge built is available
+	/* If Ctrl is being pressed, check whether the last bridge built is available
 	 * If so, return this bridge type. Otherwise continue normally.
 	 * We store bridge types for each transport type, so we have to check for
 	 * the transport type beforehand.
diff --git a/src/bridge_map.h b/src/bridge_map.h
index 8c6bf83..5ab4fd5 100644
--- a/src/bridge_map.h
+++ b/src/bridge_map.h
@@ -41,7 +41,7 @@ static inline bool IsBridgeTile(TileIndex t)
  * checks for the possibility that a bridge may be on this tile
  * These are in fact all the tile types on which a bridge can be found
  * @param t The tile to analyze
- * @return true if a bridge migh be present
+ * @return true if a bridge might be present
  */
 static inline bool MayHaveBridgeAbove(TileIndex t)
 {
diff --git a/src/build_vehicle_gui.cpp b/src/build_vehicle_gui.cpp
index 5d42467..4d7a643 100644
--- a/src/build_vehicle_gui.cpp
+++ b/src/build_vehicle_gui.cpp
@@ -272,7 +272,7 @@ static int CDECL EnginePowerVsRunningCostSorter(const EngineID *a, const EngineI
 	 * we will actually calculate cunning cost/power (to make it more than 1).
 	 * Because of this, the return value have to be reversed as well and we return b - a instead of a - b.
 	 * Another thing is that both power and running costs should be doubled for multiheaded engines.
-	 * Since it would be multipling with 2 in both numerator and denumerator, it will even themselves out and we skip checking for multiheaded. */
+	 * Since it would be multiplying with 2 in both numerator and denominator, it will even themselves out and we skip checking for multiheaded. */
 	Money va = (e_a->GetRunningCost()) / max(1U, (uint)e_a->GetPower());
 	Money vb = (e_b->GetRunningCost()) / max(1U, (uint)e_b->GetPower());
 	int r = ClampToI32(vb - va);
@@ -968,7 +968,7 @@ struct BuildVehicleWindow : Window {
 		this->vscroll = this->GetScrollbar(WID_BV_SCROLLBAR);
 
 		/* If we are just viewing the list of vehicles, we do not need the Build button.
-		 * So we just hide it, and enlarge the Rename buton by the now vacant place. */
+		 * So we just hide it, and enlarge the Rename button by the now vacant place. */
 		if (this->listview_mode) this->GetWidget<NWidgetStacked>(WID_BV_BUILD_SEL)->SetDisplayedPlane(SZSP_NONE);
 
 		NWidgetCore *widget = this->GetWidget<NWidgetCore>(WID_BV_LIST);
diff --git a/src/cargomonitor.cpp b/src/cargomonitor.cpp
index be808fd..0f656a6 100644
--- a/src/cargomonitor.cpp
+++ b/src/cargomonitor.cpp
@@ -31,7 +31,7 @@ void ClearCargoDeliveryMonitoring()
 /**
  * Get and reset the amount associated with a cargo monitor.
  * @param[in,out] monitor_map Monitoring map to search (and reset for the queried entry).
- * @oaram monitor Cargo monitor to query/reset.
+ * @param monitor Cargo monitor to query/reset.
  * @param keep_monitoring After returning from this call, continue monitoring.
  * @return Amount collected since last query/activation for the monitored combination.
  */
diff --git a/src/cargopacket.h b/src/cargopacket.h
index 7964ea7..dcb1415 100644
--- a/src/cargopacket.h
+++ b/src/cargopacket.h
@@ -161,7 +161,7 @@ public:
 
 /**
  * Simple collection class for a list of cargo packets.
- * @tparam Tinst Actual instantation of this cargo list.
+ * @tparam Tinst Actual instantiation of this cargo list.
  */
 template <class Tinst>
 class CargoList {
diff --git a/src/cargotype.h b/src/cargotype.h
index 74fa5a9..8ee5fb7 100644
--- a/src/cargotype.h
+++ b/src/cargotype.h
@@ -46,7 +46,7 @@ enum CargoClass {
 	CC_LIQUID       = 1 <<  6, ///< Liquids (Oil, Water, Rubber)
 	CC_REFRIGERATED = 1 <<  7, ///< Refrigerated cargo (Food, Fruit)
 	CC_HAZARDOUS    = 1 <<  8, ///< Hazardous cargo (Nuclear Fuel, Explosives, etc.)
-	CC_COVERED      = 1 <<  9, ///< Covered/Sheltered Freight (Transporation in Box Vans, Silo Wagons, etc.)
+	CC_COVERED      = 1 <<  9, ///< Covered/Sheltered Freight (Transportation in Box Vans, Silo Wagons, etc.)
 	CC_SPECIAL      = 1 << 15, ///< Special bit used for livery refit tricks instead of normal cargoes.
 };
 
diff --git a/src/cheat_gui.cpp b/src/cheat_gui.cpp
index 6b37079..e4c7572 100644
--- a/src/cheat_gui.cpp
+++ b/src/cheat_gui.cpp
@@ -75,7 +75,7 @@ static int32 ClickChangeCompanyCheat(int32 p1, int32 p2)
  * Allow (or disallow) changing production of all industries.
  * @param p1 new value
  * @param p2 unused
- * @return New value allwing change of industry production.
+ * @return New value allowing change of industry production.
  */
 static int32 ClickSetProdCheat(int32 p1, int32 p2)
 {
diff --git a/src/clear_cmd.cpp b/src/clear_cmd.cpp
index f69c5d4..4659886 100644
--- a/src/clear_cmd.cpp
+++ b/src/clear_cmd.cpp
@@ -190,12 +190,12 @@ static void TileLoopClearAlps(TileIndex tile)
 		}
 	}
 	/* Update snow density. */
-	uint curent_density = GetClearDensity(tile);
+	uint current_density = GetClearDensity(tile);
 	uint req_density = (k < 0) ? 0u : min((uint)k, 3);
 
-	if (curent_density < req_density) {
+	if (current_density < req_density) {
 		AddClearDensity(tile, 1);
-	} else if (curent_density > req_density) {
+	} else if (current_density > req_density) {
 		AddClearDensity(tile, -1);
 	} else {
 		/* Density at the required level. */
diff --git a/src/command.cpp b/src/command.cpp
index aa2723e..eef7652 100644
--- a/src/command.cpp
+++ b/src/command.cpp
@@ -331,7 +331,7 @@ static const Command _command_proc_table[] = {
 /*!
  * This function range-checks a cmd, and checks if the cmd is not NULL
  *
- * @param cmd The integervalue of a command
+ * @param cmd The integer value of a command
  * @return true if the command is valid (and got a CommandProc function)
  */
 bool IsValidCommand(uint32 cmd)
diff --git a/src/command_type.h b/src/command_type.h
index ee7b1a9..49b11d3 100644
--- a/src/command_type.h
+++ b/src/command_type.h
@@ -277,7 +277,7 @@ enum Commands {
 
 	CMD_GIVE_MONEY,                   ///< give money to another company
 	CMD_CHANGE_SETTING,               ///< change a setting
-	CMD_CHANGE_COMPANY_SETTING,       ///< change a company etting
+	CMD_CHANGE_COMPANY_SETTING,       ///< change a company setting
 
 	CMD_SET_AUTOREPLACE,              ///< set an autoreplace entry
 
diff --git a/src/company_manager_face.h b/src/company_manager_face.h
index 11e0071..a7c2141 100644
--- a/src/company_manager_face.h
+++ b/src/company_manager_face.h
@@ -120,7 +120,7 @@ static inline void SetCompanyManagerFaceBits(CompanyManagerFace &cmf, CompanyMan
 /**
  * Increase/Decrease the company manager's face variable by the given amount.
  * If the new value greater than the max value for this variable it will be set to 0.
- * Or is it negativ (< 0) it will be set to max value.
+ * Or is it negative (< 0) it will be set to max value.
  *
  * @param cmf    the company manager face to write the bits to
  * @param cmfv   the company manager face variable to write the data of
diff --git a/src/console.cpp b/src/console.cpp
index 5ffc4ed..72d01c2 100644
--- a/src/console.cpp
+++ b/src/console.cpp
@@ -355,7 +355,7 @@ static void IConsoleAliasExec(const IConsoleAlias *alias, byte tokencount, char
 				aliasstream[astream_i++] = '"';
 				break;
 
-			case ';': // Cmd seperator, start new command
+			case ';': // Cmd separator, start new command
 				aliasstream[astream_i] = '\0';
 				aliases[++a_index] = &aliasstream[++astream_i];
 				cmdptr++;
@@ -364,7 +364,7 @@ static void IConsoleAliasExec(const IConsoleAlias *alias, byte tokencount, char
 			case '%': // Some or all parameters
 				cmdptr++;
 				switch (*cmdptr) {
-					case '+': { // All parameters seperated: "[param 1]" "[param 2]"
+					case '+': { // All parameters separated: "[param 1]" "[param 2]"
 						for (i = 0; i != tokencount; i++) {
 							aliasstream[astream_i++] = '"';
 							astream_i += IConsoleCopyInParams(&aliasstream[astream_i], tokens[i], astream_i);
@@ -412,7 +412,7 @@ static void IConsoleAliasExec(const IConsoleAlias *alias, byte tokencount, char
 
 /**
  * Execute a given command passed to us. First chop it up into
- * individual tokens (seperated by spaces), then execute it if possible
+ * individual tokens (separated by spaces), then execute it if possible
  * @param cmdstr string to be parsed and executed
  */
 void IConsoleCmdExec(const char *cmdstr)
@@ -439,14 +439,14 @@ void IConsoleCmdExec(const char *cmdstr)
 	memset(&tokens, 0, sizeof(tokens));
 	memset(&tokenstream, 0, sizeof(tokenstream));
 
-	/* 1. Split up commandline into tokens, seperated by spaces, commands
+	/* 1. Split up commandline into tokens, separated by spaces, commands
 	 * enclosed in "" are taken as one token. We can only go as far as the amount
 	 * of characters in our stream or the max amount of tokens we can handle */
 	for (cmdptr = cmdstr, t_index = 0, tstream_i = 0; *cmdptr != '\0'; cmdptr++) {
 		if (t_index >= lengthof(tokens) || tstream_i >= lengthof(tokenstream)) break;
 
 		switch (*cmdptr) {
-		case ' ': // Token seperator
+		case ' ': // Token separator
 			if (!foundtoken) break;
 
 			if (longtoken) {
diff --git a/src/console_cmds.cpp b/src/console_cmds.cpp
index cef6e89..a131131 100644
--- a/src/console_cmds.cpp
+++ b/src/console_cmds.cpp
@@ -1066,7 +1066,7 @@ DEF_CONSOLE_CMD(ConRestart)
 }
 
 /**
- * Print a text buffer line by line to the console. Lines are seperated by '\n'.
+ * Print a text buffer line by line to the console. Lines are separated by '\n'.
  * @param buf The buffer to print.
  * @note All newlines are replace by '\0' characters.
  */
diff --git a/src/console_internal.h b/src/console_internal.h
index 8cbf1a1..1b63b26 100644
--- a/src/console_internal.h
+++ b/src/console_internal.h
@@ -28,7 +28,7 @@ enum ConsoleHookResult {
  * --Commands--
  * Commands are commands, or functions. They get executed once and any
  * effect they produce are carried out. The arguments to the commands
- * are given to them, each input word seperated by a double-quote (") is an argument
+ * are given to them, each input word separated by a double-quote (") is an argument
  * If you want to handle multiple words as one, enclose them in double-quotes
  * eg. 'say "hello sexy boy"'
  */
@@ -50,7 +50,7 @@ struct IConsoleCmd {
  * (eg. 'ng' for 'load %A; unpause; debug_level 5'). Aliases can parse the arguments
  * given to them in the command line.
  * - "%A - %Z" substitute arguments 1 t/m 26
- * - "%+" lists all parameters keeping them seperated
+ * - "%+" lists all parameters keeping them separated
  * - "%!" also lists all parameters but presenting them to the aliased command as one argument
  * - ";" allows for combining commands (see example 'ng')
  */
diff --git a/src/crashlog.h b/src/crashlog.h
index 4dd8c83..6f7fb3c 100644
--- a/src/crashlog.h
+++ b/src/crashlog.h
@@ -72,7 +72,7 @@ protected:
 	virtual char *LogRegisters(char *buffer, const char *last) const;
 
 	/**
-	 * Writes the dynamically linked libaries/modules to the buffer, if there
+	 * Writes the dynamically linked libraries/modules to the buffer, if there
 	 * is information about it available.
 	 * @param buffer The begin where to write at.
 	 * @param last   The last position in the buffer to write to.
diff --git a/src/currency.cpp b/src/currency.cpp
index 005ad98..44cd6dd 100644
--- a/src/currency.cpp
+++ b/src/currency.cpp
@@ -62,7 +62,7 @@ static const CurrencySpec origin_currency_specs[NUM_CURRENCY] = {
 CurrencySpec _currency_specs[NUM_CURRENCY];
 
 /**
- * These enums are only declared in order to make sens
+ * These enums are only declared in order to make sense
  * out of the TTDPatch_To_OTTDIndex array that will follow
  * Every currency used by Ottd is there, just in case TTDPatch will
  * add those missing in its code
@@ -129,7 +129,7 @@ const byte TTDPatch_To_OTTDIndex[] =
 };
 
 /**
- * Will return the ottd's index correspondance to
+ * Will return the ottd's index correspondence to
  * the ttdpatch's id.  If the id is bigger than the array,
  * it is a grf written for ottd, thus returning the same id.
  * Only called from newgrf.cpp
@@ -180,7 +180,7 @@ void CheckSwitchToEuro()
  * Called only from newgrf.cpp and settings.cpp.
  * @param preserve_custom will not reset custom currency (the latest one on the list)
  *        if ever it is flagged to true. In which case, the total size of the memory to move
- *        will be one currency spec less, thus preserving the custom curreny from been
+ *        will be one currency spec less, thus preserving the custom currency from been
  *        overwritten.
  */
 void ResetCurrencies(bool preserve_custom)
diff --git a/src/date.cpp b/src/date.cpp
index db06626..9df6483 100644
--- a/src/date.cpp
+++ b/src/date.cpp
@@ -138,7 +138,7 @@ void ConvertDateToYMD(Date date, YearMonthDay *ymd)
 }
 
 /**
- * Converts a tupe of Year, Month and Day to a Date.
+ * Converts a tuple of Year, Month and Day to a Date.
  * @param year  is a number between 0..MAX_YEAR
  * @param month is a number between 0..11
  * @param day   is a number between 1..31
diff --git a/src/debug.h b/src/debug.h
index ecb6a59..f7e7717 100644
--- a/src/debug.h
+++ b/src/debug.h
@@ -83,7 +83,7 @@ uint64 ottd_rdtsc();
  *
  * for (int i = 0; i < 5; i++) {
  *   TIC();
- *     --Do yuor code--
+ *     --Do your code--
  *   TOC("A name", 5);
  * }
  *
diff --git a/src/depot_gui.cpp b/src/depot_gui.cpp
index 106d9c9..d8b04ae 100644
--- a/src/depot_gui.cpp
+++ b/src/depot_gui.cpp
@@ -723,7 +723,7 @@ struct DepotWindow : Window {
 			}
 
 			case WID_D_SELL_ALL:
-				/* Only open the confimation window if there are anything to sell */
+				/* Only open the confirmation window if there are anything to sell */
 				if (this->vehicle_list.Length() != 0 || this->wagon_list.Length() != 0) {
 					TileIndex tile = this->window_number;
 					byte vehtype = this->type;
diff --git a/src/direction_func.h b/src/direction_func.h
index bf92a9a..657645e 100644
--- a/src/direction_func.h
+++ b/src/direction_func.h
@@ -93,7 +93,7 @@ static inline DiagDirection ReverseDiagDir(DiagDirection d)
  * the new DiagDirection.
  *
  * @param d The DiagDirection
- * @param delta The difference to applie on
+ * @param delta The difference to apply on
  * @return The new direction which was calculated
  */
 static inline DiagDirection ChangeDiagDir(DiagDirection d, DiagDirDiff delta)
@@ -207,7 +207,7 @@ static inline DiagDirection XYNSToDiagDir(Axis xy, uint ns)
 }
 
 /**
- * Checks if an interger value is a valid DiagDirection
+ * Checks if an integer value is a valid DiagDirection
  *
  * @param d The value to check
  * @return True if the value belongs to a DiagDirection, else false
diff --git a/src/direction_type.h b/src/direction_type.h
index c14ab51..e6e08a1 100644
--- a/src/direction_type.h
+++ b/src/direction_type.h
@@ -66,7 +66,7 @@ enum DirDiff {
 	DIRDIFF_SAME    = 0,    ///< Both directions faces to the same direction
 	DIRDIFF_45RIGHT = 1,    ///< Angle of 45 degrees right
 	DIRDIFF_90RIGHT = 2,    ///< Angle of 90 degrees right
-	DIRDIFF_REVERSE = 4,    ///< One direction is the opposit of the other one
+	DIRDIFF_REVERSE = 4,    ///< One direction is the opposite of the other one
 	DIRDIFF_90LEFT  = 6,    ///< Angle of 90 degrees left
 	DIRDIFF_45LEFT  = 7,    ///< Angle of 45 degrees left
 };
@@ -119,7 +119,7 @@ DECLARE_POSTFIX_INCREMENT(DiagDirDiff)
 /**
  * Enumeration for the two axis X and Y
  *
- * This enumeration represente the two axis X and Y in the game.
+ * This enumeration represents the two axis X and Y in the game.
  * The X axis is the one which goes align the north-west edge
  * (and south-east edge). The Y axis must be so the one which goes
  * align the north-east edge (and south-west) edge.
diff --git a/src/disaster_cmd.cpp b/src/disaster_cmd.cpp
index 916a9b4..c2365e0 100644
--- a/src/disaster_cmd.cpp
+++ b/src/disaster_cmd.cpp
@@ -382,7 +382,7 @@ static void DestructIndustry(Industry *i)
 
 /**
  * Aircraft handling, v->current_order.dest states:
- * 0: Fly towards the targetted industry
+ * 0: Fly towards the targeted industry
  * 1: If within 15 tiles, fire away rockets and destroy industry
  * 2: Industry explosions
  * 3: Fly out of the map
diff --git a/src/dock_gui.cpp b/src/dock_gui.cpp
index e7b8646..68c0126 100644
--- a/src/dock_gui.cpp
+++ b/src/dock_gui.cpp
@@ -87,7 +87,7 @@ static TileIndex GetOtherAqueductEnd(TileIndex tile_from, TileIndex *tile_to = N
 	return endtile;
 }
 
-/** Toolbar window for constructing water infra structure. */
+/** Toolbar window for constructing water infrastructure. */
 struct BuildDocksToolbarWindow : Window {
 	DockToolbarWidgets last_clicked_widget; ///< Contains the last widget that has been clicked on this toolbar.
 
diff --git a/src/economy.cpp b/src/economy.cpp
index 92f9a0c..53446df 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -291,7 +291,7 @@ void ChangeOwnershipOfCompanyItems(Owner old_owner, Owner new_owner)
 #endif /* ENABLE_NETWORK */
 	if (old_owner == _local_company) {
 		/* Single player cheated to AI company.
-		 * There are no specatators in single player, so we must pick some other company. */
+		 * There are no spectators in single player, so we must pick some other company. */
 		assert(!_networking);
 		Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
 		Company *c;
@@ -461,7 +461,7 @@ void ChangeOwnershipOfCompanyItems(Owner old_owner, Owner new_owner)
 		if (new_owner != INVALID_OWNER) {
 			/* Update all signals because there can be new segment that was owned by two companies
 			 * and signals were not propagated
-			 * Similiar with crossings - it is needed to bar crossings that weren't before
+			 * Similar with crossings - it is needed to bar crossings that weren't before
 			 * because of different owner of crossing and approaching train */
 			tile = 0;
 
@@ -545,7 +545,7 @@ static void CompanyCheckBankrupt(Company *c)
 		case 9:
 			break;
 
-		/* Warn about bancruptcy after 3 months */
+		/* Warn about bankruptcy after 3 months */
 		case 4: {
 			CompanyNewsInformation *cni = MallocT<CompanyNewsInformation>(1);
 			cni->FillData(c);
@@ -572,7 +572,7 @@ static void CompanyCheckBankrupt(Company *c)
 			/* FALL THROUGH  to case 10 */
 		}
 
-		/* Bancrupt company after 6 months (if the company has no value) or latest
+		/* Bankrupt company after 6 months (if the company has no value) or latest
 		 * after 9 months (if it still had value after 6 months) */
 		default:
 		case 10: {
@@ -696,7 +696,7 @@ bool AddInflation(bool check_year)
 	/* Approximation for (100 + infl_amount)% ** (1 / 12) - 100%
 	 * scaled by 65536
 	 * 12 -> months per year
-	 * This is only a good approxiamtion for small values
+	 * This is only a good approximation for small values
 	 */
 	_economy.inflation_prices  += (_economy.inflation_prices  * _economy.infl_amount    * 54) >> 16;
 	_economy.inflation_payment += (_economy.inflation_payment * _economy.infl_amount_pr * 54) >> 16;
@@ -866,7 +866,7 @@ void StartupIndustryDailyChanges(bool init_counter)
 	 * which stands for the days in a month.
 	 * Using just 31 will make it so that a monthly reset (based on the real number of days of that month)
 	 * would not be needed.
-	 * Since it is based on "fractionnal parts", the leftover days will not make much of a difference
+	 * Since it is based on "fractional parts", the leftover days will not make much of a difference
 	 * on the overall total number of changes performed */
 	_economy.industry_daily_increment = (1 << map_size) / 31;
 
diff --git a/src/effectvehicle.cpp b/src/effectvehicle.cpp
index 033d0bd..a0ca3e1 100644
--- a/src/effectvehicle.cpp
+++ b/src/effectvehicle.cpp
@@ -547,7 +547,7 @@ static EffectInitProc * const _effect_init_procs[] = {
 };
 assert_compile(lengthof(_effect_init_procs) == EV_END);
 
-/** Functions for controling effect vehicles at each tick. */
+/** Functions for controlling effect vehicles at each tick. */
 static EffectTickProc * const _effect_tick_procs[] = {
 	ChimneySmokeTick,   // EV_CHIMNEY_SMOKE
 	SteamSmokeTick,     // EV_STEAM_SMOKE
diff --git a/src/elrail.cpp b/src/elrail.cpp
index 5d4a4a6..6cef5f5 100644
--- a/src/elrail.cpp
+++ b/src/elrail.cpp
@@ -25,7 +25,7 @@
  * Group 0: Tiles with both an even X coordinate and an even Y coordinate
  * Group 1: Tiles with an even X and an odd Y coordinate
  * Group 2: Tiles with an odd X and an even Y coordinate
- * Group 3: Tiles with both an odd X and Y coordnate.
+ * Group 3: Tiles with both an odd X and Y coordinate.
  *
  * <h3>Pylon Points</h3>
  * <h4>Control Points</h4>
@@ -39,7 +39,7 @@
  * other tile.
  *
  * Now on each edge there are two PCPs: One from each adjacent tile. Both PCPs
- * are merged using an OR operation (i. e. if one tile needs a PCP at the postion
+ * are merged using an OR operation (i. e. if one tile needs a PCP at the position
  * in question, both tiles get it).
  *
  * <h4>Position Points</h4>
@@ -127,7 +127,7 @@ static TrackBits MaskWireBits(TileIndex t, TrackBits tracks)
 
 	TrackdirBits neighbour_tdb = TRACKDIR_BIT_NONE;
 	for (DiagDirection d = DIAGDIR_BEGIN; d < DIAGDIR_END; d++) {
-		/* If the neighbor tile is either not electrified or has no tracks that can be reached
+		/* If the neighbour tile is either not electrified or has no tracks that can be reached
 		 * from this tile, mark all trackdirs that can be reached from the neighbour tile
 		 * as needing no catenary. */
 		RailType rt = GetTileRailType(TileAddByDiagDir(t, d));
@@ -369,7 +369,7 @@ static void DrawCatenaryRailway(const TileInfo *ti)
 		/* Station and road crossings are always "flat", so adjust the tileh accordingly */
 		if (IsTileType(neighbour, MP_STATION) || IsTileType(neighbour, MP_ROAD)) tileh[TS_NEIGHBOUR] = SLOPE_FLAT;
 
-		/* Read the foundataions if they are present, and adjust the tileh */
+		/* Read the foundations if they are present, and adjust the tileh */
 		if (trackconfig[TS_NEIGHBOUR] != TRACK_BIT_NONE && IsTileType(neighbour, MP_RAILWAY) && HasCatenary(GetRailType(neighbour))) foundation = GetRailFoundation(tileh[TS_NEIGHBOUR], trackconfig[TS_NEIGHBOUR]);
 		if (IsBridgeTile(neighbour)) {
 			foundation = GetBridgeFoundation(tileh[TS_NEIGHBOUR], DiagDirToAxis(GetTunnelBridgeDirection(neighbour)));
@@ -419,7 +419,7 @@ static void DrawCatenaryRailway(const TileInfo *ti)
 
 					/* Don't build the pylon if it would be outside the tile */
 					if (!HasBit(OwnedPPPonPCP[i], temp)) {
-						/* We have a neighour that will draw it, bail out */
+						/* We have a neighbour that will draw it, bail out */
 						if (trackconfig[TS_NEIGHBOUR] != TRACK_BIT_NONE) break;
 						continue; // No neighbour, go looking for a better position
 					}
diff --git a/src/engine.cpp b/src/engine.cpp
index 04ceec7..fa9b1dc 100644
--- a/src/engine.cpp
+++ b/src/engine.cpp
@@ -854,7 +854,7 @@ void EnginesDailyLoop()
  * Accept an engine prototype. XXX - it is possible that the top-company
  * changes while you are waiting to accept the offer? Then it becomes invalid
  * @param tile unused
- * @param flags operation to perfom
+ * @param flags operation to perform
  * @param p1 engine-prototype offered
  * @param p2 unused
  * @param text unused
@@ -1000,7 +1000,7 @@ static bool IsUniqueEngineName(const char *name)
 /**
  * Rename an engine.
  * @param tile unused
- * @param flags operation to perfom
+ * @param flags operation to perform
  * @param p1 engine ID to rename
  * @param p2 unused
  * @param text the new name or an empty string when resetting to the default
diff --git a/src/engine_base.h b/src/engine_base.h
index 789a26d..99a15aa 100644
--- a/src/engine_base.h
+++ b/src/engine_base.h
@@ -72,7 +72,7 @@ struct Engine : EnginePool::PoolItem<&_engine_pool> {
 	 * Usually a valid cargo is returned, even though the vehicle has zero capacity, and can therefore not carry anything. But the cargotype is still used
 	 * for livery selection etc..
 	 *
-	 * Vehicles with CT_INVALID as default cargo are usally not available, but it can appear as default cargo of articulated parts.
+	 * Vehicles with CT_INVALID as default cargo are usually not available, but it can appear as default cargo of articulated parts.
 	 *
 	 * @return The default cargo type.
 	 * @see CanCarryCargo
diff --git a/src/error.h b/src/error.h
index 34fb3fb..438d70d 100644
--- a/src/error.h
+++ b/src/error.h
@@ -18,7 +18,7 @@
 
 /** Message severity/type */
 enum WarningLevel {
-	WL_INFO,     ///< Used for DoCommand-like (and some nonfatal AI GUI) errors/information
+	WL_INFO,     ///< Used for DoCommand-like (and some non-fatal AI GUI) errors/information
 	WL_WARNING,  ///< Other information
 	WL_ERROR,    ///< Errors (eg. saving/loading failed)
 	WL_CRITICAL, ///< Critical errors, the MessageBox is shown in all cases
diff --git a/src/error_gui.cpp b/src/error_gui.cpp
index 6c4c2e9..db73d31 100644
--- a/src/error_gui.cpp
+++ b/src/error_gui.cpp
@@ -67,7 +67,7 @@ static const WindowDesc _errmsg_face_desc(
 );
 
 /**
- * Copy the given data into our instace.
+ * Copy the given data into our instance.
  * @param data The data to copy.
  */
 ErrorMessageData::ErrorMessageData(const ErrorMessageData &data)
diff --git a/src/fileio.cpp b/src/fileio.cpp
index 924141a..75fdb3f 100644
--- a/src/fileio.cpp
+++ b/src/fileio.cpp
@@ -643,7 +643,7 @@ static void SimplifyFileName(char *name)
 	/* Force lowercase */
 	strtolower(name);
 
-	/* Tar-files always have '/' path-seperator, but we want our PATHSEPCHAR */
+	/* Tar-files always have '/' path-separator, but we want our PATHSEPCHAR */
 #if (PATHSEPCHAR != '/')
 	for (char *n = name; *n != '\0'; n++) if (*n == '/') *n = PATHSEPCHAR;
 #endif
@@ -1364,7 +1364,7 @@ static uint ScanTar(FileScanner *fs, const char *extension, TarFileList::iterato
 }
 
 /**
- * Scan for files with the given extention in the given search path.
+ * Scan for files with the given extension in the given search path.
  * @param extension the extension of files to search for.
  * @param sd        the sub directory to search in.
  * @param tars      whether to search in the tars too.
@@ -1410,7 +1410,7 @@ uint FileScanner::Scan(const char *extension, Subdirectory sd, bool tars, bool r
 }
 
 /**
- * Scan for files with the given extention in the given search path.
+ * Scan for files with the given extension in the given search path.
  * @param extension the extension of files to search for.
  * @param directory the sub directory to search in.
  * @param recursive whether to search recursively
diff --git a/src/fios.h b/src/fios.h
index aca7ff4..941371f 100644
--- a/src/fios.h
+++ b/src/fios.h
@@ -88,9 +88,9 @@ enum FileSlots {
 	CONFIG_SLOT    =  0,
 	/** Slot for the sound. */
 	SOUND_SLOT     =  1,
-	/** First slot useable for (New)GRFs used during the game. */
+	/** First slot usable for (New)GRFs used during the game. */
 	FIRST_GRF_SLOT =  2,
-	/** Last slot useable for (New)GRFs used during the game. */
+	/** Last slot usable for (New)GRFs used during the game. */
 	LAST_GRF_SLOT  = 63,
 	/** Maximum number of slots. */
 	MAX_FILE_SLOTS = 64
diff --git a/src/fontcache.cpp b/src/fontcache.cpp
index 4623315..d5f2b3f 100644
--- a/src/fontcache.cpp
+++ b/src/fontcache.cpp
@@ -160,8 +160,8 @@ static FT_Error GetFontByFaceName(const char *font_name, FT_Face *face)
 		 * - Batang & BatangChe & Gungsuh & GungsuhChe (TrueType)
 		 * We will strip the font-type '()' if any and work with the font name
 		 * itself, which must match exactly; if...
-		 * TTC files, font files which contain more than one font are seperated
-		 * byt '&'. Our best bet will be to do substr match for the fontname
+		 * TTC files, font files which contain more than one font are separated
+		 * by '&'. Our best bet will be to do substr match for the fontname
 		 * and then let FreeType figure out which index to load */
 		s = _tcschr(vbuffer, _T('('));
 		if (s != NULL) s[-1] = '\0';
@@ -182,7 +182,7 @@ static FT_Error GetFontByFaceName(const char *font_name, FT_Face *face)
 	 * contain multiple fonts inside this single file. GetFontData however
 	 * returns the whole file, so we need to check each font inside to get the
 	 * proper font.
-	 * Also note that FreeType does not support UNICODE filesnames! */
+	 * Also note that FreeType does not support UNICODE filenames! */
 #if defined(UNICODE)
 	/* We need a cast here back from wide because FreeType doesn't support
 	 * widechar filenames. Just use the buffer we allocated before for the
@@ -570,7 +570,7 @@ bool SetFallbackFont(FreeTypeSettings *settings, const char *language_isocode, i
 		strecpy(buff, str, lastof(buff));
 		str_validate(buff, lastof(buff), SVS_ALLOW_NEWLINE);
 
-		/* Extract a UniChar represenation of the sample string. */
+		/* Extract a UniChar representation of the sample string. */
 		CFStringRef cf_str = CFStringCreateWithCString(kCFAllocatorDefault, buff, kCFStringEncodingUTF8);
 		if (cf_str == NULL) {
 			/* Something went wrong. Corrupt/invalid sample string? */
@@ -590,7 +590,7 @@ bool SetFallbackFont(FreeTypeSettings *settings, const char *language_isocode, i
 		ATSUCreateTextLayoutWithTextPtr(string, kATSUFromTextBeginning, kATSUToTextEnd, str_len, 1, &run_len, &style, &text_layout);
 
 		/* Try to match a font for the sample text. ATSUMatchFontsToText stops after
-		 * it finds the first continous character run not renderable with the currently
+		 * it finds the first continuous character run not renderable with the currently
 		 * selected font starting at offset. The matching needs to be repeated until
 		 * the end of the string is reached to make sure the fallback font matches for
 		 * all characters in the string and not only the first run. */
diff --git a/src/gfx.cpp b/src/gfx.cpp
index eb62e56..bba1cc5 100644
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -362,7 +362,7 @@ static UChar *HandleBiDiAndArabicShapes(UChar *buffer)
 
 
 /**
- * Truncate a given string to a maximum width if neccessary.
+ * Truncate a given string to a maximum width if necessary.
  * If the string is truncated, add three dots ('...') to show this.
  * @param *str string that is checked and possibly truncated
  * @param maxw maximum width in pixels of the string
@@ -751,7 +751,7 @@ uint32 FormatStringLinebreaks(char *str, const char *last, int maxw, FontSize si
 end_of_inner_loop:
 		/* String didn't fit on line (or a '\n' was encountered), so 'dummy' terminate
 		 * and increase linecount. We use Utf8PrevChar() as also non 1 char long
-		 * whitespace seperators are supported */
+		 * whitespace separators are supported */
 		num++;
 		char *s = Utf8PrevChar(str);
 		*s++ = '\0';
@@ -1074,14 +1074,14 @@ void DrawCharCentered(WChar c, int x, int y, TextColour colour)
 /**
  * Draw a string at the given coordinates with the given colour.
  *  While drawing the string, parse it in case some formatting is specified,
- *  like new colour, new size or even positionning.
+ *  like new colour, new size or even positioning.
  * @param string              The string to draw. This is already bidi reordered.
  * @param x                   Offset from left side of the screen
  * @param y                   Offset from top side of the screen
  * @param params              Text drawing parameters
  * @param parse_string_also_when_clipped
  *                            By default, always test the available space where to draw the string.
- *                            When in multipline drawing, it would already be done,
+ *                            When in multiline drawing, it would already be done,
  *                            so no need to re-perform the same kind (more or less) of verifications.
  *                            It's not only an optimisation, it's also a way to ensures the string will be parsed
  *                            (as there are certain side effects on global variables, which are important for the next line)
@@ -1455,7 +1455,7 @@ void DoPaletteAnimations()
 	}
 
 	Colour *palette_pos = &_cur_palette.palette[PALETTE_ANIM_START];  // Points to where animations are taking place on the palette
-	/* Makes a copy of the current anmation palette in old_val,
+	/* Makes a copy of the current animation palette in old_val,
 	 * so the work on the current palette could be compared, see if there has been any changes */
 	memcpy(old_val, palette_pos, sizeof(old_val));
 
@@ -1837,7 +1837,7 @@ void DrawDirtyBlocks()
  * @param left The left edge of the rectangle
  * @param top The top edge of the rectangle
  * @param right The right edge of the rectangle
- * @param bottom The bottm edge of the rectangle
+ * @param bottom The bottom edge of the rectangle
  * @see DrawDirtyBlocks
  *
  * @todo The name of the function should be called like @c AddDirtyBlock as
diff --git a/src/gfx_func.h b/src/gfx_func.h
index 2425a40..3cb3aa1 100644
--- a/src/gfx_func.h
+++ b/src/gfx_func.h
@@ -26,10 +26,10 @@
  * This whole mechanism is controlled by an rectangle defined in #_invalid_rect. This
  * rectangle defines the area on the screen which must be repaint. If a new object
  * needs to be repainted this rectangle is extended to 'catch' the object on the
- * screen. At some point (which is normaly uninteressted for patch writers) this
+ * screen. At some point (which is normally uninteresting for patch writers) this
  * rectangle is send to the video drivers method
  * VideoDriver::MakeDirty and it is truncated back to an empty rectangle. At some
- * later point (which is uninteressted, too) the video driver
+ * later point (which is uninteresting, too) the video driver
  * repaints all these saved rectangle instead of the whole screen and drop the
  * rectangle informations. Then a new round begins by marking objects "dirty".
  *
diff --git a/src/gfxinit.cpp b/src/gfxinit.cpp
index 50efd9a..0ee82d0 100644
--- a/src/gfxinit.cpp
+++ b/src/gfxinit.cpp
@@ -352,7 +352,7 @@ template <class Tbase_set>
 
 	const Tbase_set *best = NULL;
 	for (const Tbase_set *c = BaseMedia<Tbase_set>::available_sets; c != NULL; c = c->next) {
-		/* Skip unuseable sets */
+		/* Skip unusable sets */
 		if (c->GetNumMissing() != 0) continue;
 
 		if (best == NULL ||
diff --git a/src/graph_gui.cpp b/src/graph_gui.cpp
index 82d862d..ab264f3 100644
--- a/src/graph_gui.cpp
+++ b/src/graph_gui.cpp
@@ -285,7 +285,7 @@ protected:
 		ValuesInterval interval; ///< Interval that contains all of the graph data.
 		int x_axis_offset;       ///< Distance from the top of the graph to the x axis.
 
-		/* the colours and cost array of GraphDrawer must accomodate
+		/* the colours and cost array of GraphDrawer must accommodate
 		 * both values for cargo and companies. So if any are higher, quit */
 		assert_compile(GRAPH_MAX_DATASETS >= (int)NUM_CARGO && GRAPH_MAX_DATASETS >= (int)MAX_COMPANIES);
 		assert(this->num_vert_lines > 0);
@@ -423,7 +423,7 @@ protected:
 					if (datapoint != INVALID_DATAPOINT) {
 						/*
 						 * Check whether we need to reduce the 'accuracy' of the
-						 * datapoint value and the highest value to splut overflows.
+						 * datapoint value and the highest value to split overflows.
 						 * And when 'drawing' 'one million' or 'one million and one'
 						 * there is no significant difference, so the least
 						 * significant bits can just be removed.
diff --git a/src/heightmap.cpp b/src/heightmap.cpp
index be51dc0..8f0fac6 100644
--- a/src/heightmap.cpp
+++ b/src/heightmap.cpp
@@ -344,7 +344,7 @@ static void GrayscaleToMapHeights(uint img_width, uint img_height, byte *map)
 					(col < col_pad) || (col >= (width  - col_pad - (_settings_game.construction.freeform_edges ? 0 : 1)))) {
 				SetTileHeight(tile, 0);
 			} else {
-				/* Use nearest neighbor resizing to scale map data.
+				/* Use nearest neighbour resizing to scale map data.
 				 *  We rotate the map 45 degrees (counter)clockwise */
 				img_row = (((row - row_pad) * num_div) / img_scale);
 				switch (_settings_game.game_creation.heightmap_rotation) {
@@ -464,7 +464,7 @@ bool GetHeightmapDimensions(char *filename, uint *x, uint *y)
  * Load a heightmap from file and change the map in his current dimensions
  *  to a landscape representing the heightmap.
  * It converts pixels to height. The brighter, the higher.
- * @param filename of the heighmap file to be imported
+ * @param filename of the heightmap file to be imported
  */
 void LoadHeightmap(char *filename)
 {
diff --git a/src/hotkeys.cpp b/src/hotkeys.cpp
index 1b3c6ea..a41ede7 100644
--- a/src/hotkeys.cpp
+++ b/src/hotkeys.cpp
@@ -131,7 +131,7 @@ static void ParseHotkeys(Hotkey<T> *hotkey, const char *value)
 
 /**
  * Convert a hotkey to it's string representation so it can be written to the
- * config file. Seperate parts of the keycode (like "CTRL" and "F1" are split
+ * config file. Separate parts of the keycode (like "CTRL" and "F1" are split
  * by a '+'.
  * @param keycode The keycode to convert to a string.
  * @return A string representation of this keycode.
diff --git a/src/industry.h b/src/industry.h
index f6e32b2..5e5d046 100644
--- a/src/industry.h
+++ b/src/industry.h
@@ -79,7 +79,7 @@ struct Industry : IndustryPool::PoolItem<&_industry_pool> {
 	/**
 	 * Check if a given tile belongs to this industry.
 	 * @param tile The tile to check.
-	 * @return True if the tils is part of this industry.
+	 * @return True if the tile is part of this industry.
 	 */
 	inline bool TileBelongsToIndustry(TileIndex tile) const
 	{
diff --git a/src/industry_cmd.cpp b/src/industry_cmd.cpp
index ab10c7d..5a62a32 100644
--- a/src/industry_cmd.cpp
+++ b/src/industry_cmd.cpp
@@ -329,7 +329,7 @@ static void DrawTile_Industry(TileInfo *ti)
 
 	SpriteID image = dits->ground.sprite;
 
-	/* DrawFoundation() modifes ti->z and ti->tileh */
+	/* DrawFoundation() modifies ti->z and ti->tileh */
 	if (ti->tileh != SLOPE_FLAT) DrawFoundation(ti, FOUNDATION_LEVELED);
 
 	/* If the ground sprite is the default flat water sprite, draw also canal/river borders.
@@ -2653,7 +2653,7 @@ void IndustryDailyLoop()
 	 * is sufficient for an industry. */
 	uint16 change_loop = _economy.industry_daily_change_counter >> 16;
 
-	/* Reset the active part of the counter, just keeping the "factional part" */
+	/* Reset the active part of the counter, just keeping the "fractional part" */
 	_economy.industry_daily_change_counter &= 0xFFFF;
 
 	if (change_loop == 0) {
diff --git a/src/industry_gui.cpp b/src/industry_gui.cpp
index 308d992..3450c1c 100644
--- a/src/industry_gui.cpp
+++ b/src/industry_gui.cpp
@@ -247,7 +247,7 @@ class BuildIndustryWindow : public Window {
 			}
 		}
 
-		/* first indutry type is selected if the current selection is invalid.
+		/* first industry type is selected if the current selection is invalid.
 		 * I'll be damned if there are none available ;) */
 		if (this->selected_index == -1) {
 			this->selected_index = 0;
diff --git a/src/industry_map.h b/src/industry_map.h
index 33f60ff..14fb990 100644
--- a/src/industry_map.h
+++ b/src/industry_map.h
@@ -157,7 +157,7 @@ static inline void SetIndustryGfx(TileIndex t, IndustryGfx gfx)
 }
 
 /**
- * Returns this indutry tile's construction counter value
+ * Returns this industry tile's construction counter value
  * @param tile the tile to query
  * @pre IsTileType(tile, MP_INDUSTRY)
  * @return the construction counter
@@ -169,7 +169,7 @@ static inline byte GetIndustryConstructionCounter(TileIndex tile)
 }
 
 /**
- * Sets this indutry tile's construction counter value
+ * Sets this industry tile's construction counter value
  * @param tile the tile to query
  * @param value the new value for the construction counter
  * @pre IsTileType(tile, MP_INDUSTRY)
diff --git a/src/industrytype.h b/src/industrytype.h
index 8102548..03b6c79 100644
--- a/src/industrytype.h
+++ b/src/industrytype.h
@@ -143,7 +143,7 @@ struct IndustrySpec {
 };
 
 /**
- * Defines the data structure of each indivudual tile of an industry.
+ * Defines the data structure of each individual tile of an industry.
  */
 struct IndustryTileSpec {
 	CargoID accepts_cargo[3];             ///< Cargo accepted by this tile
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index 444725c..0938308 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -76,7 +76,7 @@ void HandleOnEditText(const char *str)
 
 		uint32 money_c = Clamp(ClampToI32(money), 0, 20000000); // Clamp between 20 million and 0
 
-		/* Give 'id' the money, and substract it from ourself */
+		/* Give 'id' the money, and subtract it from ourself */
 		DoCommandP(0, money_c, _rename_id, CMD_GIVE_MONEY | CMD_MSG(STR_ERROR_INSUFFICIENT_FUNDS), CcGiveMoney, str);
 		break;
 	}
diff --git a/src/map_func.h b/src/map_func.h
index 105090f..9198c2c 100644
--- a/src/map_func.h
+++ b/src/map_func.h
@@ -146,7 +146,7 @@ static inline uint ScaleByMapSize1D(uint n)
 /**
  * An offset value between to tiles.
  *
- * This value is used fro the difference between
+ * This value is used for the difference between
  * to tiles. It can be added to a tileindex to get
  * the resulting tileindex of the start tile applied
  * with this saved difference.
diff --git a/src/misc_cmd.cpp b/src/misc_cmd.cpp
index 7f0dbc1..9c01eef 100644
--- a/src/misc_cmd.cpp
+++ b/src/misc_cmd.cpp
@@ -207,7 +207,7 @@ CommandCost CmdMoneyCheat(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 /**
  * Transfer funds (money) from one company to another.
  * To prevent abuse in multiplayer games you can only send money to other
- * companies if you have paid off your loan (either explicitely, or implicitely
+ * companies if you have paid off your loan (either explicitly, or implicitly
  * given the fact that you have more money than loan).
  * @param tile unused
  * @param flags operation to perform
diff --git a/src/misc_gui.cpp b/src/misc_gui.cpp
index 9c90b92..d5ed353 100644
--- a/src/misc_gui.cpp
+++ b/src/misc_gui.cpp
@@ -35,7 +35,7 @@ enum OskActivation {
 	OSKA_DISABLED,           ///< The OSK shall not be activated at all.
 	OSKA_DOUBLE_CLICK,       ///< Double click on the edit box opens OSK.
 	OSKA_SINGLE_CLICK,       ///< Single click after focus click opens OSK.
-	OSKA_IMMEDIATELY,        ///< Focussing click already opens OSK.
+	OSKA_IMMEDIATELY,        ///< Focusing click already opens OSK.
 };
 
 
@@ -704,7 +704,7 @@ struct TooltipsWindow : public Window
  * @param str String to be displayed
  * @param paramcount number of params to deal with
  * @param params (optional) up to 5 pieces of additional information that may be added to a tooltip
- * @param use_left_mouse_button close the tooltip when the left (true) or right (false) mousebutton is released
+ * @param use_left_mouse_button close the tooltip when the left (true) or right (false) mouse button is released
  */
 void GuiShowTooltips(Window *parent, StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_tooltip)
 {
diff --git a/src/news_gui.cpp b/src/news_gui.cpp
index 20693e6..2d10ec1 100644
--- a/src/news_gui.cpp
+++ b/src/news_gui.cpp
@@ -40,7 +40,7 @@
 const NewsItem *_statusbar_news_item = NULL;
 bool _news_ticker_sound; ///< Make a ticker sound when a news item is published.
 
-static uint MIN_NEWS_AMOUNT = 30;           ///< prefered minimum amount of news messages
+static uint MIN_NEWS_AMOUNT = 30;           ///< preferred minimum amount of news messages
 static uint _total_news = 0;                ///< current number of news items
 static NewsItem *_oldest_news = NULL;       ///< head of news items queue
 static NewsItem *_latest_news = NULL;       ///< tail of news items queue
@@ -964,7 +964,7 @@ static void DrawNewsString(uint left, uint right, int y, TextColour colour, cons
 	}
 
 	*dest = '\0';
-	/* Truncate and show string; postfixed by '...' if neccessary */
+	/* Truncate and show string; postfixed by '...' if necessary */
 	DrawString(left, right, y, buffer2, colour);
 }
 
@@ -972,7 +972,7 @@ struct MessageHistoryWindow : Window {
 	static const int top_spacing;    ///< Additional spacing at the top of the #WID_MH_BACKGROUND widget.
 	static const int bottom_spacing; ///< Additional spacing at the bottom of the #WID_MH_BACKGROUND widget.
 
-	int line_height; /// < Height of a single line in the news histoy window including spacing.
+	int line_height; /// < Height of a single line in the news history window including spacing.
 	int date_width;  /// < Width needed for the date part.
 
 	Scrollbar *vscroll;
diff --git a/src/object_gui.cpp b/src/object_gui.cpp
index 9217bb6..a5e065c 100644
--- a/src/object_gui.cpp
+++ b/src/object_gui.cpp
@@ -115,7 +115,7 @@ public:
 			}
 
 			case WID_BO_OBJECT_SPRITE: {
-				bool two_wide = false;  // Whether there will be two widgets next to eachother in the matrix or not.
+				bool two_wide = false;  // Whether there will be two widgets next to each other in the matrix or not.
 				int height[2] = {0, 0}; // The height for the different views; in this case views 1/2 and 4.
 
 				/* Get the height and view information. */
@@ -190,7 +190,7 @@ public:
 				/* Height of the selection matrix.
 				 * Depending on the number of views, the matrix has a 1x1, 1x2, 2x1 or 2x2 layout. To make the previews
 				 * look nice in all layouts, we use the 4x4 layout (smallest previews) as starting point. For the bigger
-				 * previews in the layouts with less views we add space homogenously on all sides, so the 4x4 preview-rectangle
+				 * previews in the layouts with less views we add space homogeneously on all sides, so the 4x4 preview-rectangle
 				 * is centered in the 2x1, 1x2 resp. 1x1 buttons. */
 				uint matrix_height = this->GetWidget<NWidgetMatrix>(WID_BO_OBJECT_MATRIX)->current_y;
 
diff --git a/src/object_map.h b/src/object_map.h
index 580fd69..d509389 100644
--- a/src/object_map.h
+++ b/src/object_map.h
@@ -125,7 +125,7 @@ static inline byte GetObjectRandomBits(TileIndex t)
  * @param u      The object type of the tile.
  * @param o      The new owner of the tile.
  * @param index  Index to the object.
- * @param wc     Water class for this obect.
+ * @param wc     Water class for this object.
  * @param random Random data to store on the tile
  */
 static inline void MakeObject(TileIndex t, ObjectType u, Owner o, ObjectID index, WaterClass wc, byte random)
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 1ec778d..be83d4e 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -1027,7 +1027,7 @@ void SwitchToMode(SwitchMode new_mode)
 		}
 	}
 #endif /* ENABLE_NETWORK */
-	/* Make sure all AI controllers are gone at quiting game */
+	/* Make sure all AI controllers are gone at quitting game */
 	if (new_mode != SM_SAVE_GAME) AI::KillAll();
 
 	switch (new_mode) {
@@ -1295,7 +1295,7 @@ static void CheckCaches()
  */
 void StateGameLoop()
 {
-	/* dont execute the state loop during pause */
+	/* don't execute the state loop during pause */
 	if (_pause_mode != PM_UNPAUSED) {
 		UpdateLandscapingLimits();
 		Game::GameLoop();
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index 0ce3059..f1b79d5 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -79,7 +79,7 @@ void Order::MakeGoToStation(StationID destination)
 /**
  * Makes this order a Go To Depot order.
  * @param destination   the depot to go to.
- * @param order         is this order a 'default' order, or an overriden vehicle order?
+ * @param order         is this order a 'default' order, or an overridden vehicle order?
  * @param non_stop_type how to get to the depot?
  * @param action        what to do in the depot?
  * @param cargo         the cargo type to change to.
@@ -1118,7 +1118,7 @@ CommandCost CmdMoveOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			 * predictable and transparent behaviour.
 			 *
 			 * With that decision it basically does not matter what we do to cur_implicit_order_index.
-			 * If we change orders between the implict- and real-index, the implicit orders are mostly likely
+			 * If we change orders between the implicit- and real-index, the implicit orders are mostly likely
 			 * completely out-dated anyway. So, keep it simple and just keep cur_implicit_order_index as well.
 			 * The worst which can happen is that a lot of implicit orders are removed when reaching current_order.
 			 */
@@ -1521,7 +1521,7 @@ CommandCost CmdCloneOrder(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32
 			if (ret.Failed()) return ret;
 
 			/* Trucks can't copy all the orders from busses (and visa versa),
-			 * and neither can helicopters and aircarft. */
+			 * and neither can helicopters and aircraft. */
 			const Order *order;
 			FOR_VEHICLE_ORDERS(src, order) {
 				if (OrderGoesToStation(dst, order) &&
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index 85bd196..2cbfd98 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -522,7 +522,7 @@ private:
 
 	/**
 	 * Return the memorised selected order.
-	 * @return the memorised order if it is a vaild one
+	 * @return the memorised order if it is a valid one
 	 *  else return the number of orders
 	 */
 	VehicleOrderID OrderGetSel() const
diff --git a/src/pbs.cpp b/src/pbs.cpp
index 01e7b2f..2e0919b 100644
--- a/src/pbs.cpp
+++ b/src/pbs.cpp
@@ -219,7 +219,7 @@ static PBSTileInfo FollowReservation(Owner o, RailTypes rts, TileIndex tile, Tra
 
 		if (first_loop) {
 			/* Update the start tile after we followed the track the first
-			 * time. This is neccessary because the track follower can skip
+			 * time. This is necessary because the track follower can skip
 			 * tiles (in stations for example) which means that we might
 			 * never visit our original starting tile again. */
 			start_tile = tile;
@@ -376,7 +376,7 @@ bool IsSafeWaitingPosition(const Train *v, TileIndex tile, Trackdir trackdir, bo
 		if (HasSignalOnTrackdir(tile, trackdir) && !IsPbsSignal(GetSignalType(tile, TrackdirToTrack(trackdir)))) return true;
 	}
 
-	/* Check next tile. For perfomance reasons, we check for 90 degree turns ourself. */
+	/* Check next tile. For performance reasons, we check for 90 degree turns ourself. */
 	CFollowTrackRail ft(v, GetRailTypeInfo(v->railtype)->compatible_railtypes);
 
 	/* End of track? */
diff --git a/src/rail.cpp b/src/rail.cpp
index fa0d86c..dd34cb6 100644
--- a/src/rail.cpp
+++ b/src/rail.cpp
@@ -216,7 +216,7 @@ RailType GetBestRailtype(const CompanyID company)
 /**
  * Add the rail types that are to be introduced at the given date.
  * @param current The currently available railtypes.
- * @param date    The date for the introduction comparisions.
+ * @param date    The date for the introduction comparisons.
  * @return The rail types that should be available when date
  *         introduced rail types are taken into account as well.
  */
diff --git a/src/rail.h b/src/rail.h
index 0a6a153..249c1be 100644
--- a/src/rail.h
+++ b/src/rail.h
@@ -76,7 +76,7 @@ enum RailTrackOffset {
 };
 
 /**
- * Offsets for spries within a bridge surface overlay set.
+ * Offsets for sprites within a bridge surface overlay set.
  */
 enum RailTrackBridgeOffset {
 	RTBO_X,     ///< Piece of rail in X direction
@@ -120,7 +120,7 @@ struct RailtypeInfo {
 		SpriteID single_s;     ///< single piece of rail in the southern corner
 		SpriteID single_e;     ///< single piece of rail in the eastern corner
 		SpriteID single_w;     ///< single piece of rail in the western corner
-		SpriteID single_sloped;///< single piecs of rail for slopes
+		SpriteID single_sloped;///< single piece of rail for slopes
 		SpriteID crossing;     ///< level crossing, rail in X direction
 		SpriteID tunnel;       ///< tunnel sprites base
 	} base_sprites;
diff --git a/src/rail_cmd.cpp b/src/rail_cmd.cpp
index 90fe364..1a07383 100644
--- a/src/rail_cmd.cpp
+++ b/src/rail_cmd.cpp
@@ -923,7 +923,7 @@ CommandCost CmdRemoveRailroadTrack(TileIndex tile, DoCommandFlag flags, uint32 p
  * @return the cost of this operation or an error
  *
  * @todo When checking for the tile slope,
- * distingush between "Flat land required" and "land sloped in wrong direction"
+ * distinguish between "Flat land required" and "land sloped in wrong direction"
  */
 CommandCost CmdBuildTrainDepot(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
@@ -1096,7 +1096,7 @@ CommandCost CmdBuildSingleSignal(TileIndex tile, DoCommandFlag flags, uint32 p1,
 				if (convert_signal) {
 					/* convert signal button pressed */
 					if (ctrl_pressed) {
-						/* toggle the pressent signal variant: SIG_ELECTRIC <-> SIG_SEMAPHORE */
+						/* toggle the present signal variant: SIG_ELECTRIC <-> SIG_SEMAPHORE */
 						SetSignalVariant(tile, track, (GetSignalVariant(tile, track) == SIG_ELECTRIC) ? SIG_SEMAPHORE : SIG_ELECTRIC);
 						/* Query current signal type so the check for PBS signals below works. */
 						sigtype = GetSignalType(tile, track);
@@ -1650,7 +1650,7 @@ CommandCost CmdConvertRail(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 				if (endtile < tile && TileX(endtile) >= TileX(ta.tile) && TileX(endtile) < TileX(ta.tile) + ta.w &&
 						TileY(endtile) >= TileY(ta.tile) && TileY(endtile) < TileY(ta.tile) + ta.h) continue;
 
-				/* When not coverting rail <-> el. rail, any vehicle cannot be in tunnel/bridge */
+				/* When not converting rail <-> el. rail, any vehicle cannot be in tunnel/bridge */
 				if (!IsCompatibleRail(GetRailType(tile), totype)) {
 					CommandCost ret = TunnelBridgeIsFree(tile, endtile);
 					if (ret.Failed()) {
@@ -2642,8 +2642,8 @@ static TrackStatus GetTileTrackStatus_Track(TileIndex tile, TransportType mode,
 			/* When signals are not present (in neither direction),
 			 * we pretend them to be green. Otherwise, it depends on
 			 * the signal type. For signals that are only active from
-			 * one side, we set the missing signals explicitely to
-			 * `green'. Otherwise, they implicitely become `red'. */
+			 * one side, we set the missing signals explicitly to
+			 * `green'. Otherwise, they implicitly become `red'. */
 			if (!IsOnewaySignal(tile, TRACK_UPPER) || (a & SignalOnTrack(TRACK_UPPER)) == 0) b |= ~a & SignalOnTrack(TRACK_UPPER);
 			if (!IsOnewaySignal(tile, TRACK_LOWER) || (a & SignalOnTrack(TRACK_LOWER)) == 0) b |= ~a & SignalOnTrack(TRACK_LOWER);
 
diff --git a/src/rail_gui.cpp b/src/rail_gui.cpp
index 73d1a26..705e1c4 100644
--- a/src/rail_gui.cpp
+++ b/src/rail_gui.cpp
@@ -294,7 +294,7 @@ static void ToggleRailButton_Remove(Window *w)
 /**
  * Updates the Remove button because of Ctrl state change
  * @param w window the button belongs to
- * @return true iff the remove buton was changed
+ * @return true iff the remove button was changed
  */
 static bool RailToolbar_CtrlChanged(Window *w)
 {
diff --git a/src/rev.cpp.in b/src/rev.cpp.in
index ce21fc5..a50ba79 100644
--- a/src/rev.cpp.in
+++ b/src/rev.cpp.in
@@ -49,7 +49,7 @@ const char _openttd_build_date[] = __DATE__ " " __TIME__;
 
 /**
  * Let us know if current build was modified. This detection
- * works even in the case when revision string is overriden by
+ * works even in the case when revision string is overridden by
  * --revision argument.
  * Value 0 means no modification, 1 is for unknown state
  * (compiling from sources without any version control software)
@@ -68,7 +68,7 @@ const byte _openttd_revision_modified = !!MODIFIED!!;
  *
  * The 19th bit is there so the development/betas/alpha, etc. leading to a
  * final release will always have a lower version number than the released
- * version, thus making comparisions on specific revisions easy.
+ * version, thus making comparisons on specific revisions easy.
  */
 const uint32 _openttd_newgrf_version = 1 << 28 | 3 << 24 | 0 << 20 | 0 << 19 | (!!REVISION!! & ((1 << 19) - 1));
 
diff --git a/src/rev.h b/src/rev.h
index 50b2654..d31dbb5 100644
--- a/src/rev.h
+++ b/src/rev.h
@@ -7,7 +7,7 @@
  * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
  */
 
-/** @file rev.h declaration of OTTD revision dependant variables */
+/** @file rev.h declaration of OTTD revision dependent variables */
 
 #ifndef REV_H
 #define REV_H
diff --git a/src/road.cpp b/src/road.cpp
index fad4cbc..c005d56 100644
--- a/src/road.cpp
+++ b/src/road.cpp
@@ -23,7 +23,7 @@
 /**
  * Return if the tile is a valid tile for a crossing.
  *
- * @param tile the curent tile
+ * @param tile the current tile
  * @param ax the axis of the road over the rail
  * @return true if it is a valid tile
  */
@@ -36,7 +36,7 @@ static bool IsPossibleCrossing(const TileIndex tile, Axis ax)
 }
 
 /**
- * Clean up unneccesary RoadBits of a planed tile.
+ * Clean up unnecessary RoadBits of a planed tile.
  * @param tile current tile
  * @param org_rb planed RoadBits
  * @return optimised RoadBits
@@ -56,7 +56,7 @@ RoadBits CleanUpRoadBits(const TileIndex tile, RoadBits org_rb)
 			const RoadBits mirrored_rb = MirrorRoadBits(target_rb);
 
 			switch (GetTileType(neighbor_tile)) {
-				/* Allways connective ones */
+				/* Always connective ones */
 				case MP_CLEAR: case MP_TREES:
 					connective = true;
 					break;
@@ -83,11 +83,11 @@ RoadBits CleanUpRoadBits(const TileIndex tile, RoadBits org_rb)
 					connective = !IsWater(neighbor_tile);
 					break;
 
-				/* The defentetly not connective ones */
+				/* The definitely not connective ones */
 				default: break;
 			}
 
-			/* If the neighbor tile is inconnective remove the planed road connection to it */
+			/* If the neighbor tile is inconnective, remove the planed road connection to it */
 			if (!connective) org_rb ^= target_rb;
 
 		}
diff --git a/src/road_cmd.cpp b/src/road_cmd.cpp
index ad7579a..dfc1087 100644
--- a/src/road_cmd.cpp
+++ b/src/road_cmd.cpp
@@ -993,7 +993,7 @@ CommandCost CmdRemoveLongRoad(TileIndex start_tile, DoCommandFlag flags, uint32
  * @return the cost of this operation or an error
  *
  * @todo When checking for the tile slope,
- * distingush between "Flat land required" and "land sloped in wrong direction"
+ * distinguish between "Flat land required" and "land sloped in wrong direction"
  */
 CommandCost CmdBuildRoadDepot(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
 {
diff --git a/src/road_func.h b/src/road_func.h
index 27622f4..bfe2619 100644
--- a/src/road_func.h
+++ b/src/road_func.h
@@ -92,7 +92,7 @@ static inline RoadBits MirrorRoadBits(RoadBits r)
 /**
  * Calculate rotated RoadBits
  *
- * Move the Roadbits clockwise til they are in their final position.
+ * Move the Roadbits clockwise until they are in their final position.
  *
  * @param r The given RoadBits value
  * @param rot The given Rotation angle
diff --git a/src/road_gui.cpp b/src/road_gui.cpp
index 3b23e9c..57bf98f 100644
--- a/src/road_gui.cpp
+++ b/src/road_gui.cpp
@@ -273,7 +273,7 @@ static void PlaceRoad_TruckStation(TileIndex tile)
 typedef void OnButtonClick(Window *w);
 
 /**
- * Toogles state of the Remove button of Build road toolbar
+ * Toggles state of the Remove button of Build road toolbar
  * @param w window the button belongs to
  */
 static void ToggleRoadButton_Remove(Window *w)
@@ -287,7 +287,7 @@ static void ToggleRoadButton_Remove(Window *w)
 /**
  * Updates the Remove button because of Ctrl state change
  * @param w window the button belongs to
- * @return true iff the remove buton was changed
+ * @return true iff the remove button was changed
  */
 static bool RoadToolbar_CtrlChanged(Window *w)
 {
@@ -350,7 +350,7 @@ struct BuildRoadToolbarWindow : Window {
 	void UpdateOptionWidgetStatus(RoadToolbarWidgets clicked_widget)
 	{
 		/* The remove and the one way button state is driven
-		 * by the other buttons so they don't act on themselfs.
+		 * by the other buttons so they don't act on themselves.
 		 * Both are only valid if they are able to apply as options. */
 		switch (clicked_widget) {
 			case WID_ROT_REMOVE:
diff --git a/src/roadstop.cpp b/src/roadstop.cpp
index b5840dd..193e915 100644
--- a/src/roadstop.cpp
+++ b/src/roadstop.cpp
@@ -65,7 +65,7 @@ void RoadStop::MakeDriveThrough()
 
 	RoadStopType rst = GetRoadStopType(this->xy);
 	DiagDirection dir = GetRoadStopDir(this->xy);
-	/* Use absolute so we always go towards the nortern tile */
+	/* Use absolute so we always go towards the northern tile */
 	TileIndexDiff offset = abs(TileOffsByDiagDir(dir));
 
 	/* Information about the tile north of us */
@@ -81,7 +81,7 @@ void RoadStop::MakeDriveThrough()
 	/* Amount of road stops that will be added to the 'northern' head */
 	int added = 1;
 	if (north && rs_north->east != NULL) { // (east != NULL) == (west != NULL)
-		/* There is a more nothern one, so this can join them */
+		/* There is a more northern one, so this can join them */
 		this->east = rs_north->east;
 		this->west = rs_north->west;
 
@@ -133,7 +133,7 @@ void RoadStop::ClearDriveThrough()
 
 	RoadStopType rst = GetRoadStopType(this->xy);
 	DiagDirection dir = GetRoadStopDir(this->xy);
-	/* Use absolute so we always go towards the nortern tile */
+	/* Use absolute so we always go towards the northern tile */
 	TileIndexDiff offset = abs(TileOffsByDiagDir(dir));
 
 	/* Information about the tile north of us */
@@ -178,7 +178,7 @@ void RoadStop::ClearDriveThrough()
 			/* We have to rebuild the entries because we cannot easily determine
 			 * how full each part is. So instead of keeping and maintaining a list
 			 * of vehicles and using that to 'rebuild' the occupied state we just
-			 * rebuild it from scratch as that removes lots of maintainance code
+			 * rebuild it from scratch as that removes lots of maintenance code
 			 * for the vehicle list and it's faster in real games as long as you
 			 * do not keep split and merge road stop every tick by the millions. */
 			rs_south_base->east->Rebuild(rs_south_base);
@@ -243,7 +243,7 @@ bool RoadStop::Enter(RoadVehicle *rv)
 		uint bay_nr = this->AllocateBay();
 		SB(rv->state, RVS_USING_SECOND_BAY, 1, bay_nr);
 
-		/* Mark the station entrace as busy */
+		/* Mark the station entrance as busy */
 		this->SetEntranceBusy(true);
 		return true;
 	}
@@ -290,7 +290,7 @@ void RoadStop::Entry::Leave(const RoadVehicle *rv)
 void RoadStop::Entry::Enter(const RoadVehicle *rv)
 {
 	/* we cannot assert on this->occupied < this->length because of the
-	 * remote possibility that RVs are running through eachother when
+	 * remote possibility that RVs are running through each other when
 	 * trying to prevention an infinite jam. */
 	this->occupied += rv->gcache.cached_total_length;
 }
diff --git a/src/screenshot.cpp b/src/screenshot.cpp
index c642c03..9c750ff 100644
--- a/src/screenshot.cpp
+++ b/src/screenshot.cpp
@@ -844,7 +844,7 @@ bool MakeHeightmapScreenshot(const char *filename)
  * Make an actual screenshot.
  * @param t    the type of screenshot to make.
  * @param name the name to give to the screenshot.
- * @return true iff the screenshow was made successfully
+ * @return true iff the screenshot was made successfully
  */
 bool MakeScreenshot(ScreenshotType t, const char *name)
 {
diff --git a/src/settings.cpp b/src/settings.cpp
index e9f190e..09582d2 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -98,7 +98,7 @@ static const char * const _list_group_names[] = {
 };
 
 /**
- * Find the index value of a ONEofMANY type in a string seperated by |
+ * Find the index value of a ONEofMANY type in a string separated by |
  * @param many full domain of values the ONEofMANY setting can have
  * @param one the current value of the setting for which a value needs found
  * @param onelen force calculation of the *one parameter
@@ -130,7 +130,7 @@ static size_t LookupOneOfMany(const char *many, const char *one, size_t onelen =
  * Find the set-integer value MANYofMANY type in a string
  * @param many full domain of values the MANYofMANY setting can have
  * @param str the current string value of the setting, each individual
- * of seperated by a whitespace,tab or | character
+ * of separated by a whitespace,tab or | character
  * @return the 'fully' set integer, or -1 if a set is not found
  */
 static size_t LookupManyOfMany(const char *many, const char *str)
@@ -159,7 +159,7 @@ static size_t LookupManyOfMany(const char *many, const char *str)
 
 /**
  * Parse an integerlist string and set each found value
- * @param p the string to be parsed. Each element in the list is seperated by a
+ * @param p the string to be parsed. Each element in the list is separated by a
  * comma or a space character
  * @param items pointer to the integerlist-array that will be filled with values
  * @param maxitems the maximum number of elements the integerlist-array has
@@ -248,7 +248,7 @@ static bool LoadIntList(const char *str, void *array, int nelems, VarType type)
 
 /**
  * Convert an integer-array (intlist) to a string representation. Each value
- * is seperated by a comma or a space character
+ * is separated by a comma or a space character
  * @param buf output buffer where the string-representation will be stored
  * @param last last item to write to in the output buffer
  * @param array pointer to the integer-arrays that is read from
@@ -1292,7 +1292,7 @@ static void NewsDisplayLoadConfig(IniFile *ini, const char *grpname)
 			}
 		}
 
-		/* the config been read is not within current aceptable config */
+		/* the config been read is not within current acceptable config */
 		if (news_item == -1) {
 			/* if the conversion function cannot process it, advice by a debug warning*/
 			if (!ConvertOldNewsSetting(item->name, item->value)) {
@@ -1585,7 +1585,7 @@ static IniFile *IniLoadConfig()
 void LoadFromConfig(bool minimal)
 {
 	IniFile *ini = IniLoadConfig();
-	if (!minimal) ResetCurrencies(false); // Initialize the array of curencies, without preserving the custom one
+	if (!minimal) ResetCurrencies(false); // Initialize the array of currencies, without preserving the custom one
 
 	/* Load basic settings only during bootstrap, load other settings not during bootstrap */
 	HandleSettingDescs(ini, IniLoadSettings, IniLoadSettingList, minimal, !minimal);
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 7a9d791..37fd2e8 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -912,7 +912,7 @@ void SettingEntry::GetFoldingState(bool &all_folded, bool &all_unfolded) const
 
 /**
  * Check whether an entry is visible and not folded or filtered away.
- * Note: This does not consider the scrolling range; it might still require scrolling ot make the setting really visible.
+ * Note: This does not consider the scrolling range; it might still require scrolling to make the setting really visible.
  * @param item Entry to search for.
  * @return true if entry is visible.
  */
@@ -1390,7 +1390,7 @@ uint SettingsPage::GetMaxHelpHeight(int maxw)
 /**
  * Draw a selected part of the settings page.
  *
- * The scrollbar uses rows of the page, while the page data strucure is a tree of #SettingsPage and #SettingEntry objects.
+ * The scrollbar uses rows of the page, while the page data structure is a tree of #SettingsPage and #SettingEntry objects.
  * As a result, the drawing routing traverses the tree from top to bottom, counting rows in \a cur_row until it reaches \a first_row.
  * Then it enables drawing rows while traversing until \a max_row is reached, at which point drawing is terminated.
  *
@@ -2421,7 +2421,7 @@ struct CustomCurrencyWindow : Window {
 				_custom_currency.rate = Clamp(atoi(str), 1, UINT16_MAX);
 				break;
 
-			case WID_CC_SEPARATOR: // Thousands seperator
+			case WID_CC_SEPARATOR: // Thousands separator
 				strecpy(_custom_currency.separator, str, lastof(_custom_currency.separator));
 				break;
 
diff --git a/src/settings_internal.h b/src/settings_internal.h
index 9bda96f..567c033 100644
--- a/src/settings_internal.h
+++ b/src/settings_internal.h
@@ -27,7 +27,7 @@ enum SettingDescTypeLong {
 	SDT_BOOLX       = 1, ///< a boolean number
 	SDT_ONEOFMANY   = 2, ///< bitmasked number where only ONE bit may be set
 	SDT_MANYOFMANY  = 3, ///< bitmasked number where MULTIPLE bits may be set
-	SDT_INTLIST     = 4, ///< list of integers seperated by a comma ','
+	SDT_INTLIST     = 4, ///< list of integers separated by a comma ','
 	SDT_STRING      = 5, ///< string with a pre-allocated buffer
 	SDT_END,
 	/* 10 more possible primitives */
@@ -78,7 +78,7 @@ enum SettingCategory {
 
 
 typedef bool OnChange(int32 var);           ///< callback prototype on data modification
-typedef size_t OnConvert(const char *value); ///< callback prototype for convertion error
+typedef size_t OnConvert(const char *value); ///< callback prototype for conversion error
 
 /** Properties of config file settings. */
 struct SettingDescBase {
diff --git a/src/settings_type.h b/src/settings_type.h
index b182191..b50158b 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -393,7 +393,7 @@ struct OrderSettings {
 	bool   improved_load;                    ///< improved loading algorithm
 	bool   gradual_loading;                  ///< load vehicles gradually
 	bool   selectgoods;                      ///< only send the goods to station if a train has been there
-	bool   no_servicing_if_no_breakdowns;    ///< dont send vehicles to depot when breakdowns are disabled
+	bool   no_servicing_if_no_breakdowns;    ///< don't send vehicles to depot when breakdowns are disabled
 	bool   serviceathelipad;                 ///< service helicopters at helipads automatically (no need to send to depot)
 };
 
@@ -432,7 +432,7 @@ struct EconomySettings {
 	bool   fund_buildings;                   ///< allow funding new buildings
 	bool   fund_roads;                       ///< allow funding local road reconstruction
 	bool   give_money;                       ///< allow giving other companies money
-	bool   mod_road_rebuild;                 ///< roadworks remove unneccesary RoadBits
+	bool   mod_road_rebuild;                 ///< roadworks remove unnecessary RoadBits
 	bool   multiple_industry_per_town;       ///< allow many industries of the same type per town
 	uint8  town_growth_rate;                 ///< town growth rate
 	uint8  larger_towns;                     ///< the number of cities to build. These start off larger and grow twice as fast
diff --git a/src/ship_cmd.cpp b/src/ship_cmd.cpp
index 9bf97fb..6dd0c01 100644
--- a/src/ship_cmd.cpp
+++ b/src/ship_cmd.cpp
@@ -370,7 +370,7 @@ static bool ShipAccelerate(Vehicle *v)
 		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
 	}
 
-	/* Convert direction-indepenent speed into direction-dependent speed. (old movement method) */
+	/* Convert direction-independent speed into direction-dependent speed. (old movement method) */
 	spd = v->GetOldAdvanceSpeed(spd);
 
 	if (spd == 0) return false;
diff --git a/src/signal.cpp b/src/signal.cpp
index d991d62..2d16e9a 100644
--- a/src/signal.cpp
+++ b/src/signal.cpp
@@ -52,7 +52,7 @@ template <typename Tdir, uint items>
 struct SmallSet {
 private:
 	uint n;           // actual number of units
-	bool overflowed;  // did we try to oveflow the set?
+	bool overflowed;  // did we try to overflow the set?
 	const char *name; // name, used for debugging purposes...
 
 	/** Element of set */
@@ -73,7 +73,7 @@ public:
 	}
 
 	/**
-	 * Returns value of 'oveflowed'
+	 * Returns value of 'overflowed'
 	 * @return did we try to overflow the set?
 	 */
 	bool Overflowed()
@@ -131,7 +131,7 @@ public:
 	 * Tries to find given tile and dir in the set
 	 * @param tile tile
 	 * @param dir and dir to find
-	 * @return true iff the tile & dir elemnt was found
+	 * @return true iff the tile & dir element was found
 	 */
 	bool IsIn(TileIndex tile, Tdir dir)
 	{
@@ -201,7 +201,7 @@ static Vehicle *TrainOnTileEnum(Vehicle *v, void *)
  * The new and reverse direction is removed from _globset, because we are sure
  * it doesn't need to be checked again
  * Also, remove reverse direction from _tbdset
- * This is the 'core' part so the graph seaching won't enter any tile twice
+ * This is the 'core' part so the graph searching won't enter any tile twice
  *
  * @param t1 tile we are entering
  * @param d1 direction (tile side) we are entering
@@ -227,7 +227,7 @@ static inline bool CheckAddToTodoSet(TileIndex t1, DiagDirection d1, TileIndex t
  * The new and reverse direction is removed from Global set, because we are sure
  * it doesn't need to be checked again
  * Also, remove reverse direction from Todo set
- * This is the 'core' part so the graph seaching won't enter any tile twice
+ * This is the 'core' part so the graph searching won't enter any tile twice
  *
  * @param t1 tile we are entering
  * @param d1 direction (tile side) we are entering
diff --git a/src/signs_gui.cpp b/src/signs_gui.cpp
index 120906a..357fcaf 100644
--- a/src/signs_gui.cpp
+++ b/src/signs_gui.cpp
@@ -429,7 +429,7 @@ struct SignWindow : Window, SignList {
 
 	void UpdateSignEditWindow(const Sign *si)
 	{
-		/* Display an empty string when the sign hasnt been edited yet */
+		/* Display an empty string when the sign hasn't been edited yet */
 		if (si->name != NULL) {
 			SetDParam(0, si->index);
 			this->name_editbox.text.Assign(STR_SIGN_NAME);
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 2bd4422..90a4e42 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -151,7 +151,7 @@ static LegendAndColour _legend_land_owners[NUM_NO_COMPANY_ENTRIES + MAX_COMPANIE
 
 /**
  * Allow room for all industries, plus a terminator entry
- * This is required in order to have the indutry slots all filled up
+ * This is required in order to have the industry slots all filled up
  */
 static LegendAndColour _legend_from_industries[NUM_INDUSTRYTYPES + 1];
 /** For connecting industry type to position in industries list(small map legend) */
@@ -1593,8 +1593,8 @@ bool SmallMapWindow::show_towns = true;
  * Custom container class for displaying smallmap with a vertically resizing legend panel.
  * The legend panel has a smallest height that depends on its width. Standard containers cannot handle this case.
  *
- * @note The container assumes it has two childs, the first is the display, the second is the bar with legends and selection image buttons.
- *       Both childs should be both horizontally and vertically resizable and horizontally fillable.
+ * @note The container assumes it has two children, the first is the display, the second is the bar with legends and selection image buttons.
+ *       Both children should be both horizontally and vertically resizable and horizontally fillable.
  *       The bar should have a minimal size with a zero-size legends display. Child padding is not supported.
  */
 class NWidgetSmallmapDisplay : public NWidgetContainer {
diff --git a/src/sortlist_type.h b/src/sortlist_type.h
index 5e6ac11..1a30c3b 100644
--- a/src/sortlist_type.h
+++ b/src/sortlist_type.h
@@ -30,7 +30,7 @@ enum SortListFlags {
 };
 DECLARE_ENUM_AS_BIT_SET(SortListFlags)
 
-/** Data structure describing how to show the list (what sort direction and criterium). */
+/** Data structure describing how to show the list (what sort direction and criteria). */
 struct Listing {
 	bool order;    ///< Ascending/descending
 	byte criteria; ///< Sorting criteria
@@ -232,7 +232,7 @@ public:
 	}
 
 	/**
-	 * Toogle the sort order
+	 * Toggle the sort order
 	 *  Since that is the worst condition for the sort function
 	 *  reverse the list here.
 	 */
diff --git a/src/sound.cpp b/src/sound.cpp
index 4c72778..9bad9d6 100644
--- a/src/sound.cpp
+++ b/src/sound.cpp
@@ -306,7 +306,7 @@ template <class Tbase_set>
 
 	const Tbase_set *best = NULL;
 	for (const Tbase_set *c = BaseMedia<Tbase_set>::available_sets; c != NULL; c = c->next) {
-		/* Skip unuseable sets */
+		/* Skip unusable sets */
 		if (c->GetNumMissing() != 0) continue;
 
 		if (best == NULL ||
diff --git a/src/sprite.cpp b/src/sprite.cpp
index acf0dca..513ca01 100644
--- a/src/sprite.cpp
+++ b/src/sprite.cpp
@@ -21,7 +21,7 @@
  * Draws a tile sprite sequence.
  * @param ti The tile to draw on
  * @param dts Sprite and subsprites to draw
- * @param to The transparancy bit that toggles drawing of these sprites
+ * @param to The transparency bit that toggles drawing of these sprites
  * @param orig_offset Sprite-Offset for original sprites
  * @param newgrf_offset Sprite-Offset for NewGRF defined sprites
  * @param default_palette The default recolour sprite to use (typically company colour)
diff --git a/src/spritecache.cpp b/src/spritecache.cpp
index 202f2f0..61313ed 100644
--- a/src/spritecache.cpp
+++ b/src/spritecache.cpp
@@ -414,7 +414,7 @@ static void *ReadSprite(const SpriteCache *sc, SpriteID id, SpriteType sprite_ty
 		 *  extract the data directly and store that as sprite.
 		 * Ugly: yes. Other solution: no. Blame the original author or
 		 *  something ;) The image should really have been a data-stream
-		 *  (so type = 0xFF basicly). */
+		 *  (so type = 0xFF basically). */
 		uint num = sprite[ZOOM_LVL_NORMAL].width * sprite[ZOOM_LVL_NORMAL].height;
 
 		Sprite *s = (Sprite *)allocator(sizeof(*s) + num);
diff --git a/src/station.cpp b/src/station.cpp
index 94f49fd..43b6594 100644
--- a/src/station.cpp
+++ b/src/station.cpp
@@ -376,7 +376,7 @@ void StationRect::MakeEmpty()
  * @note x and y are in Tile coordinates
  * @param x X coordinate
  * @param y Y coordinate
- * @param distance The maxmium distance a point may have (L1 norm)
+ * @param distance The maximum distance a point may have (L1 norm)
  * @return true if the point is within distance tiles of the station rectangle
  */
 bool StationRect::PtInExtendedRect(int x, int y, int distance) const
diff --git a/src/station_cmd.cpp b/src/station_cmd.cpp
index 94d03b3..23ffe2f 100644
--- a/src/station_cmd.cpp
+++ b/src/station_cmd.cpp
@@ -594,7 +594,7 @@ void UpdateStationAcceptance(Station *st, bool show_msg)
 		uint num_acc = 0;
 		uint num_rej = 0;
 
-		/* Test each cargo type to see if its acceptange has changed */
+		/* Test each cargo type to see if its acceptance has changed */
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			if (HasBit(new_acc, i)) {
 				if (!HasBit(old_acc, i) && num_acc < lengthof(accepts)) {
@@ -692,7 +692,7 @@ CommandCost ClearTile_Station(TileIndex tile, DoCommandFlag flags);
  * @param invalid_dirs Prohibited directions for slopes (set of #DiagDirection).
  * @param allowed_z Height allowed for the tile. If allowed_z is negative, it will be set to the height of this tile.
  * @param allow_steep Whether steep slopes are allowed.
- * @param check_bridge Check for the existance of a bridge.
+ * @param check_bridge Check for the existence of a bridge.
  * @return The cost in case of success, or an error code if it failed.
  */
 CommandCost CheckBuildableTile(TileIndex tile, uint invalid_dirs, int &allowed_z, bool allow_steep, bool check_bridge = true)
@@ -3075,7 +3075,7 @@ static VehicleEnterTileStatus VehicleEnter_Station(Vehicle *v, TileIndex tile, i
 		/* Stop whenever that amount of station ahead + the distance from the
 		 * begin of the platform to the stop location is longer than the length
 		 * of the platform. Station ahead 'includes' the current tile where the
-		 * vehicle is on, so we need to substract that. */
+		 * vehicle is on, so we need to subtract that. */
 		if (!IsInsideBS(stop + station_ahead, station_length, TILE_SIZE)) return VETSB_CONTINUE;
 
 		DiagDirection dir = DirToDiagDir(v->direction);
@@ -3268,7 +3268,7 @@ static void UpdateStationRating(Station *st)
 
 				/* At some point we really must cap the cargo. Previously this
 				 * was a strict 4095, but now we'll have a less strict, but
-				 * increasingly agressive truncation of the amount of cargo. */
+				 * increasingly aggressive truncation of the amount of cargo. */
 				static const uint WAITING_CARGO_THRESHOLD  = 1 << 12;
 				static const uint WAITING_CARGO_CUT_FACTOR = 1 <<  6;
 				static const uint MAX_WAITING_CARGO        = 1 << 15;
diff --git a/src/statusbar_gui.h b/src/statusbar_gui.h
index 7852c78..b55a88c 100644
--- a/src/statusbar_gui.h
+++ b/src/statusbar_gui.h
@@ -16,7 +16,7 @@
 enum StatusBarInvalidate {
 	SBI_SAVELOAD_START,  ///< started saving
 	SBI_SAVELOAD_FINISH, ///< finished saving
-	SBI_SHOW_TICKER,     ///< start scolling news
+	SBI_SHOW_TICKER,     ///< start scrolling news
 	SBI_SHOW_REMINDER,   ///< show a reminder (dot on the right side of the statusbar)
 	SBI_NEWS_DELETED,    ///< abort current news display (active news were deleted)
 	SBI_END
diff --git a/src/string.cpp b/src/string.cpp
index 4f7865a..3d0073d 100644
--- a/src/string.cpp
+++ b/src/string.cpp
@@ -250,7 +250,7 @@ void str_validate(char *str, const char *last, StringValidationSettings settings
 			if ((settings & SVS_REPLACE_WITH_QUESTION_MARK) != 0) *dst++ = '?';
 
 			/* In case of these two special cases assume that they really
-			 * mean SETX/SETXY and also "eat" the paramater. If this was
+			 * mean SETX/SETXY and also "eat" the parameter. If this was
 			 * not the case the string was broken to begin with and this
 			 * would not break much more. */
 			if (c == SCC_SETX) {
@@ -413,7 +413,7 @@ int CDECL vsnprintf(char *str, size_t size, const char *format, va_list ap)
 		}
 	} else if ((size_t)ret < size) {
 		/* The buffer is big enough for the number of
-		 * characers stored (excluding null), i.e.
+		 * characters stored (excluding null), i.e.
 		 * the string has been null-terminated. */
 		return ret;
 	}
diff --git a/src/string_func.h b/src/string_func.h
index 070695fd..0760c38 100644
--- a/src/string_func.h
+++ b/src/string_func.h
@@ -49,7 +49,7 @@ bool StrValid(const char *str, const char *last);
 /**
  * Check if a string buffer is empty.
  *
- * @param s The pointer to the firste element of the buffer
+ * @param s The pointer to the first element of the buffer
  * @return true if the buffer starts with the terminating null-character or
  *         if the given pointer points to NULL else return false
  */
@@ -61,7 +61,7 @@ static inline bool StrEmpty(const char *s)
 /**
  * Get the length of a string, within a limited buffer.
  *
- * @param str The pointer to the firste element of the buffer
+ * @param str The pointer to the first element of the buffer
  * @param maxlen The maximum size of the buffer
  * @return The length of the string
  */
diff --git a/src/strings.cpp b/src/strings.cpp
index a8a7cc6..5d1cf3d 100644
--- a/src/strings.cpp
+++ b/src/strings.cpp
@@ -95,7 +95,7 @@ void StringParameters::ShiftParameters(uint amount)
  * @param n Index of the string parameter.
  * @param max_value The biggest value which shall be displayed.
  *                  For the result only the number of digits of \a max_value matter.
- * @param min_count Minimum number of digits indepentent of \a max.
+ * @param min_count Minimum number of digits independent of \a max.
  */
 void SetDParamMaxValue(uint n, uint64 max_value, uint min_count)
 {
@@ -203,7 +203,7 @@ const char *GetStringPtr(StringID string)
  * @param buffr  Pointer to a string buffer where the formatted string should be written to.
  * @param string
  * @param args   Arguments for the string.
- * @param last   Pointer just past the end of buffr.
+ * @param last   Pointer just past the end of \a buffr.
  * @param case_index  The "case index". This will only be set when FormatString wants to print the string in a different case.
  * @param game_script The string is coming directly from a game script.
  * @return       Pointer to the final zero byte of the formatted string.
@@ -556,7 +556,7 @@ static int DeterminePluralForm(int64 count, int plural_form)
 		case 5:
 			return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
 
-		/* Three forms: special cases for numbers ending in 1 except wehn ending in 11, and 2 to 4 except when ending in 12 to 14.
+		/* Three forms: special cases for numbers ending in 1 except when ending in 11, and 2 to 4 except when ending in 12 to 14.
 		 * Used in:
 		 *   Croatian, Russian, Ukrainian */
 		case 6:
@@ -2129,7 +2129,7 @@ void CheckForMissingGlyphs(bool base_font, MissingGlyphSearcher *searcher)
 	if (bad_font) {
 		/* All attempts have failed. Display an error. As we do not want the string to be translated by
 		 * the translators, we 'force' it into the binary and 'load' it via a BindCString. To do this
-		 * properly we have to set the colour of the string, otherwise we end up with a lot of artefacts.
+		 * properly we have to set the colour of the string, otherwise we end up with a lot of artifacts.
 		 * The colour 'character' might change in the future, so for safety we just Utf8 Encode it into
 		 * the string, which takes exactly three characters, so it replaces the "XXX" with the colour marker. */
 		static char *err_str = strdup("XXXThe current font is missing some of the characters used in the texts for this language. Read the readme to see how to solve this.");
@@ -2153,7 +2153,7 @@ void CheckForMissingGlyphs(bool base_font, MissingGlyphSearcher *searcher)
 	 * be translated by the translators, we 'force' it into the
 	 * binary and 'load' it via a BindCString. To do this
 	 * properly we have to set the colour of the string,
-	 * otherwise we end up with a lot of artefacts. The colour
+	 * otherwise we end up with a lot of artifacts. The colour
 	 * 'character' might change in the future, so for safety
 	 * we just Utf8 Encode it into the string, which takes
 	 * exactly three characters, so it replaces the "XXX" with
diff --git a/src/subsidy.cpp b/src/subsidy.cpp
index 356d8ab..c69b2b2 100644
--- a/src/subsidy.cpp
+++ b/src/subsidy.cpp
@@ -242,7 +242,7 @@ void CreateSubsidy(CargoID cid, SourceType src_type, SourceID src, SourceType ds
  * - p1 = (bit 24 - 31) - CargoID of subsidy.
  * @param p2 various bitstuffed elements
  * - p2 = (bit  0 -  7) - SourceType of destination.
- * - p2 = (bit  8 - 23) - SourceID of destionation.
+ * - p2 = (bit  8 - 23) - SourceID of destination.
  * @param text unused.
  * @return the cost of this operation or an error
  */
diff --git a/src/subsidy_gui.cpp b/src/subsidy_gui.cpp
index 138ea45..80f9adb 100644
--- a/src/subsidy_gui.cpp
+++ b/src/subsidy_gui.cpp
@@ -154,7 +154,7 @@ struct SubsidyListWindow : Window {
 		int pos = -this->vscroll->GetPosition();
 		const int cap = this->vscroll->GetCapacity();
 
-		/* Section for drawing the offered subisidies */
+		/* Section for drawing the offered subsidies */
 		if (IsInsideMM(pos, 0, cap)) DrawString(x, right, y + pos * FONT_HEIGHT_NORMAL, STR_SUBSIDIES_OFFERED_TITLE);
 		pos++;
 
@@ -178,7 +178,7 @@ struct SubsidyListWindow : Window {
 			pos++;
 		}
 
-		/* Section for drawing the already granted subisidies */
+		/* Section for drawing the already granted subsidies */
 		pos++;
 		if (IsInsideMM(pos, 0, cap)) DrawString(x, right, y + pos * FONT_HEIGHT_NORMAL, STR_SUBSIDIES_SUBSIDISED_TITLE);
 		pos++;
diff --git a/src/terraform_cmd.cpp b/src/terraform_cmd.cpp
index 0957261..8c0c63a 100644
--- a/src/terraform_cmd.cpp
+++ b/src/terraform_cmd.cpp
@@ -23,14 +23,14 @@
 
 /*
  * In one terraforming command all four corners of a initial tile can be raised/lowered (though this is not available to the player).
- * The maximal amount of height modifications is archieved when raising a complete flat land from sea level to MAX_TILE_HEIGHT or vice versa.
+ * The maximal amount of height modifications is achieved when raising a complete flat land from sea level to MAX_TILE_HEIGHT or vice versa.
  * This affects all corners with a manhatten distance smaller than MAX_TILE_HEIGHT to one of the initial 4 corners.
  * Their maximal amount is computed to 4 * \sum_{i=1}^{h_max} i  =  2 * h_max * (h_max + 1).
  */
 static const int TERRAFORMER_MODHEIGHT_SIZE = 2 * MAX_TILE_HEIGHT * (MAX_TILE_HEIGHT + 1);
 
 /*
- * The maximal amount of affected tiles (i.e. the tiles that incident with one of the corners above, is computed similiar to
+ * The maximal amount of affected tiles (i.e. the tiles that incident with one of the corners above, is computed similar to
  * 1 + 4 * \sum_{i=1}^{h_max} (i+1)  =  1 + 2 * h_max + (h_max + 3).
  */
 static const int TERRAFORMER_TILE_TABLE_SIZE = 1 + 2 * MAX_TILE_HEIGHT * (MAX_TILE_HEIGHT + 3);
diff --git a/src/textbuf.cpp b/src/textbuf.cpp
index fe32712..9b9eb2d 100644
--- a/src/textbuf.cpp
+++ b/src/textbuf.cpp
@@ -21,10 +21,10 @@
 #include "core/alloc_func.hpp"
 
 /**
- * Try to retrive the current clipboard contents.
+ * Try to retrieve the current clipboard contents.
  *
- * @note OS-specific funtion.
- * @return True if some text could be retrived.
+ * @note OS-specific function.
+ * @return True if some text could be retrieved.
  */
 bool GetClipboardContents(char *buffer, size_t buff_len);
 
@@ -221,7 +221,7 @@ bool Textbuf::InsertClipboard()
 }
 
 /**
- * Checks if it is possible to move carret to the left
+ * Checks if it is possible to move caret to the left
  * @return true if the caret can be moved to the left, otherwise false.
  */
 bool Textbuf::CanMoveCaretLeft()
@@ -248,7 +248,7 @@ WChar Textbuf::MoveCaretLeft()
 }
 
 /**
- * Checks if it is possible to move carret to the right
+ * Checks if it is possible to move caret to the right
  * @return true if the caret can be moved to the right, otherwise false.
  */
 bool Textbuf::CanMoveCaretRight()
@@ -275,7 +275,7 @@ WChar Textbuf::MoveCaretRight()
 
 /**
  * Handle text navigation with arrow keys left/right.
- * This defines where the caret will blink and the next characer interaction will occur
+ * This defines where the caret will blink and the next character interaction will occur
  * @param navmode Direction in which navigation occurs (WKC_CTRL |) WKC_LEFT, (WKC_CTRL |) WKC_RIGHT, WKC_END, WKC_HOME
  * @return Return true on successful change of Textbuf, or false otherwise
  */
@@ -304,7 +304,7 @@ bool Textbuf::MovePos(int navmode)
 				if (!this->CanMoveCaretLeft()) return true;
 				c = this->MoveCaretLeft();
 			}
-			/* Place caret at the begining of the left word. */
+			/* Place caret at the beginning of the left word. */
 			this->MoveCaretRight();
 			return true;
 		}
diff --git a/src/tile_map.h b/src/tile_map.h
index 8dc4757..2c5cfff 100644
--- a/src/tile_map.h
+++ b/src/tile_map.h
@@ -105,8 +105,8 @@ static inline void SetTileType(TileIndex tile, TileType type)
  * This function checks if a tile got the given tiletype.
  *
  * @param tile The tile to check
- * @param type The type to check agains
- * @return true If the type matches agains the type of the tile
+ * @param type The type to check against
+ * @return true If the type matches against the type of the tile
  */
 static inline bool IsTileType(TileIndex tile, TileType type)
 {
@@ -169,7 +169,7 @@ static inline void SetTileOwner(TileIndex tile, Owner owner)
  * Checks if a tile belongs to the given owner
  *
  * @param tile The tile to check
- * @param owner The owner to check agains
+ * @param owner The owner to check against
  * @return True if a tile belongs the the given owner
  */
 static inline bool IsTileOwner(TileIndex tile, Owner owner)
diff --git a/src/tile_type.h b/src/tile_type.h
index 8a476e9..34543eb 100644
--- a/src/tile_type.h
+++ b/src/tile_type.h
@@ -52,7 +52,7 @@ enum TileType {
  *
  * In randomly generated maps:
  *  TROPICZONE_DESERT: Generated everywhere, if there is neither water nor mountains (TileHeight >= 4) in a certain distance from the tile.
- *  TROPICZONE_RAINFOREST: Genereated everywhere, if there is no desert in a certain distance from the tile.
+ *  TROPICZONE_RAINFOREST: Generated everywhere, if there is no desert in a certain distance from the tile.
  *  TROPICZONE_NORMAL: Everywhere else, i.e. between desert and rainforest and on sea (if you clear the water).
  *
  * In scenarios:
diff --git a/src/tilearea.cpp b/src/tilearea.cpp
index e6efd05..7572f9f 100644
--- a/src/tilearea.cpp
+++ b/src/tilearea.cpp
@@ -159,7 +159,7 @@ DiagonalTileIterator::DiagonalTileIterator(TileIndex corner1, TileIndex corner2)
 }
 
 /**
- * Move ourselves to the next tile in the rectange on the map.
+ * Move ourselves to the next tile in the rectangle on the map.
  */
 TileIterator &DiagonalTileIterator::operator++()
 {
diff --git a/src/tilearea_type.h b/src/tilearea_type.h
index 4596514..62d3d75 100644
--- a/src/tilearea_type.h
+++ b/src/tilearea_type.h
@@ -91,7 +91,7 @@ public:
 	}
 
 	/**
-	 * Move ourselves to the next tile in the rectange on the map.
+	 * Move ourselves to the next tile in the rectangle on the map.
 	 */
 	virtual TileIterator& operator ++() = 0;
 
@@ -118,7 +118,7 @@ public:
 	}
 
 	/**
-	 * Move ourselves to the next tile in the rectange on the map.
+	 * Move ourselves to the next tile in the rectangle on the map.
 	 */
 	inline TileIterator& operator ++()
 	{
@@ -148,7 +148,7 @@ private:
 	uint base_y; ///< The base tile y coordinate from where the iterating happens.
 	int a_cur;   ///< The current (rotated) x coordinate of the iteration.
 	int b_cur;   ///< The current (rotated) y coordinate of the iteration.
-	int a_max;   ///< The (rotated) x coordinats of the end of the iteration.
+	int a_max;   ///< The (rotated) x coordinate of the end of the iteration.
 	int b_max;   ///< The (rotated) y coordinate of the end of the iteration.
 
 public:
diff --git a/src/town.h b/src/town.h
index 2bb1fa9..a672c2c 100644
--- a/src/town.h
+++ b/src/town.h
@@ -209,7 +209,7 @@ enum TownActions {
 	TACT_BUILD_STATUE     = 0x10, ///< Build a statue.
 	TACT_FUND_BUILDINGS   = 0x20, ///< Fund new buildings.
 	TACT_BUY_RIGHTS       = 0x40, ///< Buy exclusive transport rights.
-	TACT_BRIBE            = 0x80, ///< Try to bribe the counsil.
+	TACT_BRIBE            = 0x80, ///< Try to bribe the council.
 
 	TACT_COUNT            = 8,    ///< Number of available town actions.
 
diff --git a/src/town_cmd.cpp b/src/town_cmd.cpp
index e186a87..abfa181 100644
--- a/src/town_cmd.cpp
+++ b/src/town_cmd.cpp
@@ -283,7 +283,7 @@ static Foundation GetFoundation_Town(TileIndex tile, Slope tileh)
 /**
  * Animate a tile for a town
  * Only certain houses can be animated
- * The newhouses animation superseeds regular ones
+ * The newhouses animation supersedes regular ones
  * @param tile TileIndex of the house to animate
  */
 static void AnimateTile_Town(TileIndex tile)
@@ -374,8 +374,8 @@ void UpdateAllTownVirtCoords()
 
 /**
  * Change the towns population
- * @param t Town which polulation has changed
- * @param mod polulation change (can be positive or negative)
+ * @param t Town which population has changed
+ * @param mod population change (can be positive or negative)
  */
 static void ChangePopulation(Town *t, int mod)
 {
@@ -804,9 +804,9 @@ static RoadBits GetTownRoadBits(TileIndex tile)
  *   Assuming a road from (tile - TileOffsByDiagDir(dir)) to tile,
  *   is there a parallel road left or right of it within distance dist_multi?
  *
- * @param tile curent tile
+ * @param tile current tile
  * @param dir target direction
- * @param dist_multi distance multiplyer
+ * @param dist_multi distance multiplayer
  * @return true if there is a parallel road
  */
 static bool IsNeighborRoadTile(TileIndex tile, const DiagDirection dir, uint dist_multi)
@@ -1173,7 +1173,7 @@ static void GrowTownInTile(TileIndex *tile_ptr, RoadBits cur_rb, DiagDirection t
 
 	} else if (target_dir < DIAGDIR_END && !(cur_rb & DiagDirToRoadBits(ReverseDiagDir(target_dir)))) {
 		/* Continue building on a partial road.
-		 * Should be allways OK, so we only generate
+		 * Should be always OK, so we only generate
 		 * the fitting RoadBits */
 		_grow_town_result = GROWTH_SEARCH_STOPPED;
 
@@ -2221,7 +2221,7 @@ static bool BuildTownHouse(Town *t, TileIndex tile)
 	while (probability_max > 0) {
 		/* Building a multitile building can change the location of tile.
 		 * The building would still be built partially on that tile, but
-		 * its nothern tile would be elsewere. However, if the callback
+		 * its northern tile would be elsewhere. However, if the callback
 		 * fails we would be basing further work from the changed tile.
 		 * So a next 1x1 tile building could be built on the wrong tile. */
 		tile = baseTile;
@@ -2859,7 +2859,7 @@ static CommandCost TownActionBribe(Town *t, DoCommandFlag flags)
 				}
 			}
 
-			/* only show errormessage to the executing player. All errors are handled command.c
+			/* only show error message to the executing player. All errors are handled command.c
 			 * but this is special, because it can only 'fail' on a DC_EXEC */
 			if (IsLocalCompany()) ShowErrorMessage(STR_ERROR_BRIBE_FAILED, INVALID_STRING_ID, WL_INFO);
 
diff --git a/src/town_gui.cpp b/src/town_gui.cpp
index 490bca5..8d726cb 100644
--- a/src/town_gui.cpp
+++ b/src/town_gui.cpp
@@ -668,7 +668,7 @@ private:
 
 		/* If 'b' is the same town as in the last round, use the cached value
 		 * We do this to speed stuff up ('b' is called with the same value a lot of
-		 * times after eachother) */
+		 * times after each other) */
 		if (tb != last_town) {
 			last_town = tb;
 			SetDParam(0, tb->index);
diff --git a/src/town_map.h b/src/town_map.h
index eb7ddb8..4150587 100644
--- a/src/town_map.h
+++ b/src/town_map.h
@@ -175,7 +175,7 @@ static inline void SetHouseCompleted(TileIndex t, bool status)
 /**
  * Gets the building stage of a house
  * Since the stage is used for determining what sprite to use,
- * if the house is complete (and that stage no longuer is available),
+ * if the house is complete (and that stage no longer is available),
  * fool the system by returning the TOWN_HOUSE_COMPLETE (3),
  * thus showing a beautiful complete house.
  * @param t the tile of the house to get the building stage of
diff --git a/src/townname.cpp b/src/townname.cpp
index 644a603..495fde4 100644
--- a/src/townname.cpp
+++ b/src/townname.cpp
@@ -157,7 +157,7 @@ static inline uint32 SeedModChance(byte shift_by, int max, uint32 seed)
 	 * than SeedChance(), which is absolutely horrible in that. If
 	 * you do not believe me, try with i.e. the Czech town names,
 	 * compare the words (nicely visible on prefixes) generated by
-	 * SeedChance() and SeedModChance(). Do not get dicouraged by the
+	 * SeedChance() and SeedModChance(). Do not get discouraged by the
 	 * never-use-modulo myths, which hold true only for the linear
 	 * congruential generators (and Random() isn't such a generator).
 	 * --pasky
diff --git a/src/track_func.h b/src/track_func.h
index a497dd4..0cd3dcf 100644
--- a/src/track_func.h
+++ b/src/track_func.h
@@ -113,7 +113,7 @@ static inline Track RemoveFirstTrack(TrackBits *tracks)
 /**
  * Removes first Trackdir from TrackdirBits and returns it
  *
- * This function searchs for the first bit in the TrackdirBits parameter,
+ * This function searches for the first bit in the TrackdirBits parameter,
  * remove this bit from the parameter and returns the fnound bit as
  * Trackdir value. It returns INVALID_TRACKDIR if the trackdirs is
  * TRACKDIR_BIT_NONE or INVALID_TRACKDIR_BIT. This is basically used in a
@@ -200,7 +200,7 @@ static inline bool IsValidTrack(Track track)
  * Checks if a Trackdir is valid.
  *
  * @param trackdir The value to check
- * @return true if the given valie is a valid Trackdir
+ * @return true if the given value is a valid Trackdir
  * @note Use this in an assert()
  */
 static inline bool IsValidTrackdir(Trackdir trackdir)
@@ -422,8 +422,8 @@ static inline DiagDirection TrackdirToExitdir(Trackdir trackdir)
  * direction which the DiagDirection is pointing. But this will be INVALID_TRACKDIR
  * if the DiagDirection is pointing 'away' the track.
  *
- * @param track The track to applie an direction on
- * @param diagdir The DiagDirection to applie on
+ * @param track The track to apply an direction on
+ * @param diagdir The DiagDirection to apply on
  * @return The resulting track direction or INVALID_TRACKDIR if not possible.
  */
 static inline Trackdir TrackExitdirToTrackdir(Track track, DiagDirection diagdir)
@@ -442,7 +442,7 @@ static inline Trackdir TrackExitdirToTrackdir(Track track, DiagDirection diagdir
  * you follow the DiagDirection and then turn by 45 deg left or right on the
  * next tile. The new direction on the new track will be the returning Trackdir
  * value. If the parameters makes no sense like the track TRACK_UPPER and the
- * diraction DIAGDIR_NE (target track cannot be reached) this function returns
+ * direction DIAGDIR_NE (target track cannot be reached) this function returns
  * INVALID_TRACKDIR.
  *
  * @param track The target track
@@ -524,7 +524,7 @@ static inline TrackdirBits DiagdirReachesTrackdirs(DiagDirection diagdir)
  * This will obviously include 90 degree turns, since no
  * information is available about the exact angle of entering
  *
- * @param diagdir The joining irection
+ * @param diagdir The joining direction
  * @return The tracks which can be used
  * @see DiagdirReachesTrackdirs
  */
@@ -545,7 +545,7 @@ static inline TrackdirBits TrackdirReachesTrackdirs(Trackdir trackdir)
 	return _exitdir_reaches_trackdirs[TrackdirToExitdir(trackdir)];
 }
 /* Note that there is no direct table for this function (there used to be),
- * but it uses two simpeler tables to achieve the result */
+ * but it uses two simpler tables to achieve the result */
 
 /**
  * Maps a trackdir to all trackdirs that make 90 deg turns with it.
@@ -609,7 +609,7 @@ static inline bool TracksOverlap(TrackBits bits)
 /**
  * Check if a given track is contained within or overlaps some other tracks.
  *
- * @param tracks Tracks to be testet against
+ * @param tracks Tracks to be tested against
  * @param track The track to test
  * @return true if the track is already in the tracks or overlaps the tracks.
  */
diff --git a/src/train.h b/src/train.h
index 85c9edf..b3b1693 100644
--- a/src/train.h
+++ b/src/train.h
@@ -37,7 +37,7 @@ enum VehicleRailFlags {
 enum TrainForceProceeding {
 	TFP_NONE   = 0,    ///< Normal operation.
 	TFP_STUCK  = 1,    ///< Proceed till next signal, but ignore being stuck till then. This includes force leaving depots.
-	TFP_SIGNAL = 2,    ///< Ignore next signal, after the signal ignore being stucked.
+	TFP_SIGNAL = 2,    ///< Ignore next signal, after the signal ignore being stuck.
 };
 typedef SimpleTinyEnumT<TrainForceProceeding, byte> TrainForceProceedingByte;
 
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index c7bad3b..e262a5f 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -3864,7 +3864,7 @@ bool Train::Tick()
 }
 
 /**
- * Check whether a train needs serivce, and if so, find a depot or service it.
+ * Check whether a train needs service, and if so, find a depot or service it.
  * @return v %Train to check.
  */
 static void CheckIfTrainNeedsService(Train *v)
diff --git a/src/train_gui.cpp b/src/train_gui.cpp
index 7888b0d..e463228 100644
--- a/src/train_gui.cpp
+++ b/src/train_gui.cpp
@@ -163,7 +163,7 @@ struct CargoSummaryItem {
 	uint amount;      ///< Amount that is carried
 	StationID source; ///< One of the source stations
 
-	/** Used by CargoSummary::Find() and similiar functions */
+	/** Used by CargoSummary::Find() and similar functions */
 	inline bool operator != (const CargoSummaryItem &other) const
 	{
 		return this->cargo != other.cargo || this->subtype != other.subtype;
@@ -251,7 +251,7 @@ static void TrainDetailsCapacityTab(const CargoSummaryItem *item, int left, int
 }
 
 /**
- * Collects the cargo transportet
+ * Collects the cargo transported
  * @param v Vehicle to process
  * @param summary Space for the result
  */
@@ -316,7 +316,7 @@ int GetTrainDetailsWndVScroll(VehicleID veh_id, TrainDetailsWindowTabs det_tab)
 			max_cargo[v->cargo_type] += v->cargo_cap;
 		}
 
-		/* Set scroll-amount seperately from counting, as to not compute num double
+		/* Set scroll-amount separately from counting, as to not compute num double
 		 * for more carriages of the same type
 		 */
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
diff --git a/src/transparency_gui.cpp b/src/transparency_gui.cpp
index 82e26e8..2e6c38a 100644
--- a/src/transparency_gui.cpp
+++ b/src/transparency_gui.cpp
@@ -140,7 +140,7 @@ static const NWidgetPart _nested_transparency_widgets[] = {
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_LOADING), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRAINLIST, STR_TRANSPARENT_LOADING_TOOLTIP),
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetFill(1, 1), EndContainer(),
 	EndContainer(),
-	/* Panel with 'inivisibility' buttons. */
+	/* Panel with 'invisibility' buttons. */
 	NWidget(WWT_PANEL, COLOUR_DARK_GREEN, WID_TT_BUTTONS), SetMinimalSize(219, 13), SetDataTip(0x0, STR_TRANSPARENT_INVISIBLE_TOOLTIP),
 	EndContainer(),
 };
diff --git a/src/tree_map.h b/src/tree_map.h
index 53e6bc4..105eb8d 100644
--- a/src/tree_map.h
+++ b/src/tree_map.h
@@ -27,7 +27,7 @@ enum TreeType {
 	TREE_TEMPERATE    = 0x00, ///< temperate tree
 	TREE_SUB_ARCTIC   = 0x0C, ///< tree on a sub_arctic landscape
 	TREE_RAINFOREST   = 0x14, ///< tree on the 'green part' on a sub-tropical map
-	TREE_CACTUS       = 0x1B, ///< a catus for the 'desert part' on a sub-tropical map
+	TREE_CACTUS       = 0x1B, ///< a cactus for the 'desert part' on a sub-tropical map
 	TREE_SUB_TROPICAL = 0x1C, ///< tree on a sub-tropical map, non-rainforest, non-desert
 	TREE_TOYLAND      = 0x20, ///< tree on a toyland map
 	TREE_INVALID      = 0xFF, ///< An invalid tree
@@ -104,7 +104,7 @@ static inline TreeGround GetTreeGround(TileIndex t)
  * tile. So this function returns the density of a tile for sub arctic
  * and sub tropical games. This means for sub arctic the type of snowline
  * (0 to 3 for all 4 types of snowtiles) and for sub tropical the value
- * 3 for a desert (and 0 for non-desert). The functionname is not read as
+ * 3 for a desert (and 0 for non-desert). The function name is not read as
  * "get the tree density of a tile" but "get the density of a tile which got trees".
  *
  * @param t The tile to get the 'density'
diff --git a/src/tunnelbridge_cmd.cpp b/src/tunnelbridge_cmd.cpp
index 3a53bb8..f5e8689 100644
--- a/src/tunnelbridge_cmd.cpp
+++ b/src/tunnelbridge_cmd.cpp
@@ -10,7 +10,7 @@
 /**
  * @file tunnelbridge_cmd.cpp
  * This file deals with tunnels and bridges (non-gui stuff)
- * @todo seperate this file into two
+ * @todo separate this file into two
  */
 
 #include "stdafx.h"
@@ -61,7 +61,7 @@ void ResetBridges()
 		}
 	}
 
-	/* Then, wipe out current bidges */
+	/* Then, wipe out current bridges */
 	memset(&_bridge, 0, sizeof(_bridge));
 	/* And finally, reinstall default data */
 	memcpy(&_bridge, &_orig_bridge, sizeof(_orig_bridge));
@@ -91,8 +91,8 @@ int CalcBridgeLenCostFactor(int length)
 /**
  * Get the foundation for a bridge.
  * @param tileh The slope to build the bridge on.
- * @param axis The axis of the bridge entrace.
- * @return The foundatiton required.
+ * @param axis The axis of the bridge entrance.
+ * @return The foundation required.
  */
 Foundation GetBridgeFoundation(Slope tileh, Axis axis)
 {
@@ -431,7 +431,7 @@ CommandCost CmdBuildBridge(TileIndex end_tile, DoCommandFlag flags, uint32 p1, u
 			if (flags & DC_EXEC) {
 				/* We do this here because when replacing a bridge with another
 				 * type calling SetBridgeMiddle isn't needed. After all, the
-				 * tile alread has the has_bridge_above bits set. */
+				 * tile already has the has_bridge_above bits set. */
 				SetBridgeMiddle(tile, direction);
 			}
 		}
@@ -591,7 +591,7 @@ CommandCost CmdBuildTunnel(TileIndex start_tile, DoCommandFlag flags, uint32 p1,
 
 	TileIndex end_tile = start_tile;
 
-	/* Tile shift coeficient. Will decrease for very long tunnels to avoid exponential growth of price*/
+	/* Tile shift coefficient. Will decrease for very long tunnels to avoid exponential growth of price*/
 	int tiles_coef = 3;
 	/* Number of tiles from start of tunnel */
 	int tiles = 0;
@@ -1076,7 +1076,7 @@ static void DrawBridgeTramBits(int x, int y, int z, int offset, bool overlay, bo
 
 /**
  * Draws a tunnel of bridge tile.
- * For tunnels, this is rather simple, as you only needa draw the entrance.
+ * For tunnels, this is rather simple, as you only need to draw the entrance.
  * Bridges are a bit more complex. base_offset is where the sprite selection comes into play
  * and it works a bit like a bitmask.<p> For bridge heads:
  * @param ti TileInfo of the structure to draw
@@ -1555,7 +1555,7 @@ static void TileLoop_TunnelBridge(TileIndex tile)
 	switch (_settings_game.game_creation.landscape) {
 		case LT_ARCTIC: {
 			/* As long as we do not have a snow density, we want to use the density
-			 * from the entry endge. For tunnels this is the lowest point for bridges the highest point.
+			 * from the entry edge. For tunnels this is the lowest point for bridges the highest point.
 			 * (Independent of foundations) */
 			int z = IsBridge(tile) ? GetTileMaxZ(tile) : GetTileZ(tile);
 			if (snow_or_desert != (z > GetSnowLine())) {
diff --git a/src/tunnelbridge_map.h b/src/tunnelbridge_map.h
index ff3a36a..0f7f17b 100644
--- a/src/tunnelbridge_map.h
+++ b/src/tunnelbridge_map.h
@@ -23,7 +23,7 @@
  * Bridge: Get the direction pointing onto the bridge
  * @param t The tile to analyze
  * @pre IsTileType(t, MP_TUNNELBRIDGE)
- * @return the above mentionned direction
+ * @return the above mentioned direction
  */
 static inline DiagDirection GetTunnelBridgeDirection(TileIndex t)
 {
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index 27b5e4b..f32fc9f 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -167,9 +167,9 @@ bool Vehicle::NeedsServicing() const
 }
 
 /**
- * Checks if the current order should be interupted for a service-in-depot-order.
+ * Checks if the current order should be interrupted for a service-in-depot-order.
  * @see NeedsServicing()
- * @return true if the current order should be interupted.
+ * @return true if the current order should be interrupted.
  */
 bool Vehicle::NeedsAutomaticServicing() const
 {
@@ -890,7 +890,7 @@ void CallVehicleTicks()
 				/* Play a running sound if the motion counter passes 256 (Do we not skip sounds?) */
 				if (GB(v->motion_counter, 0, 8) < v->cur_speed) PlayVehicleSound(v, VSE_RUNNING);
 
-				/* Play an alterate running sound every 16 ticks */
+				/* Play an alternating running sound every 16 ticks */
 				if (GB(v->tick_counter, 0, 4) == 0) PlayVehicleSound(v, v->cur_speed > 0 ? VSE_RUNNING_16 : VSE_STOPPED_16);
 		}
 	}
@@ -1769,7 +1769,7 @@ static PaletteID GetEngineColourMap(EngineID engine_type, CompanyID company, Eng
 		uint16 callback = GetVehicleCallback(CBID_VEHICLE_COLOUR_MAPPING, 0, 0, engine_type, v);
 		/* Failure means "use the default two-colour" */
 		if (callback != CALLBACK_FAILED) {
-			assert_compile(PAL_NONE == 0); // Returning 0x4000 (resp. 0xC000) conincidences with default value (PAL_NONE)
+			assert_compile(PAL_NONE == 0); // Returning 0x4000 (resp. 0xC000) coincidences with default value (PAL_NONE)
 			map = GB(callback, 0, 14);
 			/* If bit 14 is set, then the company colours are applied to the
 			 * map else it's returned as-is. */
@@ -2303,7 +2303,7 @@ void Vehicle::ShowVisualEffect() const
 				/* Electric train's spark - more often occurs when train is departing (more load)
 				 * Details: Electric locomotives are usually at least twice as powerful as their diesel counterparts, so spark
 				 * emissions are kept simple. Only when starting, creating huge force are sparks more likely to happen, but when
-				 * reaching its max. speed, quarter by quarter of it, chance decreases untill the usuall 2,22% at train's top speed.
+				 * reaching its max. speed, quarter by quarter of it, chance decreases until the usual 2,22% at train's top speed.
 				 * REGULATION:
 				 * - in Chance16 the last value is 360 / 2^smoke_amount (max. sparks when 90 = smoke_amount of 2). */
 				if (GB(v->tick_counter, 0, 2) == 0 &&
diff --git a/src/vehicle_gui.cpp b/src/vehicle_gui.cpp
index 19cc7d2..48b7938 100644
--- a/src/vehicle_gui.cpp
+++ b/src/vehicle_gui.cpp
@@ -1034,7 +1034,7 @@ static int CDECL VehicleCargoSorter(const Vehicle * const *a, const Vehicle * co
 	const Vehicle *v;
 	CargoArray diff;
 
-	/* Append the cargo of the connected weagons */
+	/* Append the cargo of the connected waggons */
 	for (v = *a; v != NULL; v = v->Next()) diff[v->cargo_type] += v->cargo_cap;
 	for (v = *b; v != NULL; v = v->Next()) diff[v->cargo_type] -= v->cargo_cap;
 
@@ -1068,7 +1068,7 @@ static int CDECL VehicleModelSorter(const Vehicle * const *a, const Vehicle * co
 	return (r != 0) ? r : VehicleNumberSorter(a, b);
 }
 
-/** Sort vehciles by their value */
+/** Sort vehicles by their value */
 static int CDECL VehicleValueSorter(const Vehicle * const *a, const Vehicle * const *b)
 {
 	const Vehicle *u;
@@ -2433,7 +2433,7 @@ public:
 					SetDParam(2, v->GetDisplaySpeed());
 					if (v->current_order.GetDepotActionType() & ODATFB_NEAREST_DEPOT) {
 						/* This case *only* happens when multiple nearest depot orders
-						 * follow eachother (including an order list only one order: a
+						 * follow each other (including an order list only one order: a
 						 * nearest depot order) and there are no reachable depots.
 						 * It is primarily to guard for the case that there is no
 						 * depot with index 0, which would be used as fallback for
diff --git a/src/viewport.cpp b/src/viewport.cpp
index 011064f..eac16a6 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -1431,7 +1431,7 @@ static void ViewportDrawStrings(DrawPixelInfo *dpi, const StringSpriteToDrawVect
 			/* Do not draw signs nor station names if they are set invisible */
 			if (IsInvisibilitySet(TO_SIGNS) && ss->string != STR_WHITE_SIGN) continue;
 
-			/* if we didn't draw a rectangle, or if transparant building is on,
+			/* if we didn't draw a rectangle, or if transperant building is on,
 			 * draw the text in the colour the rectangle would have */
 			if (IsTransparencySet(TO_SIGNS) && ss->string != STR_WHITE_SIGN) {
 				/* Real colours need the TC_IS_PALETTE_COLOUR flag
@@ -1439,7 +1439,7 @@ static void ViewportDrawStrings(DrawPixelInfo *dpi, const StringSpriteToDrawVect
 				colour = (TextColour)_colour_gradient[ss->colour][6] | TC_IS_PALETTE_COLOUR;
 			}
 
-			/* Draw the rectangle if 'tranparent station signs' is off,
+			/* Draw the rectangle if 'transparent station signs' is off,
 			 * or if we are drawing a general text sign (STR_WHITE_SIGN) */
 			if (!IsTransparencySet(TO_SIGNS) || ss->string == STR_WHITE_SIGN) {
 				DrawFrameRect(
@@ -1726,7 +1726,7 @@ static void SetSelectionTilesDirty()
 	int x_size = _thd.size.x;
 	int y_size = _thd.size.y;
 
-	if (!_thd.diagonal) { // Selecting in a straigth rectangle (or a single square)
+	if (!_thd.diagonal) { // Selecting in a straight rectangle (or a single square)
 		int x_start = _thd.pos.x;
 		int y_start = _thd.pos.y;
 
diff --git a/src/viewport_type.h b/src/viewport_type.h
index 2c29c83..a3dd0d7 100644
--- a/src/viewport_type.h
+++ b/src/viewport_type.h
@@ -32,7 +32,7 @@ struct ViewPort {
 	ZoomLevel zoom; ///< The zoom level of the viewport.
 };
 
-/** Margings for the viewport sign */
+/** Margins for the viewport sign */
 enum ViewportSignMargin {
 	VPSM_LEFT   = 1, ///< Left margin
 	VPSM_RIGHT  = 1, ///< Right margin
@@ -82,7 +82,7 @@ enum ViewportPlaceMethod {
 	VPM_X_LIMITED       =    7, ///< Drag only in X axis with limited size
 	VPM_Y_LIMITED       =    8, ///< Drag only in Y axis with limited size
 	VPM_RAILDIRS        = 0x40, ///< all rail directions
-	VPM_SIGNALDIRS      = 0x80, ///< similiar to VMP_RAILDIRS, but with different cursor
+	VPM_SIGNALDIRS      = 0x80, ///< similar to VMP_RAILDIRS, but with different cursor
 };
 DECLARE_ENUM_AS_BIT_SET(ViewportPlaceMethod)
 
diff --git a/src/widget_type.h b/src/widget_type.h
index 6d267e1..4a0f0ff 100644
--- a/src/widget_type.h
+++ b/src/widget_type.h
@@ -308,7 +308,7 @@ public:
 
 /**
  * Highlight the widget or not.
- * @param higlighted Widget must be highlighted (blink).
+ * @param highlighted_colour Widget must be highlighted (blink).
  */
 inline void NWidgetCore::SetHighlighted(TextColour highlight_colour)
 {
@@ -830,7 +830,7 @@ static inline uint ComputeMaxSize(uint base, uint max_space, uint step)
  *   the child widgets (it has no meaning for the compiler but it makes the widget parts easier to read).
  *   Below the last child widget, use an #EndContainer part. This part should be aligned with the #NWidget part that started the container.
  *
- * - Stacked widgets #NWidgetStacked map each of their childs onto the same space. It behaves like a container, except there is no pre/inter/post space,
+ * - Stacked widgets #NWidgetStacked map each of their children onto the same space. It behaves like a container, except there is no pre/inter/post space,
  *   so the widget does not support #SetPIP. #SetPadding is allowed though.
  *   Like the other container widgets, below the last child widgets, a #EndContainer part should be used to denote the end of the stacked widget.
  *
@@ -1071,7 +1071,7 @@ static inline NWidgetPart SetPIP(uint8 pre, uint8 inter, uint8 post)
 /**
  * Attach a scrollbar to a widget.
  * The scrollbar is controlled when using the mousewheel on the widget.
- * Multipe widgets can refer to the same scrollbar to make the mousewheel work in all of them.
+ * Multiple widgets can refer to the same scrollbar to make the mousewheel work in all of them.
  * @param index Widget index of the scrollbar.
  * @ingroup NestedWidgetParts
  */
diff --git a/src/window.cpp b/src/window.cpp
index c50c022..2f4fd18 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -2475,7 +2475,7 @@ static void HandleKeyScrolling()
 {
 	/*
 	 * Check that any of the dirkeys is pressed and that the focused window
-	 * dont has an edit-box as focused widget.
+	 * don't has an edit-box as focused widget.
 	 */
 	if (_dirkeys && !EditBoxInGlobalFocus()) {
 		int factor = _shift_pressed ? 50 : 10;
@@ -2806,7 +2806,7 @@ void SetWindowClassesDirty(WindowClass cls)
 /**
  * Mark this window's data as invalid (in need of re-computing)
  * @param data The data to invalidate with
- * @param gui_scope Whether the funtion is called from GUI scope.
+ * @param gui_scope Whether the function is called from GUI scope.
  */
 void Window::InvalidateData(int data, bool gui_scope)
 {
@@ -3071,7 +3071,7 @@ int PositionNewsMessage(Window *w)
 /**
  * (Re)position network chat window at the screen.
  * @param w Window structure of the network chat window, may also be \c NULL.
- * @return X coordinate of left edge of the repositioned network chat winodw.
+ * @return X coordinate of left edge of the repositioned network chat window.
  */
 int PositionNetworkChatWindow(Window *w)
 {
diff --git a/src/window_gui.h b/src/window_gui.h
index 6cd2187..c0beaf3 100644
--- a/src/window_gui.h
+++ b/src/window_gui.h
@@ -171,9 +171,9 @@ struct WindowDesc : ZeroedMemoryAllocator {
 
 	~WindowDesc();
 
-	WindowPosition default_pos;    ///< Prefered position of the window. @see WindowPosition()
-	int16 default_width;           ///< Prefered initial width of the window.
-	int16 default_height;          ///< Prefered initial height of the window.
+	WindowPosition default_pos;    ///< Preferred position of the window. @see WindowPosition()
+	int16 default_width;           ///< Preferred initial width of the window.
+	int16 default_height;          ///< Preferred initial height of the window.
 	WindowClass cls;               ///< Class of the window, @see WindowClass.
 	WindowClass parent_cls;        ///< Class of the parent window. @see WindowClass
 	uint32 flags;                  ///< Flags. @see WindowDefaultFlag
@@ -284,7 +284,7 @@ public:
 	WindowNumber window_number; ///< Window number within the window class
 
 	uint8 timeout_timer;      ///< Timer value of the WF_TIMEOUT for flags.
-	uint8 white_border_timer; ///< Timervalue of the WF_WHITE_BORDER for flags.
+	uint8 white_border_timer; ///< Timer value of the WF_WHITE_BORDER for flags.
 
 	int left;   ///< x position of left edge of the window
 	int top;    ///< y position of top edge of the window
